// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  December 8/2000
//
// Description:
//
//		This file contains the procedures which create and manipulate the
//		Visor panel UI.
//												
  
// Note: Updated on April 16, 2015 by Andrew Hazelden to add a Domemaster3D visor tab

if (!`scriptedPanelType -exists visorPanel`) 
//
// If you change this, you must also change the one in 
// initScriptedPanels.mel
//
{
	//
	//  Define the callbacks for the shader editor panel.
	//
	scriptedPanelType
		-createCallback		"createVisorPanel" 
		-initCallback		"initVisorPanel"
		-addCallback		"addVisorPanel"
		-removeCallback		"removeVisorPanel"
		-saveStateCallback	"saveStateVisorPanel"
		-deleteCallback		"deleteVisorPanel"
		-unique true
		visorPanel;

}

global proc string visorPanelName()
//
// Description:
//	This procedure returns the name of the panel containing the 
//	shader editor.
//	If there is no shader editor in existence, the behaviour of this
//	procedure is undefined.
//
//	ASSUMPTION: This procedure assumes there is a maximum of one 
//	shader editor open. 
//
{
	string $visorPanels[] = 
		`getPanel -scriptType "visorPanel"`;
	
	return $visorPanels[0];
}

// ---------------------------------------------------------------------------
// 	Registry to record tabs and their associated libraryUI, graphUI and
// 	collectionUI components.
// 

global string $gVisorPanelLookupTable[];
global int $gVisorPanelLookupTableCreated = false;

proc createVisorPanelLookupTable()
{
	//
	// Description:
	//	This procedure initializes the string array
	//	$gVisorPanelLookupTable[] for use as a lookup table. The lookup
	//	table will contain information about the tabs of the visor panel,
	//	and the UI contained within them.
	//

	global string $gVisorPanelLookupTable[];
	global int $gVisorPanelLookupTableCreated;

	if (!$gVisorPanelLookupTableCreated)
	{
		string $columns[];

		$columns[0] = "tab";
		$columns[1] = "type";
		$columns[2] = "componentName";
		$columns[3] = "optionVar";

		lookupTable($gVisorPanelLookupTable, $columns);
		$gVisorPanelLookupTableCreated = true;
	}
}

proc registerTab(
	string $tab,
	string $type,
	string $componentUI,
	string $optionVar)
{
	//
	// Description:
	//	This procedure enters information about the specified tab into the
	//	lookup table that contains information about all of the tabs in the
	//	visor panel.
	//

	if (	($type != "disk") 
		&&	($type != "paint effects") 
		&&	($type != "sculpting stamps") 
		&& 	($type != "scene"))
	{
		string $registerError = (uiRes("m_visorPanel.kTabRegisterError"));
		error
			-showLineNumber true
			$registerError ;
	}

	global string $gVisorPanelLookupTable[];
	string $row[];

	$row[0] = $tab;
	$row[1] = $type;
	$row[2] = $componentUI;
	$row[3] = $optionVar;

	lookupTableAddRow($gVisorPanelLookupTable, $row);
}

proc unregisterTab(
	string $tab)
{
	//
	// Description:
	//	This procedure removes information about the specified tab from the
	//	lookup table.
	//

	global string $gVisorPanelLookupTable[];

	lookupTableRemoveRow(
		$gVisorPanelLookupTable,
		"tab",
		$tab);
}

proc string lookupComponentName(
	string $tab)
{
	//
	// Description:
	//	This procedure uses the lookup table to look up the name of the
	//	UI component (ie libraryUI, collectionUI or graphUI) associated with 
	// 	the specified tab.
	//
	// Returns: 
	//	The name of the UI component associated with the specified tab.
	//

	global string $gVisorPanelLookupTable[];

	return lookupTableLookup(
		$gVisorPanelLookupTable,
		"tab",
		$tab,
		"componentName");
}

proc string lookupTabOptionVar(
	string $tab)
{
	//
	// Description:
	//	This procedure uses the lookup table to look up the name of the
	//	optionVar which stores information about the specified tab. The
	//	information stored in these optionVars is used to recreate tabs with
	//	the same characteristics in subsequent Maya sessions, and also to
	//	recreate tabs when the panel is torn off into a window.
	//
	// Returns: 
	//	The name of the optionVar associated with the specified tab.
	//

	global string $gVisorPanelLookupTable[];

	return lookupTableLookup(
		$gVisorPanelLookupTable,
		"tab",
		$tab,
		"optionVar");
}

proc string lookupOptionVarTab(
	string $optionVar)
{
	//
	// Description:
	//	This procedure uses the lookup table to look up the name of the tab
	//	associated with the specified optionVar.
	//
	// Returns: 
	//	The name of the tab associated with the specified optionVar.
	//

	global string $gVisorPanelLookupTable[];

	return lookupTableLookup(
		$gVisorPanelLookupTable,
		"optionVar",
		$optionVar,
		"tab");
}

proc string lookupTabType(
	string $tab)
{
	//
	// Description:
	//	This procedure uses the lookup table to look up the type (disk, scene,
	//	graph, protected graph) of the specified tab.
	//
	// Returns: 
	//	The type of the specified tab.
	//

	global string $gVisorPanelLookupTable[];

	return lookupTableLookup(
		$gVisorPanelLookupTable,
		"tab",
		$tab,
		"type");
}

proc int isDiskTab(
	string $tab)
{
	//
	// Description:
	//	This procedure is used to query whether the specified tab is a disk
	//	tab.
	//
	// Returns: 
	//	True if the tab is a disk tab, false if not.
	//

	global string $gVisorPanelLookupTable[];

	return (lookupTabType($tab) == "disk");
}

proc int isPaintEffectsTab(
	string $tab)
{
	//
	// Description:
	//	This procedure is used to query whether the specified tab is a paint
	//	effects tab.
	//
	// Returns: 
	//	True if the tab is a paint effects tab, false if not.
	//

	global string $gVisorPanelLookupTable[];

	return (lookupTabType($tab) == "paint effects");
}

proc int isSculptStampsTab(string $tab)
{
	//
	// Description:
	//	This procedure is used to query whether the specified tab is a
	//	sculpt stamps tab.
	//
	// Returns: 
	//	True if the tab is a sculpt stamps tab, false if not.
	//

	global string $gVisorPanelLookupTable[];

	return (lookupTabType($tab) == "sculpting stamps");
}

proc int isSceneTab(
	string $tab)
{
	//
	// Description:
	//	This procedure is used to query whether the specified tab is a scene
	//	tab.
	//
	// Returns: 
	//	True if the tab is a scene tab, false if not.
	//

	global string $gVisorPanelLookupTable[];

	return (lookupTabType($tab) == "scene");
}

// ---------------------------------------------------------------------------
// 	Procedures to find out information about the current tab
// 

proc string activeTabLayout(
	string $panel)
{
	//
	// Description:
	//	This procedure determines the name of the tab layout in the visor panel.
	//
	// Returns: 
	//	The name of the tab layout in the visor panel.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	setParent $panel;

	string $activeTabLayout;

	$activeTabLayout = "firstPaneTabs";

	$activeTabLayout = `setParent $activeTabLayout`;

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;

	return $activeTabLayout;
}

proc string activeTab(
	string $panel)
{
	//
	// Description:
	//	This procedure determines the name of the frontmost tab in the tab 
	//	layout in the active pane of the visor panel.
	//
	// Returns: 
	//	The name of the tab.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	setParent $panel;
	string $activeTabLayout = `setParent firstPaneTabs`;

	string $activeTab;
	$activeTab = `tabLayout -query -selectTab $activeTabLayout`;
	$activeTab = `setParent $activeTab`;

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;

	return $activeTab;
}

proc string activeTabIndex(
	string $panel)
{
	//
	// Description:
	//	This procedure determines the index of the frontmost tab in the tab 
	//	layout in the active pane of the visor panel.
	//
	// Returns: 
	//	The index of the tab within the active tab layout.
	//

	string $activeTabLayout = activeTabLayout($panel);
	
	int $activeTabIndex;
	$activeTabIndex = `tabLayout -query -selectTabIndex $activeTabLayout`;

	return $activeTabIndex;
}

proc string activeTabLabel(
	string $panel)
{
	//
	// Description:
	//	This procedure determines the label of the frontmost tab in the tab 
	//	layout in the active pane of the visor panel.
	//
	// Returns: 
	//	The label of the tab.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	setParent $panel;
	string $activeTabLayout = activeTabLayout($panel);
	int $activeTabIndex = activeTabIndex($panel);

	string $tabLabelArray[];
	$tabLabelArray = `tabLayout -query -tabLabel $activeTabLayout`;

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;

	return $tabLabelArray[$activeTabIndex - 1];
}

// ---------------------------------------------------------------------------
// 	Procedures to save/access information in option vars about the tab 
//	layouts and settings of individual tabs
// 
proc string tabLabel(
	string $tab)
{
	//
	// Description:
	//	This procedure determines the label of the specified tab.
	//
	// Returns: 
	//	The label of the specified tab.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	string $tabLabel = "";

	setParent $tab;
	setParent ..;
	string $tabLayout = `setParent -query`;
	string $tabLabelArray[] = `tabLayout -query -tabLabel $tabLayout`;
	string $tabArray[] = `tabLayout -query -childArray $tabLayout`;

	int $i;

	for ($i = 0; ($i < size($tabArray)) && ($tabLabel == ""); $i++)
	{
		setParent $tabLayout;
		$tabArray[$i] = `setParent $tabArray[$i]`;

		if ($tabArray[$i] == $tab)
		{
			$tabLabel = $tabLabelArray[$i];
		}
	}

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;

	return $tabLabel;
}

proc string generateUniqueTabOptionVarName()
{
	//
	// Description:
	//	This procedure is used to create a unique name for an optionVar in
	//	which information about a tab will be stored.
	//
	// Returns: 
	//	A unique name for an optionVar.
	//

	int $i = 1;
	string $optionVarName;

	do
	{
		$optionVarName = ("visorTab" + $i);
		$i++;
	}
	while (`optionVar -exists $optionVarName`);

	return $optionVarName;
}

proc updateTabOptionVar(
	string $optionVar,
	string $tab)
{
	//
	// Description:
	//	This procedure is called from updateTabOptionVar() and from
	//	createTabOptionVar(). It encapsulates some shared functionality of the
	//	two other procedures. 
	//	This procedure generates a unique name for a tab option var if no name
	//	is provided in $optionVar. This procedure looks up the type of the tab
	//	in the lookup table if the type is not specified in $type.
	//	This procedure then gathers all of the information about the specified
	//	tab which needs to be stored in the optionVar, and saves that
	//	information in the optionVar in a known format.
	//	
	// Returns: 
	//	This procedure returns the name of the optionVar into which the
	//	information was stored.
	//

	if ($optionVar == "")
	{
		// No optionVar name was specified, so we create a new one.
		//
		$optionVar = generateUniqueTabOptionVarName();
	}

	//
	// Now we gather all of the information we need to store about the tab.
	//

	string $type = lookupTabType($tab);
	string $tabLabel = tabLabel($tab);
	string $component = lookupComponentName($tab);
	string $stateDescription[];

	optionVar -intValue $optionVar 1;
	optionVar -stringValue ($optionVar + "Label") $tabLabel;
	optionVar -stringValue ($optionVar + "Type") $type;

	if ($type == "disk" || $type == "paint effects" || $type == "sculpting stamps")
	{
		optionVar 
			-stringValue ($optionVar + "DirectoriesVisorName") 
			`libraryUIDirectoriesVisor($component)`;
		optionVar 
			-stringValue ($optionVar + "FilesVisorName") 
			`libraryUIFilesVisor($component)`;
		optionVar 
			-stringValue ($optionVar + "RootDirectory") 
			`libraryUIRootDirectory($component)`;
		optionVar 
			-stringValue ($optionVar + "CurrentDirectory") 
			`libraryUICurrentDirectory($component)`;
		optionVar 
			-intValue ($optionVar + "DirectoriesShown") 
			`libraryUIDirectoriesShown($component)`;
		optionVar 
			-intValue ($optionVar + "FilesShown") 
			`libraryUIFilesShown($component)`;
	}
	else if ($type == "scene")
	{
		optionVar 
			-stringValue ($optionVar + "HypershadeName") 
			`collectionUIHypershadeName($component)`;
		optionVar 
			-stringValue ($optionVar + "Filter") 
			`collectionUIFilter($component)`;
	}
	else
	{
		string $errorMsg = (uiRes("m_visorPanel.kUnexpectedTabType"));
		string $errorDisplay = `format -s $type $errorMsg`;
		error
			-showLineNumber true
			$errorDisplay;
	}
}

proc setTabLabel(
	string $tab,
	string $label)
{
	//
	// Description:
	//	This procedure sets the label of the specified tab.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	setParent $tab;
	setParent ..;
	string $tabLayout = `setParent -query`;
	string $tabLabelArray[] = `tabLayout -query -tabLabel $tabLayout`;
	string $tabArray[] = `tabLayout -query -childArray $tabLayout`;

	int $i;
	string $shortTabName;
	int $found = false;

	for ($i = 0; ($i < size($tabArray)) && (!$found); $i++)
	{
		setParent $tabLayout;
		$shortTabName = $tabArray[$i];
		$tabArray[$i] = `setParent $tabArray[$i]`;

		if ($tabArray[$i] == $tab)
		{
			$found = true;
		}
	}

	if ($found)
	{
		tabLayout
			-edit
			-tabLabel $shortTabName $label
			$tabLayout;
	}

	// Save the new tab label so that it will be remembered the next time the
	// visor is opened.
	//
	string $optionVar = lookupTabOptionVar($tab);
	updateTabOptionVar($optionVar, $tab);

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;
}


proc string tabTypeFromOptionVar(
	string $optionVar)
{
	//
	// Description:
	//	This procedure retrieves the type of the tab whose information is
	//	stored in the specified optionVar.
	//
	// Returns: 
	//	The type of the tab.
	//

	string $valueArray[];
	$valueArray = `optionVar -query $optionVar`;

	return $valueArray[0];
}

proc string tabLabelFromOptionVar(
	string $optionVar)
{
	//
	// Description:
	//	This procedure retrieves the label of the tab whose information is
	//	stored in the specified optionVar.
	//
	// Returns: 
	//	The label of the tab.
	//

	string $valueArray[];
	$valueArray = `optionVar -query $optionVar`;

	return $valueArray[1];
}

proc deleteOptionVar(
	string $optionVar)
{
	//
	// Description:
	//	This method is called from deleteTabOptionVar() or from
	//	deleteUnusedOptionVars(). 
	//	This method deletes the specified optionVar and the optionVars related
	//	to it.
	//	The specified optionVar actually serves no purpose except to act as a
	//	prefix for the related optionVars.
	//

	optionVar -remove $optionVar;
	optionVar -remove ($optionVar + "Label");
	optionVar -remove ($optionVar + "Type");
	optionVar -remove ($optionVar + "DirectoriesVisorName");
	optionVar -remove ($optionVar + "FilesVisorName");
	optionVar -remove ($optionVar + "RootDirectory"); 
	optionVar -remove ($optionVar + "CurrentDirectory"); 
	optionVar -remove ($optionVar + "DirectoriesShown");
	optionVar -remove ($optionVar + "FilesShown"); 
	optionVar -remove ($optionVar + "HypershadeName");
	optionVar -remove ($optionVar + "Filter");
}

proc deleteTabOptionVar(
	string $tab)
{
	//
	// Description:
	//	This procedure deletes the optionVar associated with the specified tab.
	//

	string $optionVar = lookupTabOptionVar($tab);
	deleteOptionVar($optionVar);
}

proc deleteUnusedTabOptionVars(
	string $panel)
{
	//
	// Description:
	//	This procedure is called the first time visor is opened each
	//	session.
	//	This procedure deletes all optionVars whose names indicate that they
	//	contain information about visor panel tabs, but which are not
	//	being used for some reason. This is done so that the user's userPrefs
	//	does not fill up with unused optionVars.
	//

	int $i;

	for ($i = 0; $i < 100; $i++)
	{
		string $optionVar = ("visorTab" + $i);
		if (`optionVar -exists $optionVar`)
		{
			if (lookupOptionVarTab($optionVar) == "")
			{
				deleteOptionVar($optionVar);
			}
		}
	}
}

proc updateTabLayoutOptionVar(
	string $panel,
	string $tabLayout)
{
	//
	// Description:
	//	This procedure should be called whenever a change is made to the tab
	//	layouts in the visor panel which we want to save to an optionVar
	//	in order to be able to recreate the same tab layout structure at a
	//	later time. For example, we would want to call this procedure if we had
	//	moved a tab left or right within the tab layout.
	//	This procedure writes out an option var which names all of the option
	//	vars describing properties of the tabs in the specified tab layout. 
	//	The tab option vars are named in order from left to right.
	//

	string $oldParent = `setParent -query`;
	setParent $panel;

	string $tabLayoutOptionVar;

	if ($tabLayout == "firstPaneTabs")
	{
		$tabLayoutOptionVar = "visorFirstPaneTabs";
	}
	else
	{
		string $tabMsg = (uiRes("m_visorPanel.kUnexpectedTabLayout"));
		string $tabDisplay = `format -s $tabLayout $tabMsg`;
		error
			-showLineNumber true
			$tabDisplay;
	}

	// Delete the existing optionVar for the tabs in this pane, because we are
	// going to rebuild it.
	//
	optionVar -remove $tabLayoutOptionVar;

	// Unmanage the tabLayout because what we are about to do can cause some
	// flicker.
	//
	tabLayout -edit -manage false $tabLayout;

	// Take note of the currently selected tab because we will be changing the
	// tab selection and will want to restore the current selection later
	//
	int $selectedTabIndex = `tabLayout -query -selectTabIndex $tabLayout`;

	int $numTabs = `tabLayout -query -numberOfChildren $tabLayout`;
	string $tabArray[];
	int $i;

	// For each tab in the tabLayout of the first pane
	//
	for ($i = 0; $i < $numTabs; $i++)
	{
		// Select the tab and query the layout associated with the selected
		// tab. The name of the layout is stored in $tabArray and will be used
		// later as the key to be used in looking up the optionVar of the tab
		// in the lookup table.
		//
		// Previously, a more straightforward approach of using the tabLayout
		// -childArray flag was used, but it turned out the -childArray flag
		// does not return the names of the children in the order in which they
		// appear in the tab layout, but instead in the order in which they
		// were added to the tab layout.
		//
		tabLayout -edit -selectTabIndex ($i + 1) $tabLayout;
		$tabArray[$i] = `tabLayout -query -selectTab $tabLayout`;
	}

	// Reselect the previously selected tab
	//
	tabLayout -edit -selectTabIndex $selectedTabIndex $tabLayout;

	// Remanage the tab layout
	//
	tabLayout -edit -manage true $tabLayout;

	// Now that we have a list of the layouts associated with the tabs, we can
	// lookup the name of the optionVar associated with each and store it in
	// the optionVar which describes the ordering of the tabs.
	//
	string $tab;
	string $tabOptionVar;

	for ($i = 0; $i < size($tabArray); $i++)
	{
		$tab = $tabArray[$i];
		setParent $panel;
		$tab = `setParent $tab`;

		// Lookup the optionVar which describes this tab
		//
		$tabOptionVar = lookupTabOptionVar($tab);

		if ($tabOptionVar == "")
		{
			global string $gVisorPanelLookupTable[];
			lookupTablePrint($gVisorPanelLookupTable);

			error
				-showLineNumber true
				(uiRes("m_visorPanel.kNonemptyTabOptionVarName")) ;
		}

		// Append the name of the optionVar to the optionVar describing the
		// tabs in this pane
		//
		optionVar -stringValueAppend $tabLayoutOptionVar $tabOptionVar;
	}

	if ($oldParent != "NONE") setParent $oldParent;
}

// ---------------------------------------------------------------------------
// 	UI creation procedures
// 

proc string createDiskTab(
	string $panel,
	string $parentLayout,
	string $tabLabel,
	string $directory)
{
	//
	// Description:
	//	This procedure is called when the user creates a new disk tab, or when
	//	the default tabs are being created (ie the first time the user uses the
	//	visor panel or as a result of a revert to default tabs). 
	//	This procedure creates a disk tab.
	//
	// Returns: 
	//	The name of the newly created tab.
	//

	setParent $panel;
	setParent $parentLayout;
		string $tab = `formLayout`;
			// Create the library UI. The second and third parameters are blank
			// because we want to have new directory and files visors created,
			// rather than specifying existing ones to be used.
			//
			string $libraryUI = 
				libraryUI(
					$tab, 
					"", 	// directoriesVisorName
					""); 	// filesVisorName
		setParent ..; // from $tab
	setParent ..; // from $parentLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$parentLayout;
	
	// Configure the libraryUI
	//
	libraryUISetRootDirectory($libraryUI, $directory);
	libraryUISetFilesPopupMenuScript(
		$libraryUI,
		("visorPanelDiskTabPopupMenu " + $panel));

	string $optionVar = generateUniqueTabOptionVarName();
	registerTab($tab, "disk", $libraryUI, $optionVar);
	updateTabOptionVar($optionVar, $tab);

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $parentLayout);

	// Return the name of the tab which was created.
	//
	return $tab;
}

proc string createVisorDefaultTab( 
	string $runTimeDir, 
	string $panel, 
	string $panelLabel, 
	string $relativeDir, 
	string $newTabLabel )
{
	string $fullDir = ($runTimeDir + $relativeDir);
	string $tab = createDiskTab( $panel, $panelLabel, $newTabLabel, $fullDir);	

	// Return the name of the tab which was created.
	//
	return $tab;
}

proc string recreateDiskTab(
	string $panel,
	string $parentLayout,
	string $optionVar, 
	int $reuseEditors)
{
	//
	// Description:
	//	This procedure is called when a disk tab is being recreated from an
	//	optionVar.
	//	This procedure creates a disk tab using the information stored in the
	//	specified optionVar.
	//
	// Returns: 
	//	The name of the newly created tab.
	//

	string $tabLabel 
		= `optionVar -query ($optionVar + "Label")`;
	string $directoriesVisorName;
	string $filesVisorName;

	if ($reuseEditors)
	{
		$directoriesVisorName 
			= `optionVar -query ($optionVar + "DirectoriesVisorName")`;
		$filesVisorName 
			= `optionVar -query ($optionVar + "FilesVisorName")`;
	}

	setParent $panel;
	setParent $parentLayout;
		string $tab = `formLayout`;
			// Create the library UI specifying that our existing directory and
			// files visors should be used.
			//
			string $libraryUI = 
				libraryUI(
					$tab, 
					$directoriesVisorName,
					$filesVisorName);
		setParent ..; // from $tab
	setParent ..; // from $parentLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$parentLayout;

	// Configure the libraryUI according to saved state.
	//
	//	Do not use the full path assigned to the root directory option var.
	//	The full path may not point to the correct location when Maya is
	//	installed to a different area. Instead, determine the Maya install
	//	location and use relative path names to find the Visor tabs.
	//
	//	Get the install area.
	//
	string $runTimeDir = `getenv "MAYA_LOCATION"`;
	string $rootDirectory = `optionVar -query ($optionVar + "RootDirectory")`;
	string $projectsDir = `internalVar -userWorkspaceDir`;

  string $domeRunTimeDir = `getenv "DOMEMASTER3D_MAYA_DIR"` + "/common";
  string $domeRelDir = "/presets/Domemaster3D/examples";
  
	//	Construct the appropriate visor tab directory based on the 
	//	Maya install area.
	//
	if( "Domemaster3D Examples" == $tabLabel ) {
		$rootDirectory = $domeRunTimeDir + $domeRelDir;
	} else if ( visorPanelTabs_melToUI( "Projects" ) == $tabLabel ) {
		$rootDirectory = $projectsDir;
	} else if( visorPanelTabs_melToUI( "Ocean Examples" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/presets/fluids/ocean";
	} else if( visorPanelTabs_melToUI( "Hair Examples" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/presets/hair/examples";
	} else if ( visorPanelTabs_melToUI( "nCloth Examples" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/presets/nCloth/examples";
	} else if ( visorPanelTabs_melToUI( "Effects Assets" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/presets/EffectsAssets/examples";
	} else if ( visorPanelTabs_melToUI( "nParticle Examples" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/presets/nParticles/examples";
	} else if ( visorPanelTabs_melToUI( "Fluid Examples" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/presets/fluids/examples";
	} else if ( visorPanelTabs_melToUI( "Fluid Initial States" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/presets/fluids/initialStates";
	} else if ( visorPanelTabs_melToUI( "Bifrost Examples" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/presets/bifrost/examples";
	} else if ( visorPanelTabs_melToUI( "Sculpting Base Meshes" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/presets/Sculpt";
	} else if ( visorPanelTabs_melToUI( "Toon Examples" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/presets/toon/examples";
	} else if ( visorPanelTabs_melToUI( "HumanIK Examples" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/presets/hik/examples";
	} else if ( visorPanelTabs_melToUI( "Mocap Examples" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/presets/mocap/examples";
	}

	libraryUISetRootDirectory($libraryUI, $rootDirectory);

	libraryUISetCurrentDirectory(
		$libraryUI,
		`optionVar -query ($optionVar + "CurrentDirectory")`);

	if (`optionVar -query ($optionVar + "DirectoriesShown")` == 1)
	{
		if (`optionVar -query ($optionVar + "FilesShown")` == 1)
		{
			libraryUIShowDirectoriesAndFiles($libraryUI);
		}
		else
		{
			libraryUIShowDirectoriesOnly($libraryUI);
		}
	}
	else
	{
		libraryUIShowFilesOnly($libraryUI);
	}

	libraryUISetFilesPopupMenuScript(
		$libraryUI,
		("visorPanelDiskTabPopupMenu " + $panel));

	registerTab($tab, "disk", $libraryUI, $optionVar);

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $parentLayout);

	// Return the name of the tab which was created.
	//
	return $tab;
}

proc string createPaintEffectsTab(
	string $panel,
	string $parentLayout,
	string $tabLabel,
	string $directory)
{
	//
	// Description:
	//	This procedure is called when the user creates a new paint effects tab, 
	//	or when the default tabs are being created (ie the first time the user 
	// 	uses the visor panel or as a result of a revert to default tabs). 
	//	This procedure creates a paint effects tab.
	//
	// Returns: 
	//	The name of the newly created tab.
	//

	setParent $panel;
	setParent $parentLayout;
		string $tab = `formLayout`;
			// Create the library UI. The second and third parameters are blank
			// because we want to have new directory and files visors created,
			// rather than specifying existing ones to be used.
			//
			string $libraryUI = 
				libraryUI(
					$tab, 
					"", 	// directoriesVisorName
					""); 	// filesVisorName
		setParent ..; // from $tab
	setParent ..; // from $parentLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$parentLayout;

	// Configure the libraryUI
	//
	libraryUIUseForPaintEffects($libraryUI);
	libraryUISetRootDirectory($libraryUI, $directory);
	libraryUISetFilesPopupMenuScript(
		$libraryUI,
		("visorPanelPaintEffectsTabPopupMenu " + $panel));
	libraryUISetFilePressScript(
		$libraryUI,
		"visorPanelBrushPressCallback");

	string $optionVar = generateUniqueTabOptionVarName();
	registerTab($tab, "paint effects", $libraryUI, $optionVar);
	updateTabOptionVar($optionVar, $tab);

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $parentLayout);

	// Return the name of the tab which was created.
	//
	return $tab;
}

proc string recreatePaintEffectsTab(
	string $panel,
	string $parentLayout,
	string $optionVar,
	int $reuseEditors)
{
	//
	// Description:
	//	This procedure is called when a paint effects tab is being recreated 
	//	from an optionVar.
	//	This procedure creates a paint effects tab using the information stored
	//	in the specified optionVar.
	//
	// Returns: 
	//	The name of the newly created tab.
	//

	string $tabLabel 
		= `optionVar -query ($optionVar + "Label")`;
	string $directoriesVisorName;
	string $filesVisorName;

	if ($reuseEditors)
	{
		$directoriesVisorName 
			= `optionVar -query ($optionVar + "DirectoriesVisorName")`;
		$filesVisorName 
			= `optionVar -query ($optionVar + "FilesVisorName")`;
	}

	setParent $panel;
	setParent $parentLayout;
		string $tab = `formLayout`;
			// Create the library UI specifying that our existing directory and
			// files visors should be used.
			//
			string $libraryUI = 
				libraryUI(
					$tab, 
					$directoriesVisorName,
					$filesVisorName);
		setParent ..; // from $tab
	setParent ..; // from $parentLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$parentLayout;

	// Configure the libraryUI according to saved state
	//
	libraryUIUseForPaintEffects($libraryUI);

	//
	//	Do not use the full path assigned to the root directory option var.
	//	The full path may not point to the correct location when Maya is
	//	installed to a different area. Instead, determine the Maya install
	//	location and use relative path names to find the Visor tabs.
	//
	//	Get the install area.
	//
	string $runTimeDir = `getenv "MAYA_LOCATION"`;
	string $rootDirectory = `optionVar -query ($optionVar + "RootDirectory")`;

	//	Construct the appropriate visor tab directory based on the 
	//	Maya install area.
	//
	if( visorPanelTabs_melToUI( "Paint Effects" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/brushes";
	}
	
	libraryUISetRootDirectory($libraryUI, $rootDirectory);

	libraryUISetCurrentDirectory(
		$libraryUI,
		`optionVar -query ($optionVar + "CurrentDirectory")`);

	if (`optionVar -query ($optionVar + "DirectoriesShown")`)
	{
		if (`optionVar -query ($optionVar + "FilesShown")`)
		{
			libraryUIShowDirectoriesAndFiles($libraryUI);
		}
		else
		{
			libraryUIShowDirectoriesOnly($libraryUI);
		}
	}
	else
	{
		libraryUIShowFilesOnly($libraryUI);
	}

	libraryUISetFilesPopupMenuScript(
		$libraryUI,
		("visorPanelPaintEffectsTabPopupMenu " + $panel));
	libraryUISetFilePressScript(
		$libraryUI,
		"visorPanelBrushPressCallback");

	registerTab($tab, "paint effects", $libraryUI, $optionVar);

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $parentLayout);

	// Return the name of the tab which was created.
	//
	return $tab;
}

proc string createSculptStampsTab(
	string $panel,
	string $parentLayout,
	string $tabLabel,
	string $directory)
{
	//
	// Description:
	//	This procedure is called when the user creates a new sculpting stamps tab, 
	//	or when the default tabs are being created (ie the first time the user 
	// 	uses the visor panel or as a result of a revert to default tabs). 
	//	This procedure creates a sculpting stamps tab.
	//
	// Returns: 
	//	The name of the newly created tab.
	//

	setParent $panel;
	setParent $parentLayout;
		string $tab = `formLayout`;
			// Create the library UI. The second and third parameters are blank
			// because we want to have new directory and files visors created,
			// rather than specifying existing ones to be used.
			//
			string $libraryUI = 
				libraryUI(
					$tab, 
					"", 	// directoriesVisorName
					""); 	// filesVisorName
		setParent ..; // from $tab
	setParent ..; // from $parentLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$parentLayout;

	// Configure the libraryUI
	//
	libraryUIUseForPaintEffects($libraryUI);
	libraryUISetRootDirectory($libraryUI, $directory);
	libraryUISetFilesPopupMenuScript(
		$libraryUI,
		("visorPanelSculptStampsTabPopupMenu " + $panel));
	libraryUISetFilePressScript(
		$libraryUI,
		"visorPanelSculptStampsPressCallback");

	string $optionVar = generateUniqueTabOptionVarName();
	registerTab($tab, "sculpting stamps", $libraryUI, $optionVar);
	updateTabOptionVar($optionVar, $tab);

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $parentLayout);

	// Return the name of the tab which was created.
	//
	return $tab;
}

proc string recreateSculptStampsTab(
	string $panel,
	string $parentLayout,
	string $optionVar,
	int $reuseEditors)
{
	//
	// Description:
	//	This procedure is called when a sculpting stamps tab is being recreated 
	//	from an optionVar.
	//	This procedure creates a sculpting stamps tab using the information stored
	//	in the specified optionVar.
	//
	// Returns: 
	//	The name of the newly created tab.
	//

	string $tabLabel 
		= `optionVar -query ($optionVar + "Label")`;
	string $directoriesVisorName;
	string $filesVisorName;

	if ($reuseEditors)
	{
		$directoriesVisorName 
			= `optionVar -query ($optionVar + "DirectoriesVisorName")`;
		$filesVisorName 
			= `optionVar -query ($optionVar + "FilesVisorName")`;
	}

	setParent $panel;
	setParent $parentLayout;
		string $tab = `formLayout`;
			// Create the library UI specifying that our existing directory and
			// files visors should be used.
			//
			string $libraryUI = 
				libraryUI(
					$tab, 
					$directoriesVisorName,
					$filesVisorName);
		setParent ..; // from $tab
	setParent ..; // from $parentLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$parentLayout;

	// Configure the libraryUI according to saved state
	//
	libraryUIUseForPaintEffects($libraryUI);

	//
	//	Do not use the full path assigned to the root directory option var.
	//	The full path may not point to the correct location when Maya is
	//	installed to a different area. Instead, determine the Maya install
	//	location and use relative path names to find the Visor tabs.
	//
	//	Get the install area.
	//
	string $runTimeDir = `getenv "MAYA_LOCATION"`;
	string $rootDirectory = `optionVar -query ($optionVar + "RootDirectory")`;

	//	Construct the appropriate visor tab directory based on the 
	//	Maya install area.
	//
	if( visorPanelTabs_melToUI( "Sculpting Stamps" ) == $tabLabel ) {
		$rootDirectory = $runTimeDir + "/presets/Stamp";
	}
	
	libraryUISetRootDirectory($libraryUI, $rootDirectory);

	libraryUISetCurrentDirectory(
		$libraryUI,
		`optionVar -query ($optionVar + "CurrentDirectory")`);

	if (`optionVar -query ($optionVar + "DirectoriesShown")`)
	{
		if (`optionVar -query ($optionVar + "FilesShown")`)
		{
			libraryUIShowDirectoriesAndFiles($libraryUI);
		}
		else
		{
			libraryUIShowDirectoriesOnly($libraryUI);
		}
	}
	else
	{
		libraryUIShowFilesOnly($libraryUI);
	}

	libraryUISetFilesPopupMenuScript(
		$libraryUI,
		("visorPanelSculptStampsTabPopupMenu " + $panel));
	libraryUISetFilePressScript(
		$libraryUI,
		"visorPanelSculptStampsPressCallback");

	registerTab($tab, "sculpting stamps", $libraryUI, $optionVar);

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $parentLayout);

	// Return the name of the tab which was created.
	//
	return $tab;
}

proc string createSceneTab(
	string $panel,
	string $parentLayout,
	string $tabLabel,
	string $filter)
{
	//
	// Description:
	//	This procedure is called when the user creates a new scene tab, or when
	//	the default tabs are being created (ie the first time the user uses the
	//	visor panel or as a result of a revert to default tabs). 
	//	This procedure creates a scene tab.
	//
	// Returns: 
	//	The name of the newly created tab.
	//

	setParent $panel;
	setParent $parentLayout;
		string $tab = `formLayout`;
			// Create the collection UI. The second parameter is blank
			// because we want to have a new hypershade created,
			// rather than specifying an existing one to be used.
			//
			string $collectionUI = 
				collectionUI(
					$tab, 
					""); // hypershadeName
		setParent ..; // from $tab
	setParent ..; // from $parentLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$parentLayout;
	
	// Configure the collectionUI
	//
	collectionUISetFilter($collectionUI, $filter);
	collectionUISetPopupMenuScript(
		$collectionUI, 
		("visorPanelSceneTabPopupMenu " + $panel));

	string $optionVar = generateUniqueTabOptionVarName();
	registerTab($tab, "scene", $collectionUI, $optionVar);
	updateTabOptionVar($optionVar, $tab);

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $parentLayout);

	// Return the name of the tab which was created.
	//
	return $tab;
}

proc string recreateSceneTab(
	string $panel,
	string $parentLayout,
	string $optionVar,
	int $reuseEditors)
{
	//
	// Description:
	//	This procedure is called when a scene tab is being recreated from an
	//	optionVar.
	//	This procedure creates a scene tab using the information stored in the
	//	specified optionVar.
	//
	// Returns: 
	//	The name of the newly created tab.
	//

	string $tabLabel 
		= `optionVar -query ($optionVar + "Label")`;
	string $hypershadeName;

	if ($reuseEditors)
	{
		$hypershadeName = `optionVar -query ($optionVar + "HypershadeName")`;
	}


	setParent $panel;
	setParent $parentLayout;
		string $tab = `formLayout`;
			// Create the graph UI specifying that an existing hypershade
			// should be used.
			//
			string $collectionUI = 
				collectionUI(
					$tab, 
					$hypershadeName);

		setParent ..; // from $tab
	setParent ..; // from $parentLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$parentLayout;

	// Configure the collectionUI according to saved state
	//
	collectionUISetFilter(
		$collectionUI,
		`optionVar -query ($optionVar + "Filter")`);
	collectionUISetPopupMenuScript(
		$collectionUI, 
		("visorPanelSceneTabPopupMenu " + $panel));


	registerTab($tab, "scene", $collectionUI, $optionVar);

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $parentLayout);

	// Return the name of the tab which was created.
	//
	return $tab;
}

proc recreateTab(
	string $panel,
	string $parentLayout,
	string $optionVar,
	int $reuseEditors)
{
	//
	// Description:
	//	This procedure is called by initTabs() when a tab is being recreated 
	//	from an optionVar.
	//	This procedure determines what kind of tab is represented by the
	//	optionVar, then calls one of recreateGraphTab(), recreateDiskTab() or
	//	recreateSceneTab() to create the tab.
	//

	string $type = `optionVar -query ($optionVar + "Type")`;

	if ($type == "disk")
	{
		recreateDiskTab($panel, $parentLayout, $optionVar, $reuseEditors);
	}
	else if ($type == "paint effects")
	{
		recreatePaintEffectsTab(
			$panel, 
			$parentLayout, 
			$optionVar, 
			$reuseEditors);
	}
	else if ($type == "sculpting stamps")
	{
		recreateSculptStampsTab(
			$panel, 
			$parentLayout, 
			$optionVar, 
			$reuseEditors);
	}
	else if ($type == "scene")
	{
		recreateSceneTab($panel, $parentLayout, $optionVar, $reuseEditors);
	}
	else
	{
		string $tabError = (uiRes("m_visorPanel.kUnexpectedTab"));
		string $tabDisplay = `format -s $type $tabError`;
		error
			-showLineNumber true
			$tabDisplay;
	}
}

proc moveTab(
	string $panel,
	string $direction)
{
	//
	// Description:
	//	This procedure moves a tab up, down, left or right within the
	//	visor panel. 
	//	This procedure acts on the currently active tab when the $direction is
	//	"left" or "right". When the $direction is "up" or "down", this
	//	procedure acts on the frontmost tab in the bottom or top tab layout
	//	respectively.
	//	Once the move has been completed, the tab is made the active tab so
	//	that it can easily be immediately moved again.
	//

	setParent $panel;

	string 	$activeTabLayout = "firstPaneTabs";
	int 	$activeTabIndex = activeTabIndex($panel);

	int $numTabs = `tabLayout -query -numberOfChildren $activeTabLayout`;
	int $targetTabIndex;

	if (($direction == "left") && ($activeTabIndex > 1))
	{
		$targetTabIndex = $activeTabIndex - 1;
		tabLayout
			-edit
			-moveTab $activeTabIndex $targetTabIndex
			$activeTabLayout;

		// Bring the target tab to the front
		//
		tabLayout
			-edit
			-selectTabIndex $targetTabIndex
			$activeTabLayout;

		// Update the tab layout option vars now that a tab has been moved
		//
		updateTabLayoutOptionVar($panel, $activeTabLayout);
	}
	else if (($direction == "right") && ($activeTabIndex < $numTabs))
	{
		$targetTabIndex = $activeTabIndex + 1;
		tabLayout
			-edit
			-moveTab $activeTabIndex $targetTabIndex
			$activeTabLayout;

		// Bring the target tab to the front
		//
		tabLayout
			-edit
			-selectTabIndex $targetTabIndex
			$activeTabLayout;

		// Update the tab layout option vars now that a tab has been moved
		//
		updateTabLayoutOptionVar($panel, $activeTabLayout);
	}
}

proc removeTab(
	string $tab)
{
	//
	// Description:
	//	This procedure removes the specified tab from the visor panel.
	//

	// Delete the option var which describes this tab, so that it won't come
	// back the next time the user runs Maya
	//
	deleteTabOptionVar($tab);

	// Determine what kind of tab the current tab is (disk/graph/scene)
	//
	if (isDiskTab($tab) || isPaintEffectsTab($tab) || isSculptStampsTab($tab))
	{
		string $libraryUI;
		$libraryUI = lookupComponentName($tab);

		// Delete the libraryUI and the active tab.
		//
		unregisterTab($tab);
		libraryUIDelete(
			$libraryUI, 
			true); // delete the visors
		deleteUI $tab;
	}
	else if (isSceneTab($tab))
	{
		string $collectionUI;
		$collectionUI = lookupComponentName($tab);

		// Delete the collectionUI and the active tab.
		//
		unregisterTab($tab);
		collectionUIDelete(
			$collectionUI, 
			true); // delete the hypershade
		deleteUI $tab;
	}
}

global proc removeActiveTab(
	string $panel)
{
	//
	// Description:
	//	This procedure removes the active tab from the visor panel.
	//

	setParent $panel;

	string $tabLayout = "firstPaneTabs";
	string $activeTab = activeTab($panel);

	if (`lookupTabType($activeTab)` == "protected graph")
	{
		// The active tab is marked as a protected graph, which means we don't
		// want to allow it to be deleted or moved between tab layouts.
		//
		return;
	}

	removeTab($activeTab);

	// Delete the option var which describes this tab, so that it won't come
	// back the next time the user runs Maya
	//
	deleteTabOptionVar($activeTab);

	// Determine what kind of tab the current tab is (disk/graph/scene)
	//
	if (isDiskTab($activeTab) || isPaintEffectsTab($activeTab) || isSculptStampsTab($activeTab))
	{
		string $libraryUI;
		$libraryUI = lookupComponentName($activeTab);

		// Delete the libraryUI and the active tab.
		//
		unregisterTab($activeTab);
		libraryUIDelete(
			$libraryUI, 
			true); // delete the visors
		deleteUI $activeTab;
	}
	else if (isSceneTab($activeTab))
	{
		string $collectionUI;
		$collectionUI = lookupComponentName($activeTab);

		// Delete the collectionUI and the active tab.
		//
		unregisterTab($activeTab);
		collectionUIDelete(
			$collectionUI, 
			true); // delete the hypershade
		deleteUI $activeTab;
	}

	// Update the tab layout option var now that the tab has been deleted
	//
	updateTabLayoutOptionVar($panel, $tabLayout);
}

proc selectTab(
	string $panel,
	string $tab)
{
	//
	// Description:
	//	This procedure selects the specified tab, bringing it to the front of
	//	its tab layout.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	string $tabLayout = "firstPaneTabs";
	string $tabPathTokens[];

	tokenize($tab, "|", $tabPathTokens);
	string $tabShortName = $tabPathTokens[size($tabPathTokens) - 1];

	// Select the tab
	//
	tabLayout
		-edit
		-selectTab $tabShortName
		$tabLayout;

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;
}

proc int findTabByLabel( string $panel, string $tabLabel ) {
	//
	// Description:
	//  Returns the index of the panel with the matching label
	//  Returns zero if the tab was not found.
	int $tabIndex = 0;

	// Get a list of all tabs' labels
	setParent $panel;
	string $activeTabLay = activeTabLayout( $panel );
	string $allLabels[] = `tabLayout -query -tabLabel $activeTabLay`;

	// Find the index of the tab with the given label
	int $numLabels = size($allLabels);
	if( $numLabels > 0 ) {
		int $i;
		for( $i = 0; $i < $numLabels; $i ++ ) {
			if( $allLabels[$i] == $tabLabel ) {
				$tabIndex = $i + 1;
				break;
			}
		}
	}

	return $tabIndex;
}

proc selectTabByLabel( string $panel, string $tabLabel )
//	
//	 Description:
//		This procedure selects the specified tab with the given label, 
//	  bringing it to the front of its tab layout.
//	  The main thing here is to get the correct tab that has
//	  the label.  
//	
{
	// If the first fails, try localizing the tab label and searching with that
	//
	int $tabIndex = findTabByLabel( $panel, $tabLabel );
	if( $tabIndex == 0 ) {
		$tabIndex = findTabByLabel( $panel, visorPanelTabs_melToUI( $tabLabel ) );
	}

	string $activeTabLay = activeTabLayout( $panel );
	if( $tabIndex > 0 ) {
		// bring that tab to the front
		tabLayout
			-edit
			-selectTabIndex $tabIndex
			$activeTabLay;
	}
}

global proc string visorPanelTabs_melToUI( string $orig ) {
	string $result = $orig;

	string $paintEffects = (uiRes("m_visorPanel.kPaintEffectsMenu"));
	string $toonExamples = (uiRes("m_visorPanel.kToonExamples"));
	string $oceanExamples = (uiRes("m_visorPanel.kOceanExamples"));
	string $fluidExamples = (uiRes("m_visorPanel.kFluidExamples"));
	string $fluidInitialStates  = (uiRes("m_visorPanel.kFluidStates"));
	string $hairExamples = (uiRes("m_visorPanel.kHairExamples"));	
	string $nClothExamples = (uiRes("m_visorPanel.kNClothExamples"));
	string $EffectsAssets = (uiRes("m_visorPanel.kEffectsAssets"));
	string $nParticleExamples = (uiRes("m_visorPanel.kNParticleExamples"));
	string $BifrostPresets = (uiRes("m_visorPanel.kBifrostExamples"));
	string $sculptMeshes = (uiRes("m_visorPanel.kSculptMeshes"));
	string $sculptStamps = (uiRes("m_visorPanel.kSculptStamps"));
	string $humanikExamples = (uiRes("m_visorPanel.kHumanIKExamples"));
	string $mocapExamples = (uiRes("m_visorPanel.kMocapExamples"));
	string $characterClips = (uiRes("m_visorPanel.kCharacterClips"));
	string $characterPoses = (uiRes("m_visorPanel.kCharacterPoses"));
	string $unusedClips = (uiRes("m_visorPanel.kUnusedClips"));
	string $unusedPoses = (uiRes("m_visorPanel.kUnusedPoses"));
	string $projects = (uiRes("m_visorPanel.kProject"));

	if( $orig == "Projects" ) {
		$result = $projects;
	} else if( $orig == "Ocean Examples" ) {
		$result = $oceanExamples;
	} else if( $orig == "Fluid Examples" ) {
		$result = $fluidExamples;
	} else if( $orig == "Fluid Initial States" ) {
		$result = $fluidInitialStates;
	} else if( $orig == "Hair Examples" ) {
		$result = $hairExamples;
	} else if( $orig == "nCloth Examples" ) {
		$result = $nClothExamples;
	} else if( $orig == "Effects Assets" ) {
		$result = $EffectsAssets;
	} else if( $orig == "nParticle Examples" ) {
		$result = $nParticleExamples;
	} else if( $orig == "Bifrost Examples" ) {
		$result = $BifrostPresets;
	} else if( $orig == "Sculpting Base Meshes" ) {
		$result = $sculptMeshes;
	} else if( $orig == "Sculpting Stamps" ) {
		$result = $sculptStamps;
	} else if( $orig == "Paint Effects" ) {
		$result = $paintEffects;
	} else if( $orig == "Toon Examples" ) {
		$result = $toonExamples;
	} else if( $orig == "HumanIK Examples" ) {
		$result = $humanikExamples;
	} else if( $orig == "Mocap Examples" ) {
		$result = $mocapExamples;
	}  else if( $orig == "Character Clips" ) {
		$result = $characterClips;
	} else if( $orig == "Character Poses" ) {
		$result = $characterPoses;
	} else if( $orig == "Unused Clips" ) {
		$result = $unusedClips;
	} else if( $orig == "Unused Poses" ) {
		$result = $unusedPoses;
	} else {
		uiToMelMsg( "visorPanelTabs_melToUI", $orig, 0 );
	}

	return $result;
}


global proc revertToDefaultTabs(
	string $panel)
{
	//
	// Description:
	//	This procedure removes all tabs from the visor panel and creates
	//	the default set of tabs. 
	//

	// Show the wait cursor
	//
	waitCursor -state on;

	// Unmanage the tab layout because what we are about to do will cause some
	// flicker.
	//
	setParent $panel;
	tabLayout -edit -manage false firstPaneTabs;

	// Delete all tabs
	//
	int $i;
	string $tabArray[];
	string $tab;

	$tabArray = `tabLayout -query -childArray firstPaneTabs`;

	for ($i = 0; $i < size($tabArray); $i++)
	{
		setParent $panel;
		$tab = `setParent $tabArray[$i]`;
		removeTab($tab);
	}


 
	// Create the Domemaster3D tab
	//
  string $domeNewTabLabel = "Domemaster3D Examples";
  string $domeRunTimeDir = `getenv "DOMEMASTER3D_MAYA_DIR"` + "/common";
  string $domeRelDir = "/presets/Domemaster3D/examples";
	createVisorDefaultTab( $domeRunTimeDir, $panel, "firstPaneTabs", $domeRelDir, $domeNewTabLabel );
   
    
  // Create the default tabs
	//
	string $runTimeDir = `getenv "MAYA_LOCATION"`;


	string $paintEffects = visorPanelTabs_melToUI( "Paint Effects" );
	if ($runTimeDir != "")
	{
		string $brushDir = ($runTimeDir + "/brushes");
		createPaintEffectsTab(
			$panel,
			"firstPaneTabs",
			$paintEffects,
			$brushDir);
	}

	// Create tabs for Oceans, clouds samples, and cloud data
	//
	int $fluidsIsLicensed = fluidEditLicenseFound(); 
	string $oceanExamples = visorPanelTabs_melToUI( "Ocean Examples" );
	string $fluidExamples = visorPanelTabs_melToUI( "Fluid Examples" );
	string $fluidInitialStates = visorPanelTabs_melToUI( "Fluid Initial States" );
	if( $fluidsIsLicensed ) {
		createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
							   "/presets/fluids/ocean", 
							   $oceanExamples);

		createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
							   "/presets/fluids/examples", 
							   $fluidExamples);

		createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
							   "/presets/fluids/initialStates", 
							   $fluidInitialStates);
	}

	// Create the tabs for hair examples
	//
	string $hairExamples = visorPanelTabs_melToUI( "Hair Examples" );
	if( $fluidsIsLicensed ) {
		createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
							   "/presets/hair/examples", 
							   $hairExamples);
	}

	// Create the tabs for toon examples
	//
	string $toonExamples = visorPanelTabs_melToUI( "Toon Examples" );
	createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						   "/presets/toon/examples", 
						   $toonExamples);

	// Create the tabs for bifrost examples
	//
	string $bifrostPresets = visorPanelTabs_melToUI( "Bifrost Examples" );
	createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						   "/presets/bifrost/examples", 
						   $bifrostPresets);

	// Create the tab for Sculpting Base Meshes
	//
	string $sculptMeshes = visorPanelTabs_melToUI( "Sculpting Base Meshes" );
	string $tab = createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						   "/presets/Sculpt", 
						   $sculptMeshes);
	string $libraryUI = lookupComponentName($tab);
	libraryUISetCurrentDirectory(
		$libraryUI,
		$runTimeDir + "/presets/Sculpt/Animals");

	// Create the tab for stamps
	//
	string $newName = visorPanelTabs_melToUI( "Sculpting Stamps" );
	if ($runTimeDir != "")
	{
		string $fullDir = ($runTimeDir + "/presets/Stamp");
		createSculptStampsTab($panel, "firstPaneTabs", $newName, $fullDir);
	}

	// Create the tabs for nCloth examples
	//
	string $nClothExamples = visorPanelTabs_melToUI( "nCloth Examples" );
	if( $fluidsIsLicensed ) {
		createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						   "/presets/nCloth/examples", 
						   $nClothExamples);
	}

	// Create the tabs for Effects Assets
	//
	string $effectsAssets = visorPanelTabs_melToUI( "Effects Assets" );
	if( $fluidsIsLicensed ) {
		createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						   "/presets/EffectsAssets/examples", 
						   $effectsAssets);
	}

	// Create the tabs for nParticle examples
	//
	string $nParticleExamples = visorPanelTabs_melToUI( "nParticle Examples" );
	if( $fluidsIsLicensed ) {
		createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						   "/presets/nParticles/examples", 
						   $nParticleExamples);
	}

	// Create the tabs for fbik examples
	//
	string $fbikExamples = visorPanelTabs_melToUI( "HumanIK Examples" );
	createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						   "/presets/hik/examples", 
						   $fbikExamples);
						   
    
    // Create the tabs for mocap examples
	//
	string $mocapExamples = visorPanelTabs_melToUI( "Mocap Examples" );
	createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						   "/presets/mocap/examples", 
						   $mocapExamples);

	string $characterClips = visorPanelTabs_melToUI( "Character Clips" );
	createSceneTab(
		$panel,
		"firstPaneTabs",
		$characterClips,
		"CharacterClips");

	string $characterPoses = visorPanelTabs_melToUI( "Character Poses" );
	createSceneTab(
		$panel,
		"firstPaneTabs",
		$characterPoses,
		"CharacterPoses");

	string $unusedClips = visorPanelTabs_melToUI( "Unused Clips" );
	createSceneTab(
		$panel,
		"firstPaneTabs",
		$unusedClips,
		"UnusedClips");

	string $unusedPoses = visorPanelTabs_melToUI( "Unused Poses" );
	createSceneTab(
		$panel,
		"firstPaneTabs",
		$unusedPoses,
		"UnusedPoses");

	string $projectsDir = `internalVar -userWorkspaceDir`;

	string $projects = visorPanelTabs_melToUI( "Projects" );
	$tab = createDiskTab(
		$panel,
		"firstPaneTabs",
		$projects,
		$projectsDir);

	// If this is the first time the user has opened visor since 3.0, and
	// they have custom disk folders defined in their userPrefs, we will create
	// a tab for each of those custom disk folders.
	//
	if (	(!`optionVar -exists customFoldersConvertedForVisor`)
		&&	(`optionVar -exists visorCustomDiskFolders`))
	{
		// Get from an optionVar the list of directories for which custom disk 
		// folders were created. Create a disk tab for each.
		//
		int 	$i;
		string 	$customFolderNameArray[];

		$customFolderNameArray = `optionVar -query visorCustomDiskFolders`;

		for ($i = 0; $i < size($customFolderNameArray); $i++)
		{
			// Tokenize the path stored in $customFolderNameArray[$i] so that
			// we can have a shorter name for the tab.
			//
			string $pathTokens[];
			tokenize $customFolderNameArray[$i] "/" $pathTokens;

			createDiskTab(
				$panel,
				"firstPaneTabs",
				$pathTokens[size($pathTokens) - 1],
				$customFolderNameArray[$i]);
		}

		if (`optionVar -exists customFoldersConvertedForHypershade`)
		{
			// These custom disk folders have also already been added to Visor.
			// This means that we no longer need to keep the
			// visorCustomDiskFolders optionVar around.
			// We also don't need the customFoldersConvertedForHypershade 
			// optionVar anymore because it has served its purpose.
			//
			optionVar -remove visorCustomDiskFolders;
			optionVar -remove customFoldersConvertedForHypershade;
		}
		else
		{
			// Set an optionVar to indicate that these custom disk folders have
			// already been added to Visor
			//
			optionVar -intValue customFoldersConvertedForVisor true;
		}
	}

	// Update the tab layout option vars now that the tabs have been reverted
	//
	updateTabLayoutOptionVar($panel, "firstPaneTabs");

	// Now that we have created all the tabs we need, we delete any option vars
	// which describe tabs that did not get used.
	//
	deleteUnusedTabOptionVars($panel);

	// Remanage the tab layout
	//
	setParent $panel;
	tabLayout -edit -manage true firstPaneTabs;

	// Hide the wait cursor
	//
	waitCursor -state off;
}

global int $gVisorPanelCreatedThisSession = false;

proc initTabs(string $panel)
{
	//
	// Description:
	//	This procedure is called the first time the visor panel is opened
	//	during a Maya session.
	//	This procedure uses the optionVars which describe the contents of the
	//	visor panel tab layouts and tabs in order to recreate the
	//	visor panel as it appeared when it was last open.
	//	If no such optionVars exist, this procedure causes the default tabs to
	//	be created.
	//

	// Clear the lookup table because we are creating a fresh visor panel
	//
	global string $gVisorPanelLookupTable[];
	lookupTableReset($gVisorPanelLookupTable);

	// In Maya 4.0, trying to reuse editors was problematic because the
	// contents of the editor would be badly positioned when visor was
	// reopened with a reused editor. So we will not reuse editors for 4.0, but
	// may do so in the future.
	//
	int $reuseEditors = false;

	if (!`optionVar -exists visorFirstPaneTabs`)
	{
		// The option vars which should contain the names of the option vars
		// describing the tabs in the tab layouts do not exist.
		// This indicates that this is the first time the user is using
		// this version of Maya, or that their prefs have been deleted.
		// In this situation we want to fill the shader editor with what we
		// consider to be useful and appropriate default tabs.
		//
		revertToDefaultTabs($panel);

		//	Save the current Maya version.
		//
		float $version = getApplicationVersionAsFloat();
		optionVar -floatValue VisorPreferenceVersion $version;

		return;
	}

	// If we get to here, it means the user already has option vars in their
	// prefs to describe the tabs they expect to see in their shader editor.
	// 
	// We will read ther user's preferred set of tabs from optionVars and 
	// create them.
	//
	int $i;

	string $firstPaneTabVars[];
	$firstPaneTabVars = `optionVar -query visorFirstPaneTabs`;

	setParent $panel;

	//	A flag to let us know later if the new Fluids Visor tabs need
	//	to be created.
	//
	
  int $createDomemaster3DTabs = false;
	int $createFluidExamplesTabs = false;
	int $createnClothExamplesTabs = false;
	int $createEffectsAssetsTabs = false;
	int $createnParticleExamplesTabs = false;
	int $createHairExamplesTabs = false;
	int $createToonExamplesTabs = false;
	int $createBifrostPresetsTabs = false;
	int $createSculptMeshTabs = false;
	int $createSculptStampTabs = false;
	int $createHumanIKExamplesTabs = false;
	int $createMocapExamplesTabs = false;

	//	The VisorPreferenceVersion option var is new for 4.5. With this
	//	option var we will know which version of Maya we are running
	//	and may determine if any new default Visor tabs need to be created.
	//	For example, the Fluids tabs are new to version 4.5.
	//
	if (`optionVar -exists VisorPreferenceVersion`) {
		//
		//	The Visor preference version option var exists. This means
		//	Maya version 4.5 has been run at least once already.
		//
		//	At this point we know that Maya is running from existing
		//	4.5 (or higher) preferences. This means if there are no 
		//	option vars for the Fluids tabs then it is because the user 
		//	has explicitly removed them from the Visor. In this
		//	case we do not want to re-create them.
		//

		float $version = `optionVar -query VisorPreferenceVersion`;

		if ( $version <= 6.5) {
			//
			//	Running Maya 6.5 or lower
			//  There's still the Hair and Toon preset tabs to add
			$createHairExamplesTabs = true;
			$createToonExamplesTabs = true;
			$createHumanIKExamplesTabs = true;
			$createMocapExamplesTabs = false;

		}

		if ( $version <= 8.0) {
			//
			//	Running Maya 8.0 or lower
			//  There's still the nCloth preset tabs to add
			$createnClothExamplesTabs = true;
		}

		if ( $version <= 9.0) {
			//
			//	Running Maya 9.0 (2008) or lower
			//  There's still the nParticle preset tabs to add
			$createnParticleExamplesTabs = true;
		}

		if ( $version <= 11.0) {
			//
			//	Running Maya 11.0 (2011) or lower
			//  There's still the Effects Assets preset tabs to add
			$createEffectsAssetsTabs = true;
		}
		if ( $version <= 2015) {
			//
			//	Running Maya 2015 or lower
			//  There's still the bifrost examples tabs to add
			$createBifrostPresetsTabs = true;
		}

		if ( $version <= 2015) {
			$createSculptMeshTabs = true;
			$createSculptStampTabs = true;
		}

	} else {
		//
		//	The Visor preference version option var does not exist. 
		//	This means we are running Maya 4.5 (or greater) for the first 
		//	time and reading preferences from an earlier version of Maya.
		//
		//	We need to detect this so the new default Fluid Example Visor tabs 
		//	can be created for Maya 4.5. In this situation there are
		//	no option vars for the Fluids tabs, this is as expected
		//	because Fluids is new to 4.5. Knowing this, we can create
		//	the Fluids visor tabs.
		//
		
    $createDomemaster3DTabs = true;
		$createFluidExamplesTabs = true;
		$createHairExamplesTabs = true;
		$createnClothExamplesTabs = true;
		$createEffectsAssetsTabs = true;
		$createnParticleExamplesTabs = true;
		$createToonExamplesTabs = true;
		$createBifrostPresetsTabs = true;
		$createSculptMeshTabs = true;
		$createSculptStampTabs = true;
		$createHumanIKExamplesTabs = true;
		$createMocapExamplesTabs = false;
	}

	//	Create/Update the Visor pref version option var.
	//
	float $version = getApplicationVersionAsFloat();
	optionVar -floatValue VisorPreferenceVersion $version;

	for ($i = 0; $i < size($firstPaneTabVars); $i++)
	{
		recreateTab(
			$panel,
			"firstPaneTabs",
			$firstPaneTabVars[$i],
			$reuseEditors);
	}

	string $runTimeDir = `getenv "MAYA_LOCATION"`;

  // Create the Domemaster3D tab
  if($createDomemaster3DTabs){
    string $domeNewTabLabel = "Domemaster3D Examples";
    string $domeRunTimeDir = `getenv "DOMEMASTER3D_MAYA_DIR"` + "/common";
    string $domeRelDir = "/presets/Domemaster3D/examples";
    createVisorDefaultTab( $domeRunTimeDir, $panel, "firstPaneTabs", $domeRelDir, $domeNewTabLabel );
  }

	
	//	Create the default Fluid Visor tabs.
	//
	if( fluidEditLicenseFound() ) {
		if ($createFluidExamplesTabs) {
			//
			//	Create tabs for Ocean Examples, Fluid Examples and Fluid 
			//	Initial States.
			//
			createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
								   "/presets/fluids/ocean", 
								   visorPanelTabs_melToUI( "Ocean Examples" ) );

			createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
								   "/presets/fluids/examples", 
								   visorPanelTabs_melToUI( "Fluid Examples" ) );

			createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
								   "/presets/fluids/initialStates", 
								   visorPanelTabs_melToUI( "Fluid Initial States" ) );
		}
	}

	// Create the default Hair Visor tabs.
	//
	if( fluidEditLicenseFound() ) {
		if ($createHairExamplesTabs) {
			//
			//	Create tabs for Hair Examples
			//
			createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
								   "/presets/hair/examples", 
								   visorPanelTabs_melToUI( "Hair Examples" ) );

		}
	}

	// create Toon example tab
	if ($createToonExamplesTabs) {
		//
		//	Create tabs for Toon Examples
		//
		createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
							   "/presets/toon/examples", 
							   visorPanelTabs_melToUI( "Toon Examples" ) );
	}

	// Create the default nCloth Visor tabs.
	//
	if( fluidEditLicenseFound() ) {
		if ($createnClothExamplesTabs) {
			//
			//	Create tabs for nCloth Examples
			//
			createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
								   "/presets/nCloth/examples", 
								   visorPanelTabs_melToUI( "nCloth Examples" ) );

		}
	}
	// Create the default Effects Assets Visor tabs.
	//
	if( fluidEditLicenseFound() ) {
		if ($createEffectsAssetsTabs) {
			//
			//	Create tabs for FX Assets Examples
			//
			createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
								   "/presets/EffectsAssets/examples", 
								   visorPanelTabs_melToUI( "Effects Assets" ) );

		}
	}

	// Create the default nParticle Visor tabs.
	//
	if( fluidEditLicenseFound() ) {
		if ($createnParticleExamplesTabs) {
			//
			//	Create tabs for nParticle Examples
			//
			createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
								   "/presets/nParticles/examples", 
								   visorPanelTabs_melToUI( "nParticle Examples" ) );

		}
	}
	// create Bifrost Examples tab
	if ($createBifrostPresetsTabs) {
		//
		//	Create tabs for Bifrost examples
		//
		createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
							   "/presets/bifrost/examples", 
							   visorPanelTabs_melToUI( "Bifrost Examples" ) );
	}
	

	if ($createSculptMeshTabs) {
		string $tab = createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
							   "/presets/Sculpt", 
							   visorPanelTabs_melToUI( "Sculpting Base Meshes" ) );
		string $libraryUI = lookupComponentName($tab);
		libraryUISetCurrentDirectory(
			$libraryUI,
			$runTimeDir + "/presets/Sculpt/Animals");
	}

	// create HumanIK example tab
	if ($createHumanIKExamplesTabs) {
		//
		//	Create tabs for HumanIK Examples
		//
		createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
							   "/presets/hik/examples", 
							   visorPanelTabs_melToUI( "HumanIK Examples" ) );
	}
	
	// create Mocap example tab
	if ($createMocapExamplesTabs) {
		//
		//	Create tabs for Mocap Examples
		//
		createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
							   "/presets/mocap/examples", 
							   visorPanelTabs_melToUI( "Mocap Examples" ) );
	}

	// Update the tab layout option vars now that the tabs have been
	// initialized
	//
	updateTabLayoutOptionVar($panel, "firstPaneTabs");

	// Now that we have created all the tabs we need, we delete any option vars
	// which describe tabs that did not get used.
	//
	deleteUnusedTabOptionVars($panel);
}

global proc visorPanelRootDirectoryBrowse()
{
	//
	// Description:
	//	This procedure is called when the user clicks on the browse button
	//	beside the root directory text field in the create new tab dialog for
	//	disk tabs.
	//	This procedure opens a file browser so the user can browse for the
	//	directory they want the tab to point at.
	//

	setParent visorPanelCreateNewTabWindow;

	string $initialDirectory = `textField -query -fileName rootDirectoryField`;

	if (`filetest -d $initialDirectory`)
	{
		workspace -dir $initialDirectory;
	}
	else
	{
		string  $workspace = `workspace -query -fullName`;
		setWorkingDirectory($workspace, "", "");
	}

	fileBrowser("visorPanelRefreshRootDirectoryBrowseField", (uiRes("m_visorPanel.kOpen")), "", 4);
}

global proc int visorPanelRefreshRootDirectoryBrowseField(
	string $directory, 
	string $type)
{
	//
	// Description:
	//	This procedure is called by the file browser the user uses to choose a
	//	directory to which a new disk tab will point. 
	//	This procedure confirms that the user's selection is indeed a
	//	directory. If so, this procedure updates the root directory text field
	//	of the create new tab window.
	//
	// Returns: 
	//	1 if the $directory was a valid directory name, thereby causing the
	//	file browser to close.
	//	0 if the $directory was not a directory name, thereby causing the file
	//	browser to remain open.
	//

	if (`window -exists visorPanelCreateNewTabWindow`)
	{
		if (`filetest -d $directory`)
		{
			setParent visorPanelCreateNewTabWindow;
			textField
				-edit
				-fileName $directory
				rootDirectoryField;
			return 1;
		}
		else
		{
			confirmDialog
				-title (uiRes("m_visorPanel.kInvalidDirectory"))
				-message 
					(uiRes("m_visorPanel.kRootDirectoryInvalid"))
				-messageAlign center
				-button (uiRes("m_visorPanel.kCloseButton")) ;
			return 0;
		}
	}
	else
	{
		return 1;
	}
}

global proc visorPanelCreateNewTabFinish(
	string $panel,
	int $dismiss)
{
	//
	// Description:
	//	This procedure is called when the user clicks on the Create button in
	//	the create new tab dialog. 
	//	This procedure examines the settings of the controls in the create new
	//	tab dialog to determine the details of the tab the user wants to
	//	create, and then creates the tab.
	//

	setParent visorPanelCreateNewTabWindow;
	string 	$tabLabel;
	int 	$tabTypeIndex;
	string 	$tabLayout;

	$tabLabel = `textFieldGrp -query -text newTabNameGrp`;

	$tabLayout = "firstPaneTabs";

	string $tabType = `optionMenuGrp -query -value tabTypeGrp`;

	string $newTab = "";

	if ($tabType == (uiRes("m_visorPanel.kScene")) )
	{
		string $filter;
		string $interfaceTabLabel;
		$interfaceTabLabel = `optionMenuGrp -query -value sceneTabFilterGrp`;

		if ($interfaceTabLabel == (uiRes("m_visorPanel.kShadingGroups")) )
		{
			$filter = "ShadingGroups";
		}
		else if ($interfaceTabLabel == (uiRes("m_visorPanel.kPostProcess")) )
		{
			$filter = "PostProcess";
		}
		else if ($interfaceTabLabel == (uiRes("m_visorPanel.kMaterialsShaderGlow")) )
		{
			$filter = "MaterialsAndShaderGlow";
		}
		else if ($interfaceTabLabel == (uiRes("m_visorPanel.kLightsOpticalFX")) )
		{
			$filter = "LightsAndOpticalFX";
		}
		else if ($interfaceTabLabel == (uiRes("m_visorPanel.kMaterials")) )
		{
			$filter = "Materials";
		}
		else if ($interfaceTabLabel == (uiRes("m_visorPanel.kTextures")) )
		{
			$filter = "Textures";
		}
		else if ($interfaceTabLabel == (uiRes("m_visorPanel.kLights")) )
		{
			$filter = "Lights";
		}
		else if ($interfaceTabLabel == (uiRes("m_visorPanel.kCameras")) )
		{
			$filter = "Cameras";
		}
		else if ($interfaceTabLabel == (uiRes("m_visorPanel.kUtilities")) )
		{
			$filter = "Utilities";
		}
		
		$newTab = createSceneTab(
			$panel,
			$tabLayout,
			$tabLabel,
			$filter);
	}
	else if (($tabType == (uiRes("m_visorPanel.kDisk")) ) || ($tabType == (uiRes("m_visorPanel.kPaintEffects")) ))
	{
		string $rootDirectory = 
			`textField -query -text rootDirectoryField`;
		if (!`filetest -d $rootDirectory`)
		{
			confirmDialog
				-title (uiRes("m_visorPanel.kInvalidDdirectory"))
				-message 
					(uiRes("m_visorPanel.kDirectoryInvalidMsg"))
				-messageAlign center
				-parent visorPanelCreateNewTabWindow
				-button (uiRes("m_visorPanel.kButtonClose"));
			return;
		}
		int $showFilesOnly = 
			`checkBoxGrp -query -value1 onlyShowFilesCheckBox`;
		
		if (`about -nt`)
		{
			// The root directory must end in a "\" on NT otherwise weird 
			// things happen.
			//
			$rootDirectory = ($rootDirectory + "\\");
		}

		if ($tabType == (uiRes("m_visorPanel.kDisk")) )
		{
			$newTab = createDiskTab(
				$panel,
				$tabLayout,
				$tabLabel,
				$rootDirectory);
		}
		else if($tabType == "Sculpting Stamps")
		{
			$newTab = createSculptStampsTab(
				$panel,
				$tabLayout,
				$tabLabel,
				$rootDirectory);
		}
		else // ($tabType == "Paint Effects")
		{
			$newTab = createPaintEffectsTab(
				$panel,
				$tabLayout,
				$tabLabel,
				$rootDirectory);
		}

		string $libraryUI = lookupComponentName($newTab);

		// Specify whether the new tab should show directories
		//
		if ($showFilesOnly)
		{
			libraryUIShowFilesOnly($libraryUI);
		}
	}

	// Update the tab layout option vars now that a tab has been added
	//
	updateTabLayoutOptionVar($panel, $tabLayout);

	if ($newTab != "")
	{
		// Bring the new tab to the front
		//
		selectTab($panel, $newTab);
	}

	if ($dismiss)
	{
		// Close the create new tab dialog
		//
		deleteUI visorPanelCreateNewTabWindow;
	}
}

global proc visorPanelRefreshCreateNewTabWindow()
{
	//
	// Description:
	//	This procedure is called when the user changes the type of tab to be
	//	created in the create new tab dialog. 
	//	This procedure updates the UI of the create new tab dialog to show only
	//	the options which are applicable to a tab of the user's chosen type.
	//

	setParent visorPanelCreateNewTabWindow;

	string $tabType = `optionMenuGrp -query -value tabTypeGrp`;

	if ($tabType == (uiRes("m_visorPanel.kScene")) )
	{
		optionMenuGrp
			-edit
			-manage true
			sceneTabFilterGrp;
		rowLayout
			-edit
			-manage false
			directoryNameLayout;
		checkBoxGrp
			-edit
			-manage false
			onlyShowFilesCheckBox;
	}
	else if ($tabType == (uiRes("m_visorPanel.kDisk")) )
	{
		optionMenuGrp
			-edit
			-manage false
			sceneTabFilterGrp;
		rowLayout
			-edit
			-manage true
			directoryNameLayout;
		checkBoxGrp
			-edit
			-manage true
			onlyShowFilesCheckBox;
	}
	else if ($tabType == (uiRes("m_visorPanel.kPaintEffects")) )
	{
		optionMenuGrp
			-edit
			-manage false
			sceneTabFilterGrp;
		rowLayout
			-edit
			-manage true
			directoryNameLayout;
		checkBoxGrp
			-edit
			-manage true
			onlyShowFilesCheckBox;
	}
}

proc createNewTab(
	string $panel)
{
	//	DefaultTemplate values in setDefaultTemplates.mel
	//
	global int $gDefaultTemplateLabelWidth;
	global int $gDefaultTemplateSingleWidgetWidth;
	global int $gDefaultTemplateExtraWidth;

	//
	// Description:
	//	This procedure is called when the user chooses Create New Tab... from
	//	the visor panel menu.
	//	This procedure builds and opens the create new tab dialog.
	//

	if (`window -exists visorPanelCreateNewTabWindow`)
	{
		showWindow visorPanelCreateNewTabWindow;
		return;
	}

	//
	// If we get to here, the create new tab window does not already exist, so 
	// we will create it.
	//
	int $windowWidth = 450;
	int $windowHeight = 200;

	window 
		-title (uiRes("m_visorPanel.kCreateNewTabTitle"))
		-iconName (uiRes("m_visorPanel.kCreateNewTabIconName"))
		-width $windowWidth
		-height $windowHeight
		visorPanelCreateNewTabWindow;

	setUITemplate -pushTemplate DefaultTemplate;
	
	formLayout mainForm;
		scrollLayout
			-horizontalScrollBarThickness 0
			mainScroll;

			columnLayout scrollColumn;
				textFieldGrp
					-label (uiRes("m_visorPanel.kNewTabName"))
					newTabNameGrp;
				optionMenuGrp
					-label (uiRes("m_visorPanel.kTabType"))
					-changeCommand "visorPanelRefreshCreateNewTabWindow"
					tabTypeGrp;

					menuItem -label (uiRes("m_visorPanel.kScene"));
					menuItem -label (uiRes("m_visorPanel.kDisk"));
					menuItem -label (uiRes("m_visorPanel.kPaintEffects"));
					menuItem -label (uiRes("m_visorPanel.kSculptingStamps"));

				setParent -menu ..; // from option menu
				separator;
				formLayout sceneTabOptionsWrap;
					optionMenuGrp
						-label (uiRes("m_visorPanel.kShowNodes"))
						sceneTabFilterGrp;

						menuItem
							-label (uiRes("m_visorPanel.kMaterials"))
							materialsFilterItem;
						menuItem
							-label (uiRes("m_visorPanel.kMaterialsShaderGlow"))
							materialsAndShaderGlowFilterItem;
						menuItem
							-label (uiRes("m_visorPanel.kTextures"))
							texturesFilterItem;
						menuItem
							-label (uiRes("m_visorPanel.kLights"))
							lightsFilterItem;
						menuItem
							-label (uiRes("m_visorPanel.kLightsOpticalFX"))
							lightsAndOpticalFXFilterItem;
						menuItem
							-label (uiRes("m_visorPanel.kCameras"))
							camerasFilterItem;
						menuItem
							-label (uiRes("m_visorPanel.kUtilities"))
							utilitiesFilterItem;
						menuItem
							-label (uiRes("m_visorPanel.kShadingGroups"))
							shadingGroupsFilterItem;
						menuItem
							-label (uiRes("m_visorPanel.kPostProcess"))
							postProcessFilterItem;
					setParent -menu ..; // from option menu
					formLayout
						-edit
						-af sceneTabFilterGrp left 0
						-af sceneTabFilterGrp right 0
						-af sceneTabFilterGrp top 0
						-af sceneTabFilterGrp bottom 0
						sceneTabOptionsWrap;
				setParent ..; // from sceneTabOptionsWrap
				formLayout diskTabOptionsWrap;
					rowLayout
						-numberOfColumns 3
						-columnWidth 2 225
						-columnWidth 3 25
						directoryNameLayout;
						text 
							-label (uiRes("m_visorPanel.kRootDirectory"));
						textField
							-width 150
							rootDirectoryField;
						symbolButton
							-width 10
							-image "navButtonBrowse.png" 
							-command "visorPanelRootDirectoryBrowse"
							browseButton;
					setParent ..; // from directoryNameLayout
					checkBoxGrp
						-numberOfCheckBoxes 1
						-label1 (uiRes("m_visorPanel.kOnlyShowFiles"))
						onlyShowFilesCheckBox;
					formLayout
						-edit
						-af directoryNameLayout left 0
						-af directoryNameLayout right 0
						-af directoryNameLayout top 0
						-an directoryNameLayout bottom
						-af onlyShowFilesCheckBox left 0
						-af onlyShowFilesCheckBox right 0
						-ac onlyShowFilesCheckBox top 0 directoryNameLayout
						-af onlyShowFilesCheckBox bottom 0
						diskTabOptionsWrap;
				setParent ..; // from diskTabOptionsWrap
			setParent ..; // from scrollColumn
		setParent ..; // from mainScroll

		formLayout 
			-numberOfDivisions 3
			buttonForm;

			button
				-label (uiRes("m_visorPanel.kCreate"))
				-command ("visorPanelCreateNewTabFinish " + $panel + " 1")
				createButton;
			button
				-label (uiRes("m_visorPanel.kApply"))
				-command ("visorPanelCreateNewTabFinish " + $panel + " 0")
				applyButton;
			button
				-label (uiRes("m_visorPanel.kClose"))
				-command "deleteUI visorPanelCreateNewTabWindow"
				closeButton;

			formLayout
				-edit
				-af createButton left 0
				-ap createButton right 2 1
				-af createButton top 0
				-af createButton bottom 0

				-ap applyButton left 3 1
				-ap applyButton right 2 2
				-af applyButton top 0
				-af applyButton bottom 0

				-ap closeButton left 3 2
				-af closeButton right 0
				-af closeButton top 0
				-af closeButton bottom 0
				buttonForm;
		setParent ..; // from buttonForm

		formLayout
			-edit

			-af mainScroll left 0
			-af mainScroll right 0
			-af mainScroll top 0
			-ac mainScroll bottom 5 buttonForm

			-af buttonForm left 5
			-af buttonForm right 5
			-an buttonForm top
			-af buttonForm bottom 5
			
			mainForm;
	setParent ..; // from mainForm

	setUITemplate -popTemplate;

	visorPanelRefreshCreateNewTabWindow;

	showWindow visorPanelCreateNewTabWindow;
}

global proc visorPanelRenameTabFinish(
	string $panel)
{
	//
	// Description:
	//	This procedure is called when the user clicks on the Rename button in
	//	the rename tab dialog. 
	//	This procedure examines the settings of the controls in the rename
	//	tab dialog to determine the new name for the tab, then renames the tab.
	//

	setParent visorPanelRenameTabWindow;
	string 	$tabLabel;

	$tabLabel = `textFieldGrp -query -text newTabNameGrp`;

	setTabLabel(activeTab($panel), $tabLabel);
	deleteUI visorPanelRenameTabWindow;
}

proc renameTab(
	string $panel)
{
	//
	// Description:
	//	This procedure is called when the user chooses Rename Tab... from
	//	the visor panel menu.
	//	This procedure builds and opens the rename tab dialog.
	//

	if (`window -exists visorPanelRenameTabWindow`)
	{
		showWindow visorPanelRenameTabWindow;
		return;
	}

	//
	// If we get to here, the rename tab window does not already exist, so 
	// we will create it.
	//

	int $windowWidth = 425;
	int $windowHeight = 110;
	
	string $rename = (uiRes("m_visorPanel.kRenameTabTitle"));
	window 
		-title $rename
		-width $windowWidth
		-height $windowHeight
		-iconName $rename
		visorPanelRenameTabWindow;
	
	setUITemplate -pushTemplate DefaultTemplate;
	
	formLayout mainForm;
		columnLayout mainColumn;
			textFieldGrp 
				-label (uiRes("m_visorPanel.kOldTabName"))
				-editable false
				-text `activeTabLabel($panel)`
				oldTabNameGrp;
			textFieldGrp 
				-label (uiRes("m_visorPanel.kNewTabNameRename"))
				newTabNameGrp;
		setParent ..; // from mainColumn

		formLayout 
			-numberOfDivisions 2
			buttonForm;

			button
				-label (uiRes("m_visorPanel.kRename"))
				-command ("visorPanelRenameTabFinish " + $panel)
				renameButton;
			button
				-label (uiRes("m_visorPanel.kCloseTab"))
				-command "deleteUI visorPanelRenameTabWindow"
				closeButton;

			formLayout
				-edit
				-af renameButton left 5
				-ap renameButton right 2 1
				-af renameButton top 5
				-af renameButton bottom 5

				-ap closeButton left 3 1
				-af closeButton right 5
				-af closeButton top 5
				-af closeButton bottom 5
				buttonForm;
		setParent ..; // from buttonForm

		formLayout
			-edit

			-af mainColumn left 0
			-af mainColumn right 0
			-af mainColumn top 0
			-af mainColumn bottom 35

			-af buttonForm left 0
			-af buttonForm right 0
			-ac buttonForm top 0 mainColumn
			-af buttonForm bottom 0
			
			mainForm;
	setParent ..; // from mainForm

	setUITemplate -popTemplate;

	showWindow visorPanelRenameTabWindow;
}

proc buildMainMenu(
	string $panel,
	int $isPopupMenu)
//
// Description:
//	This procedure is called when the visor panel is first opened.
//	This procedure creates menus in the top menubar of the visor panel. 
//
{
	string $menuPrefix;

	if ($isPopupMenu)
	{
		$menuPrefix = "visorPopupMenu";
	}
	else
	{
		$menuPrefix = "visorPanelMenu";
	}

	// Build the File menu
	//
	string $file = (uiRes("m_visorPanel.kFile"));
	if ($isPopupMenu)
	{
		menuItem
			-subMenu true
			-label $file 
			-tearOff true 
			($menuPrefix + "FileMenu");
	}
	else
	{
		menu 
			-label $file 
			-tearOff true 
			($menuPrefix + "FileMenu");
	}
		menuItem 
			-label (uiRes("m_visorPanel.kImport"))
			-annotation (uiRes("m_visorPanel.kImportShadingNetworkAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"import\")");
		menuItem -divider true;
		menuItem 
			-label (uiRes("m_visorPanel.kImportSelectedScene"))
			-annotation	(uiRes("m_visorPanel.kImportSelectedFilesAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"importSelectedSceneFiles\")");
		menuItem -label (uiRes("m_visorPanel.kImportSelectedImage")) -subMenu true;
			menuItem
				-label (uiRes("m_visorPanel.kAsNormal"))
				-annotation (uiRes("m_visorPanel.kImportNormalFileTexturesAnnot")) 
				-command 
					("visorPanelMenuCommand(\"" 
						+ $panel 
						+ "\", \"importSelectedImageFilesAsNormal\")");
			menuItem
				-label (uiRes("m_visorPanel.kAsProjection"))
				-annotation (uiRes("m_visorPanel.kImportProjectedFileTexturesAnnot"))
				-command 
					("visorPanelMenuCommand(\"" 
						+ $panel 
						+ "\", \"importSelectedImageFilesAsProjection\")");
			menuItem
				-label (uiRes("m_visorPanel.kAsStencil"))
				-annotation (uiRes("m_visorPanel.kImportStencilledFileTexturesAnnot"))
				-command 
					("visorPanelMenuCommand(\"" 
						+ $panel 
						+ "\", \"importSelectedImageFilesAsStencil\")");
			menuItem -divider true;
			$includePlacementItem = 
				`menuItem 
					-label (uiRes("m_visorPanel.kIncludePlacement"))
					-checkBox true
					-annotation (uiRes("m_visorPanel.kIncludePlacementAnnot"))
					includePlacementItem`;
			menuItem
				-edit
				-checkBox 
					`optionVar -query createTexturesWithPlacement` 
				-command 
					("optionVar -intValue createTexturesWithPlacement "
						+ "`menuItem -query -checkBox " 
						+ $includePlacementItem
						+ "`; refreshCreateNodeUI();")
				$includePlacementItem;
			setParent -menu ..;
		menuItem -divider true;
		menuItem 
			-label (uiRes("m_visorPanel.kExportSelectedNetwork"))
			-annotation (uiRes("m_visorPanel.kExportSelectedNetworkAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"exportSelectedNetwork\")");

	// Build the View menu
	//
	string $view = (uiRes("m_visorPanel.kView"));
	if ($isPopupMenu)
	{
		setParent -menu ..;
		menuItem
			-subMenu true
			-label $view 
			-tearOff true 
			($menuPrefix + "ViewMenu");
	}
	else
	{
		menu 
			-label $view 
			-tearOff true 
			($menuPrefix + "ViewMenu");
	}
		menuItem 
			-label (uiRes("m_visorPanel.kFrameSelected"))
			-annotation (uiRes("m_visorPanel.kFrameSelectedAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"frameSelected\")");
		menuItem 
			-label (uiRes("m_visorPanel.kFrameAll"))
			-annotation (uiRes("m_visorPanel.kFrameAllAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"frameAll\")");

	// Build the Tabs menu
	//
	string $tabs = (uiRes("m_visorPanel.kTabs"));
	if ($isPopupMenu)
	{
		setParent -menu ..;
		menuItem
			-subMenu true
			-label $tabs
			-tearOff true 
			($menuPrefix + "TabsMenu");
	}
	else
	{
		menu 
			-label $tabs 
			-tearOff true 
			($menuPrefix + "TabsMenu");
	}
		menuItem 
			-label (uiRes("m_visorPanel.kCreateNewTab"))
			-annotation (uiRes("m_visorPanel.kNewTabAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"createNewTab\")");
		menuItem -divider true;
		menuItem 
			-label (uiRes("m_visorPanel.kMoveTabLeft"))
			-annotation (uiRes("m_visorPanel.kMoveTabLeftAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"moveTabLeft\")");
		menuItem 
			-label (uiRes("m_visorPanel.kMoveTabRight"))
			-annotation (uiRes("m_visorPanel.kMoveTabRightAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"moveTabRight\")");
		menuItem 
			-label (uiRes("m_visorPanel.kRenameTab"))
			-annotation (uiRes("m_visorPanel.kRenameTabAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"renameTab\")");
		menuItem -divider true;
		menuItem 
			-label (uiRes("m_visorPanel.kRemoveTab"))
			-annotation (uiRes("m_visorPanel.kRemoveTabAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"removeTab\")");
		menuItem 
			-label (uiRes("m_visorPanel.kRevertDefault"))
			-annotation (uiRes("m_visorPanel.kRevertToDefaultAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"revertToDefaultTabs\")");
		menuItem -divider true;
		string $currentTabOptionsMenu = 
			`menuItem 
				-label (uiRes("m_visorPanel.kCurrentTabOptions"))
				-subMenu true
				currentTabOptionsMenu`;
			setParent -menu ..;
		menuItem
			-edit
			-postMenuCommand 
				("visorPanelBuildTabOptionsMenu " 
					+ $panel
					+ " "
					+ $currentTabOptionsMenu)
			$currentTabOptionsMenu;

	// Add support for the Context Sensitive Help Menu.
	//
	addContextHelpProc $panel "visorPanelBuildContextHelpItems";
			
	// Set the menu bar visibility
	//
	int $menusOkayInPanels = `optionVar -q allowMenusInPanels`;
	panel -e -mbv $menusOkayInPanels $panel;
}


// ---------------------------------------------------------------------------
// 	Global procedures
// 

global proc visorPanelBuildContextHelpItems(
	string $nameRoot, 
	string $menuParent)
{
	//
	// Description:
	//	This procedure is called as the Help menu for this panel is being
	//	built.
	//	This procedure builds the menu item which provides help on the visor.
	//	$nameRoot is the name to use as the root of all item names
	//	$menuParent is the name of the parent of this menu
	//

	menuItem -label (uiRes("m_visorPanel.kHelpVisor"))
		-enableCommandRepeat false
		-command "showHelp Visor";
}

global proc visorPanelBuildTabOptionsMenu(
	string $panel,
	string $menuParent)
{
	//
	// Description:
	//	This procedure is called every time the Tabs->Current Tab Options menu
	//	item in the visor panel menu is selected.
	//	This procedure creates the menu items which will appear in that menu,
	//	such that they are the appropriate ones for the active tab type.
	//

	setParent $panel;
	setParent -menu $menuParent;
	menu
		-edit
		-deleteAllItems
		$menuParent;

	string $activeTab = activeTab($panel);

	if (isDiskTab($activeTab) || isPaintEffectsTab($activeTab))
	{
		string $libraryUI = lookupComponentName($activeTab);
		int $onlyDirectoriesShown = false;
		int $onlyFilesShown = false;
		int $bothShown = false;

		if (
				libraryUIDirectoriesShown($libraryUI)
			&&	libraryUIFilesShown($libraryUI))
		{
			$bothShown = true;
		}
		else if (libraryUIDirectoriesShown($libraryUI))
		{
			$onlyDirectoriesShown = true;
		}
		else if (libraryUIFilesShown($libraryUI))
		{
			$onlyFilesShown = true;
		}
		
		radioMenuItemCollection;
		menuItem 
			-label (uiRes("m_visorPanel.kShowDirectoriesOnly"))
			-radioButton $onlyDirectoriesShown
			-annotation (uiRes("m_visorPanel.kShowDirectoriesAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"showDirectoriesOnly\")");
		menuItem 
			-label (uiRes("m_visorPanel.kShowFilesOnly"))
			-radioButton $onlyFilesShown
			-annotation (uiRes("m_visorPanel.kShowFilesAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"showFilesOnly\")");
		menuItem 
			-label (uiRes("m_visorPanel.kShowBoth"))
			-radioButton $bothShown
			-annotation (uiRes("m_visorPanel.kShowBothAnnot"))
			-command 
				("visorPanelMenuCommand(\"" 
					+ $panel 
					+ "\", \"showDirectoriesAndFiles\")");
		menuItem -divider true;
		menuItem
			-label (uiRes("m_visorPanel.kRefreshFileListing"))
			-annotation (uiRes("m_visorPanel.kRefreshFileListingAnnot"))
			-command
				("visorPanelMenuCommand(\""
					+ $panel 
					+ "\", \"refreshFileListing\")");
		if (isDiskTab($activeTab))
		{
			menuItem
				-label (uiRes("m_visorPanel.kRefreshSelectedSwatches"))
				-annotation (uiRes("m_visorPanel.kRefreshSelectedSwatchesAnnot"))
				-command
					("visorPanelMenuCommand(\""
						+ $panel 
						+ "\", \"refreshSelectedSwatches\")");
			menuItem
				-label (uiRes("m_visorPanel.kRefreshAllSwatches"))
				-annotation (uiRes("m_visorPanel.kRefreshAllSwatchesAnnot"))
				-command
					("visorPanelMenuCommand(\""
						+ $panel 
						+ "\", \"refreshAllSwatches\")");
			menuItem -divider true;
			menuItem
				-label (uiRes("m_visorPanel.kGenerateSwatchFiles"))
				-annotation 
					(uiRes("m_visorPanel.kGenerateSwatchFilesAnnot"))
				-command
					("visorPanelMenuCommand(\""
						+ $panel 
						+ "\", \"saveSwatchesToDisk\")");
		}
	}
	else
	{
		menuItem
			-label (uiRes("m_visorPanel.kNoOptionsAvailable"))
			-enable false;
	}

	setParent -menu ..;
}

global proc visorPanelMenuCommand(
	string $panel,
	string $command)
{
	//
	// Description:
	//	This procedure is called whenever a menu item is chosen from the
	//	visor panel menu.
	//	This procedure is the single global procedure entry point to all
	//	functionality invoked by the menu items. This avoids cluttering the
	//	global procedure namespace with a global procedure for each menu item.
	//	This procedure causes the expected action to be performed. Typically
	//	this will mean calling some local procedure within this file to perform
	//	the action the user expects when they choose the menu item.
	//

	if ($command == "")
	{
	}
	else if ($command == "import")
	{
		Import;
	}
	else if (
			($command == "importSelectedSceneFiles")
		||	($command == "importSelectedImageFilesAsNormal")
		||	($command == "importSelectedImageFilesAsProjection")
		||	($command == "importSelectedImageFilesAsStencil"))
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab) || isPaintEffectsTab($activeTab))
		{
			string $libraryUI;
			$libraryUI = lookupComponentName($activeTab);

			string $filesVisor;
			$filesVisor = libraryUIFilesVisor($libraryUI);

			string $filesToImport[];
			$filesToImport = `visor -query -selectedGadgets $filesVisor`;

			int $asProjection;
			int $asStencil;
			int $withPlacement;

			if ($command == "importSelectedImageFilesAsNormal")
			{
				$asProjection = false;
				$asStencil = false;
			}
			else if ($command == "importSelectedImageFilesAsProjection")
			{
				$asProjection = true;
				$asStencil = false;
			}
			else if ($command == "importSelectedImageFilesAsStencil")
			{
				$asProjection = false;
				$asStencil = true;
			}

			$withPlacement =
				(`optionVar -query createTexturesWithPlacement`);

			int $i;

			for ($i = 0; $i < size($filesToImport); $i++)
			{
				string $importMsg = (uiRes("m_visorPanel.kImportMsg"));
				string $fileTypesArray[] = 
					`file -query -type $filesToImport[$i]`;
				string $fileType = $fileTypesArray[0];

				if (
						($command == "importSelectedSceneFiles") 
					&& 	(	($fileType == "mayaBinary") 
						||	($fileType == "FBX")
						|| 	($fileType == "mayaPLE")
						|| 	($fileType == "mayaAscii")))
				{
					performFileImportAction( $filesToImport[$i] );
					string $display = `format -s $filesToImport[$i] $importMsg`;
					print($display);
				}
				else if ($fileType == "image")
				{
					importImageFile(
						$filesToImport[$i], 
						$asProjection,
						$asStencil,
						$withPlacement);
					string $displayImageMsg = `format -s $filesToImport[$i] $importMsg`;
					print($displayImageMsg);
				}
			}
		}
	}
	else if ($command == "exportSelectedNetwork")
	{
		global string		$gv_operationMode;
		string				$filetype;
		string				$ws = `workspace -q -fn`;

		// Old projects saved their shaders in a directory called "lights".
		// New projects save both lights and shaders in a directory called
		// "shaders". We have to continue to specify that the shading network
		// be stored in whatever directory is used to store lights, just in
		// case this is an old project.
		//
		setWorkingDirectory $ws "image" "lights";

		if (`optionVar -exists defaultFileExportActiveType`) 
		{
			$filetype = `optionVar -q defaultFileExportActiveType`;
		}
		else 
		{
			$filetype = "mayaBinary";
		}

		$gv_operationMode = "ExportActive";
		
		// Open the file browser to export the selection
		//
		fileBrowser "pv_performAction" (uiRes("m_visorPanel.kExportSelection")) $filetype 1;
	}
	else if ($command == "createNewTab")
	{
		createNewTab($panel);
	}
	else if ($command == "moveTabLeft")
	{
		moveTab($panel, "left");
	}
	else if ($command == "moveTabRight")
	{
		moveTab($panel, "right");
	}
	else if ($command == "renameTab")
	{
		renameTab($panel);
	}
	else if ($command == "removeTab")
	{
		string $removeTab = (uiRes("m_visorPanel.kRemoveTabString"));
		string $strVal = activeTabLabel($panel);
		string $removeTabDisplay =`format -s $strVal $removeTab`;
		string $ok = (uiRes("m_visorPanel.kDialogButtonYes"));
		string $no = (uiRes("m_visorPanel.kDialogButtonNo"));
		string $confirm = 
			`confirmDialog
				-title (uiRes("m_visorPanel.kRemoveTabTitle"))
				-message $removeTabDisplay
				-button $ok
				-button $no
				-defaultButton $no
				-cancelButton $no`;
		if ($confirm == $ok )
		{
			evalDeferred("removeActiveTab " + $panel);
		}
	}
	else if ($command == "revertToDefaultTabs")
	{
		string $licensedTabs[] = {
								   "Ocean Examples",
								   "Fluid Examples",
								   "Fluid Initial States",
								   "Effects Assets",
								   "nCloth Examples",
								   "nParticle Examples",
								   "Hair Examples"
								  };
		
		string $tabs[] = { 
						   "Domemaster3D Examples",
						   "Paint Effects",
						   "Toon Examples",
						   "Bifrost Examples",
						   "Sculpting Base Meshes",
						   "Sculpting Stamps",
						   "HumanIK Examples",
						   "Mocap Examples",
						   "Character Clips",
						   "Character Poses",
						   "Unused Clips",
						   "Unused Poses"};

		$tabs[size($tabs)] = "Projects";

		int $fluidsIsLicensed = fluidEditLicenseFound();
		
		int $tabCounter;
		int $licensedTabCounter;
		string $defaultTabs = "" ;
		string $lastTab = "" ;
		
		//
		//Add some elements from the tabs array
		//
		for($tabCounter = 0;$tabCounter < (size($licensedTabs)-1 );$tabCounter++)
		{
			$defaultTabs += ( visorPanelTabs_melToUI( $tabs[$tabCounter] ) + ", " );
		}
		
		//
		//If fluid license is found,
		//add all the elements from the licensedTabs array
		//
		if( $fluidsIsLicensed )
		{
			$defaultTabs += ( visorPanelTabs_melToUI( $licensedTabs[0] ) + ",\n" );
			for($licensedTabCounter = 1;$licensedTabCounter < size($licensedTabs);$licensedTabCounter++)
			{
				$defaultTabs += ( visorPanelTabs_melToUI( $licensedTabs[$licensedTabCounter] ) + ", " );
			}
		}
		
		//
		//The remaining elements from the tabs array (excluding the last) are added
		//Here tabCounter will be (size($licensedTabs)-1 ).
		//
		$defaultTabs += ( visorPanelTabs_melToUI( $tabs[$tabCounter] ) + ",\n" );
		$tabCounter++;
		
		for(;$tabCounter < ( size($tabs)-1 );$tabCounter++)
		{
		// 
		//Here the check has been made to avoid 
		//adding comma (,) to the end of last but one string in the tabs array.
		//
			if($tabCounter == (size($tabs)-2) )
			{
				$defaultTabs += ( visorPanelTabs_melToUI( $tabs[$tabCounter] ) ); 
			}
			else
			{
				$defaultTabs += ( visorPanelTabs_melToUI( $tabs[$tabCounter] ) + ", " );
			}
		}
				
		//
		//Add the last element from the tabs array
		//
		$lastTab += ( visorPanelTabs_melToUI( $tabs[size($tabs) - 1] ) );
		
		string $formatString = (uiRes("m_visorPanel.kRevertAll"));
		string $revertDisplay = `format -s $defaultTabs -s $lastTab $formatString`;

		string $revertOk = (uiRes("m_visorPanel.kRevertTabButtonYes"));
		string $revertNo = (uiRes("m_visorPanel.kRevertTabButtonNo"));
		string $confirm = 
			`confirmDialog
				-title (uiRes("m_visorPanel.kRevertDefaultTitle"))
				-message 
					$revertDisplay
				-button $revertOk
				-button $revertNo
				-defaultButton $revertNo
				-cancelButton $revertNo`;
		if ($confirm == $revertOk )
		{
			evalDeferred("revertToDefaultTabs " + $panel);
		}
	}
	else if ($command == "showDirectoriesOnly")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab) || isPaintEffectsTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUIShowDirectoriesOnly($libraryUI);
			string $tabOptionVar = lookupTabOptionVar($activeTab);
			updateTabOptionVar($tabOptionVar, $activeTab);
		}
	}
	else if ($command == "showFilesOnly")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab) || isPaintEffectsTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUIShowFilesOnly($libraryUI);
			string $tabOptionVar = lookupTabOptionVar($activeTab);
			updateTabOptionVar($tabOptionVar, $activeTab);
		}
	}
	else if ($command == "showDirectoriesAndFiles")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab) || isPaintEffectsTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUIShowDirectoriesAndFiles($libraryUI);
			string $tabOptionVar = lookupTabOptionVar($activeTab);
			updateTabOptionVar($tabOptionVar, $activeTab);
		}
	}
	else if ($command == "refreshFileListing")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab) || isPaintEffectsTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUIRefreshFileListing($libraryUI);
		}
	}
	else if ($command == "refreshSelectedSwatches")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUIRefreshSelectedSwatches($libraryUI);
		}
	}
	else if ($command == "refreshAllSwatches")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUIRefreshAllSwatches($libraryUI);
		}
	}
	else if ($command == "saveSwatchesToDisk")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUISaveSwatchesToDisk($libraryUI);
		}
	}
	else if ($command == "frameSelected")
	{
		string $activeTab = activeTab($panel);
		string $component = lookupComponentName($activeTab);
		string $editor;

		if (isSceneTab($activeTab))
		{
			$editor = collectionUIHypershadeName($component);
		}
		else if (isDiskTab($activeTab) || isPaintEffectsTab($activeTab) || isSculptStampsTab($activeTab))
		{
			$editor = libraryUIFilesVisor($component);
		}

		hyperGraph -edit -frame $editor;
	}
	else if ($command == "frameAll")
	{
		string $activeTab = activeTab($panel);
		string $component = lookupComponentName($activeTab);
		string $editor;

		if (isSceneTab($activeTab))
		{
			$editor = collectionUIHypershadeName($component);
		}
		else if (isDiskTab($activeTab) || isPaintEffectsTab($activeTab) || isSculptStampsTab($activeTab))
		{
			$editor = libraryUIFilesVisor($component);
		}

		hyperGraph -edit -frameGraph $editor;
	}
	else 
	{
		// command string is not empty.  Parse it out for arguments
		// 
		string $cmdTokens[];
		tokenize($command, " ", $cmdTokens);

		if (($cmdTokens[0] == "selectTabByLabel") && 
			 size($cmdTokens) > 1 ) 
		{
			// Make the tab with the given label the active one.
			// The command must be in the form:
			//	 visorPanelMenuCommand( $panel, "selectTabByLabel My Clips")
			// which will select the Tab with the label "My Clips"
			// First get the label by removing the cmd at the front
			//
			string $selectCmd = "selectTabByLabel";
			string $tabLabel = substring($command, size($selectCmd)+2, 
										 size($command));

			// Use this proc to bring that tab to the front
			selectTabByLabel( $panel, $tabLabel );
		}
		else  if (($cmdTokens[0] == "selectOrCreateTabByLabel") && 
			 size($cmdTokens) > 1 ) 
		{
			// Same as "selectTabByLabel" except this will create the tab if
			// it's one of the default ones
			$selectCmd = "selectOrCreateTabByLabel";

			// Parse out the given tab label
			// 
			string $tabLabel = substring($command, size($selectCmd)+2, 
										 size($command));

			
			// If findTabByLabel fails, maybe $tabLabel is English,
			// and we should search tabs for the localized name.
			//
			int $tabIndex = findTabByLabel( $panel, $tabLabel );
			if( $tabIndex == 0 ) {
				$tabIndex = findTabByLabel( $panel, visorPanelTabs_melToUI( $tabLabel ) );
			}

			if( $tabIndex == 0 ) {

				// Tab doesn't exist - try to create it
				string $runTimeDir = `getenv "MAYA_LOCATION"`;
        
        // Domemaster3D tab
        string $domeNewTabLabel = "Domemaster3D Examples";
        string $domeRunTimeDir = `getenv "DOMEMASTER3D_MAYA_DIR"` + "/common";
        string $domeRelDir = "/presets/Domemaster3D/examples";
				if ( $tabLabel == "Domemaster3D Examples" ) {
					createVisorDefaultTab( $domeRunTimeDir, $panel, "firstPaneTabs", 
						$domeRelDir, 
						$domeNewTabLabel );
				} else if( $tabLabel == "HumanIK Examples" ) {
					createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						"/presets/hik/examples", 
						visorPanelTabs_melToUI( "HumanIK Examples" ) );
				} else if( $tabLabel == "Ocean Examples" ) {
					createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						"/presets/fluids/ocean", 
						visorPanelTabs_melToUI( "Ocean Examples" ) );
				} else if( $tabLabel == "Fluid Examples" ) {
					createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						"/presets/fluids/examples", 
						visorPanelTabs_melToUI( "Fluid Examples" ) );
				} else if( $tabLabel == "Fluid Initial States" ) {
					createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						"/presets/fluids/initialStates", 
						visorPanelTabs_melToUI( "Fluid Initial States" ) );
				} else if( $tabLabel == "Hair Examples" ) {
					createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						"/presets/hair/examples", 
						visorPanelTabs_melToUI( "Hair Examples" ) );
				} else if( $tabLabel == "nCloth Examples" ) {
					createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						"/presets/nCloth/examples", 
						visorPanelTabs_melToUI( "nCloth Examples" ) );
				} else if( $tabLabel == "nParticle Examples" ) {
					createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						"/presets/nParticles/examples", 
						visorPanelTabs_melToUI( "nParticle Examples" ) );
				} else if( $tabLabel == "Toon Examples" ) {
					createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						"/presets/toon/examples", 
						visorPanelTabs_melToUI( "Toon Examples" ) );
				} else if( $tabLabel == "Mocap Examples" ) {
					createVisorDefaultTab( $runTimeDir, $panel, "firstPaneTabs", 
						"/presets/mocap/examples", 
						visorPanelTabs_melToUI( "Mocap Examples" ) );
				} 

				// If findTabByLabel fails, maybe $tabLabel is English,
				// and we should search tabs for the localized name.
				//
				$tabIndex = findTabByLabel( $panel, $tabLabel );
				if( $tabIndex == 0 ) {
					$tabIndex = findTabByLabel( $panel, visorPanelTabs_melToUI( $tabLabel ) );
				}
			}

			// Use this proc to bring that tab to the front
			if( $tabIndex > 0 ) {
				selectTabByLabel( $panel, $tabLabel );
			}
		}
	}
}

global proc visorPanelSceneTabPopupMenu(
	string $panel,
	string $hypershade,
	string $popupMenu)
{
	//
	// Description:
	//	This procedure is called when the user RMB clicks in a scene or graph
	//	tab hypershade editor.
	//	This procedure builds the menu items which will appear in the popup
	//	menu.
	//	If the cursor is over a node, this procedure calls
	//	buildHypergraphNodePopupMenuItems() to build the node-specific menu 
	//	items.
	//

	if (!`popupMenu -e -exists $popupMenu`) return;

	// Delete the existing menu items from the popup menu.
	//
	popupMenu -edit -deleteAllItems $popupMenu;
	setParent -menu $popupMenu;

	string $node = `hyperGraph -query -feedbackNode $hypershade`;

	if ($node != "")
	{
		buildHypergraphNodePopupMenuItems($hypershade, $node);
	}
	else
	{
		// There is no node under the cursor.
		//
		buildMainMenu(
			$panel, 
			true); // popup menu
	}
}

global proc visorPanelDiskTabPopupMenu(
	string $panel,
	string $editor,
	string $popupMenu)
{
	//
	// Description:
	//	This procedure is called when the user RMB clicks in a disk tab visor.
	//	This procedure builds the menu items which will appear in the popup
	//	menu.
	//	The contents of the menu can vary based on the type of file the cursor
	//	is positioned over.
	//

	if (!`popupMenu -e -exists $popupMenu`) return;

	// Delete the existing menu items from the popup menu.
	//
	popupMenu -edit -deleteAllItems $popupMenu;
	setParent -menu $popupMenu;

	// Determine what file is under the mouse pointer, if any
	//
	string $filePath = `hyperGraph -query -feedbackNode $editor`;	

	if ($filePath != "")
	{
		buildHypergraphFilePopupMenuItems($editor, $popupMenu, $filePath);
	}
	else
	{
		// There is no file under the cursor.
		//
		buildMainMenu(
			$panel, 
			true); // popup menu
	}
}

proc checkForSculptTool()
{
	string $tool = "sculptMeshCacheContext";
	if( ! `sculptMeshCacheCtx -exists $tool` ) 
		setMeshSculptTool "Sculpt";

	if( `currentCtx` != $tool ) 
		setToolTo $tool;

	toolPropertyWindow;
}

global proc useSelectedStamp( string $path )
{
	checkForSculptTool;

	eval("sculptMeshCacheCtx -e -stampFile \"" + $path + "\" `currentCtx`;");

	sculptMeshCacheCtx -e -useStampImage 1 `currentCtx`;
}

global proc useSelectedStampForMode( string $path, string $mode )
{
	checkForSculptTool;

	sculptMeshCacheCtx -e -mode $mode -useStampImage 1 `currentCtx`;
	eval("sculptMeshCacheCtx -e -stampFile \"" + $path + "\" `currentCtx`;");
}

global proc visorPanelSculptStampsPressCallback(
	string $hypergraphEditor,
	string $fileName)
{
	string $tool = "sculptMeshCacheContext";
	if( `currentCtx` == $tool ) 
		useSelectedStamp( $fileName );
}

global proc visorPanelSculptStampsTabPopupMenu(
	string $panel,
	string $editor,
	string $popupMenu)
{
	//
	// Description:
	//	This procedure is called when the user RMB clicks in a sculpt stamps
	//	tab visor.
	//	This procedure builds the menu items which will appear in the popup
	//	menu.
	//	The contents of the menu can vary based on the type of file the cursor
	//	is positioned over.
	//
	if (!`popupMenu -e -exists $popupMenu`) return;

	// Delete the existing menu items from the popup menu.
	//
	popupMenu -edit -deleteAllItems $popupMenu;
	setParent -menu $popupMenu;

	// Determine what file is under the mouse pointer, if any
	//
	string $filePath = `hyperGraph -query -feedbackNode $editor`;	
	if ($filePath != "")
	{
		setParent -menu $popupMenu;

		string $fileNameArray[];
		tokenize($filePath, "/", $fileNameArray);
		string $fileNameTail = $fileNameArray[size($fileNameArray) - 1];

		string $fileTypesArray[] = `file -query -type $filePath`;
		string $fileType = $fileTypesArray[0];
		if ($fileType == "image")
		{
			menuItem 
				-label (uiRes("m_visorPanel.kUseStamp"))
				-command ("useSelectedStamp(\"" + $filePath + "\")");

			menuItem -subMenu true 
				-label (uiRes("m_visorPanel.kUseStampSub"))
				-command ("useSelectedStamp(\"" + $filePath + "\")");

			source "sculptMeshCacheValues.mel";

			string $modes[] = meshSculptToolModes();
			int $numModes = size($modes);
			for( $i = 0; $i < $numModes; $i ++ )
			{
				string $mode = $modes[$i];
				string $brushInfo[];
				meshSculptBrushInfo( $mode, $brushInfo );

				int $stampVis = $brushInfo[4];
				if( $stampVis )
					menuItem
						-label $mode 
						-command ("useSelectedStampForMode(\"" + $filePath + "\", \"" + $mode + "\")");
			}

			setParent ..;
			// menuItem -divider true;	
		}
	}
	else
	{
		// There is no file under the cursor.
		//
		buildMainMenu(
			$panel, 
			true); // popup menu
	}
}

global proc visorPanelPaintEffectsTabPopupMenu(
	string $panel,
	string $editor,
	string $popupMenu)
{
	//
	// Description:
	//	This procedure is called when the user RMB clicks in a paint effects
	//	tab visor.
	//	This procedure builds the menu items which will appear in the popup
	//	menu.
	//	The contents of the menu can vary based on the type of file the cursor
	//	is positioned over.
	//

	if (!`popupMenu -e -exists $popupMenu`) return;

	// Delete the existing menu items from the popup menu.
	//
	popupMenu -edit -deleteAllItems $popupMenu;
	setParent -menu $popupMenu;

	// Determine what file is under the mouse pointer, if any
	//
	string $filePath = `hyperGraph -query -feedbackNode $editor`;	

	if ($filePath != "")
	{
		buildHypergraphBrushPopupMenuItems($editor, $popupMenu, $filePath);
	}
	else
	{
		// There is no file under the cursor.
		//
		buildMainMenu(
			$panel, 
			true); // popup menu
	}
}

global proc visorPanelBrushPressCallback(
	string $hypergraphEditor,
	string $fileName)
{
	//
	// Description:
	//	This procedure is called when the user LMB clicks on a paint effects
	//	brush preset mel file.
	//	This procedure sources the pressed file, which causes that preset to
	//	become the current paint effects brush.
	//

	eval("source \"" + $fileName + "\"");
}

proc frame(
	string $panel,
	string $frameOperation)
{
	//
	// Description:
	//	This procedure is called from frameAll() or frameSelected() when
	//	the user presses a hotkey to frame the contents of a tab in the
	//	visor panel.
	//	This procedure determines what tab the user's cursor is over, and
	//	performs a frame all or frame selected operation on the component UI in
	//	that tab as requested by the $frameOperation.
	//

	setParent $panel;
	string $firstPaneTabs = `setParent firstPaneTabs`;

	string $firstPaneTab = `tabLayout -query -selectTab $firstPaneTabs`;

	setParent $firstPaneTabs;
	$firstPaneTab = `setParent $firstPaneTab`;

	string $firstPaneHypergraph;

	string $componentName;

	$componentName = lookupComponentName($firstPaneTab);

	if (isDiskTab($firstPaneTab) || isPaintEffectsTab($firstPaneTab) || isSculptStampsTab($firstPaneTab))
	{
		$firstPaneHypergraph = libraryUIFilesVisor($componentName);
	}
	else if (isSceneTab($firstPaneTab))
	{
		$firstPaneHypergraph = collectionUIHypershadeName($componentName);
	}

	if ($frameOperation == "all")
	{
		hyperGraph
			-edit
			-frameGraph
			$firstPaneHypergraph;
	}
	else if ($frameOperation == "selected")
	{
		hyperGraph
			-edit
			-frame
			$firstPaneHypergraph;
	}
}

global proc visorPanelFrameAll(
	string $panel)
{
	//
	// Description:
	//	This procedure is typically called from fitPanel() in fitPanel.mel when
	//	the user presses a hotkey to frame the contents of a tab in the
	//	visor panel.
	//	This procedure calls frame() to perform the operation.
	//
	frame($panel, "all");
}

global proc visorPanelFrameSelected(
	string $panel)
{
	//
	// Description:
	//	This procedure is typically called from fitPanel() in fitPanel.mel when
	//	the user presses a hotkey to frame the selected items in a tab in the
	//	visor panel.
	//	This procedure calls frame() to perform the operation.
	//
	frame($panel, "selected");
}

global proc visorPanelRefreshFilteredTabs(
	string $panel,
	string $filter)
{
	//
	// Description:
	//	This procedure should be called when something in Maya has changed that
	//	requires scene tabs with a specific filter in Visor to be refreshed.
	//	This procedure finds all scene tabs in visor with the specified filter
	//	and refreshes them.
	//

	// Punt if the panel does not currently exist in the UI
	//
	if (`scriptedPanel -query -control $panel` == "") return;

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	setParent $panel;

	string $tabArray[] = `tabLayout -query -childArray firstPaneTabs`;
	int $i;

	// Search through all the tabs for scene tabs that use the specified filter
	//
	for ($i = 0; $i < size($tabArray); $i++)
	{
		setParent $panel;
		setParent firstPaneTabs;
		string $tab = `setParent $tabArray[$i]`;

		if (isSceneTab($tab))
		{
			string $optionVar = lookupTabOptionVar($tab);
			string $tabFilter = `optionVar -query ($optionVar + "Filter")`;

			if ($tabFilter == $filter)
			{
				// We've found a scene tab that uses the specified filter.
				// Refresh the tab.
				//
				string $collectionUI = lookupComponentName($tab);
				string $hypershade = collectionUIHypershadeName($collectionUI);
				visor -rebuild $hypershade;
			}
		}
	}

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;
}

// ---------------------------------------------------------------------------
// 	Scripted panel support
// 

global proc createVisorPanel(string $panel) 
{
	//
	// Description:
	//	This procedure is called the first time the shader editor is opened.
	//	This procedure creates the various UI entities that the shader
	//	editor will use, except for those UI entities which are controls.
	//
}


global proc initVisorPanel(string $panel)
{
	//
	// This is called when the file changes to make sure that everything
	// is up-to-date with the new file.  
	//
}


global proc addVisorPanel(string $panel) 
{
	//
	// Description:
	//	This procedure is called when the shader editor is first opened. 
	//	This procedure creates all of the UI for the shader editor.
	//

	// Show the wait cursor
	//
	waitCursor -state on;

	// Create the lookup table which will keep track of the tabs, their types,
	// and their associated components.
	//
	createVisorPanelLookupTable();

	buildMainMenu(
		$panel,
		false); // not a popup menu

	tabLayout firstPaneTabs;
	setParent ..; // from firstPaneTabs;

	initTabs($panel);

	// Hide the wait cursor
	//
	waitCursor -state off;
}

proc deleteEditors(
	string $tabLayout)
{
	//
	// Description:
	//	This procedure is called from removeVisorPanel(). 
	//	This procedure determines all the hypergraph editors that are being
	//	used within the specified tab layout and deletes them, since the visor 
	//	is going away.
	//

	string $tabArray[] = `tabLayout -query -childArray $tabLayout`;
	string $tab;

	// Delete all hypergraph editors being used by this tab layout
	//
	for ($i = 0; $i < size($tabArray); $i++)
	{
		$tab = $tabArray[$i];
		$tab = ($tabLayout + "|" + $tab);

		string $tabType = lookupTabType($tab);
		string $component = lookupComponentName($tab);
		string $hypergraph;

		if ($tabType == "scene")
		{
			string $hypershade = collectionUIHypershadeName($component);
			collectionUIDelete( $component, 0 );
			hyperGraph -edit -unParent $hypershade;
			deleteUI $hypershade;
		}
		else if ($tabType == "disk" || $tabType == "paint effects" || $tabType == "sculpting stamps")
		{
			string $filesVisor = libraryUIFilesVisor($component);
			string $directoriesVisor = 
				libraryUIDirectoriesVisor($component);
			hyperGraph -edit -unParent $filesVisor;
			deleteUI $filesVisor;
			hyperGraph -edit -unParent $directoriesVisor;
			deleteUI $directoriesVisor;
		}
		else if ($tabType == "graph" || $tabType == "protected graph")
		{
			string $hypershade = graphUIHypershadeName($component);
			hyperGraph -edit -unParent $hypershade;
			deleteUI $hypershade;
		}
	}
}

global proc removeVisorPanel(string $panel) 
{
	//
	// Description:
	//	This procedure is called when the visor is being destroyed
	//	or reparented. 
	//	This procedure ensures that all hypergraph/hypershade/visor editors
	//	used by the various tabs get deleted.
	//

	string $tabLayout;

	setParent $panel;
	$tabLayout = `setParent firstPaneTabs`;
	deleteEditors($tabLayout);
}

global proc string saveStateVisorPanel(string $panel) 
{
	//
	// Description:
	//	This procedure is a required procedure for a scripted panel.
	//  It is meant to return a string which, when executed, will set the
	//  panel's state. Because the visor panel is far too complicated to
	//  have its state recorded in a single string, we use other mechanisms to
	//  remember the state of the visor panel. As a result, we will return
	//  only an empty string from this procedure.
	//

	string $stateStr = "";
	return $stateStr;
}

global proc deleteVisorPanel(string $panel) 
{
	//
	//  Description:
	//    Final deletion of the panel.  Clean up any resources that need to be
	//    freed.
	//
}

global proc visorPanel(string $panel)
{
	global string $gMainPane;

	// Instantiate a new visorPanel
	//
	setParent $gMainPane;
	scriptedPanel -unParent -type visorPanel $panel;
}
