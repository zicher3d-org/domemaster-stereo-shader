/*
  Dome Text V2.1
  2016-08-02
  by Andrew Hazelden

  The DomeText script is a title generator that creates raster title graphics in the png, tif, tga, bmp, and psd formats.

  The title creation settings are saved as extra attributes on the file texture nodes. This makes it possible to re-edit exiting title graphics.
  The Dome Text GUI uses ImageMagick from the command line to create rasterized images with your custom text, font styles, and colors.
  
  On Mac OS X you need to install ImageMagick to either:
  /opt/local/bin/convert
  /opt/ImageMagick/bin/convert
  or you need to add the ImageMagick "convert" tool to your system path by editing your ~/.bash_profile

  Note: On Windows the ImageMagick tool convert.exe was renamed domeconvert.exe to avoid a name collision with an existing Windows utility of the same name.

  Version History
  ----------------
  
  Version 2.1
  -------------
  2016-08-02
  
  Version 1.7
  -------------
  2015-03-07
  
  Version 1.5
  ------------------
  July 12, 2014

  Updated the Mac code that is used to detect which version of ImageMagick is installed.

  
  Version 1.4 Beta 9
  ----------------------
  Dec 9, 2013
  
  Improved Linux font support
  Improved Mac font support
  
  Updated the window's dock controls so the docked vs floating, and docked left/right window settings are restored

  Version 1.4 Beta 6 Build 2
  ----------------------
  Oct 27, 2013

  Added wrapU and wrapV attributes to the GUI. It is now easier to create scrolling credits by setting the auto scroll direction to "scroll up" and un-checking the WrapV checkbox.

  Updated the text mirror controls

  Version 1.3 Build 2
  ----------------------
  Oct 21, 2013
  
  Improved the DomeText Cylinder support
  Added Flip Text Direction control for horizontal text mirroring on a plane or cylinder surface
  
  Version 1.2 Build 5
  --------------------
  Oct 19, 2013
  Improved the save image as controls
  
  
  Version 1.2 Build 4
  --------------------
  Oct 17, 2013
  Added 93 international character encoding formats
	Added controls for converting characters to:
    Upper Case
    Lower Case
    Hex Words
    Hex Single Column
    Binary Words
    Binary Single Column
	Added DomeText aim constraints
  Added Cylinder geometry support
  Added Lambert material support
  Added text animation features for automatic left/right/up/down scrolling text
  Added folder icon to Save Image As field
  Added a Mirror Text Direction checkbox for flipping the direction of text on a plane or cylinder surface
  
  Version 1.2 Build 3
  --------------------
  Oct 8, 2013
  Added UTF8 international character set support
  Added Lambert material support
  Working on scrolling text controls
  Changed the caption for the Copy Node Settings menu to "Copy Text Settings From"
  

  Version 1.1 Build 1
  ---------------------
  Oct 6, 2013
  Initial Version

  To use the Dome Text MEL script run the following MEL commands:
  print("Dome Text Tool");
  source "domeText.mel";
  domeText();

 To check Maya's system paths use:
 system("echo $PATH");
*/

// Check what Maya version is active:
// Example: int $mayaVersion = getMayaVersionDome();
global proc int getMayaVersionDome(){
  // Check if we are running Maya 2011 or higher
  int $mayaVersion = `getApplicationVersionAsFloat`;

  // Test this GUI using the Maya 2010 - non-docked GUI mode
  //int $mayaVersion = 2010;

  // Write out the current Maya version number
  //print("Maya " + $mayaVersion + " detected.\n");

  return $mayaVersion;
}

  
// Check the operating system:
// Example: string $mayaPlatform = getMayaPlatform();
global proc string getMayaPlatform(){
  //-------------------------------------------------
  // Get the current Maya Platform using python
  //      The $mayaPlatform options are:
  //          "windows", "darwin", "linux"
  //-------------------------------------------------

  string $mayaPlatform = "";
  python("import sys");

  if(python("sys.platform == 'win32'")){
    $mayaPlatform = "windows";
  }else if(python("sys.platform == 'windows'")){
    $mayaPlatform = "windows";
  }else if(python("sys.platform == 'darwin'")){
    $mayaPlatform = "darwin";
  }else{
    $mayaPlatform = "linux";
  }

  //print("Running on " + $mayaPlatform + ".\n");
  return $mayaPlatform;
}


global proc SaveDockedDomeTextWindowPos(){
  //Save the DomeViewer dockControl State

  string $dockedArea = `dockControl -query -area domeTextDockControl`;
  int $dockedFloating = `dockControl -query -floating domeTextDockControl`;

  //Save the dockControl window state - options: left,right
  optionVar -stringValue "domeTextDockControlArea" $dockedArea; 

  //Save the dockControl floating state - options: 0, 1
  optionVar -intValue "domeTextDockControlFloating" $dockedFloating;

  //DockControl Debug Info
  if($dockedFloating == 0){
    print("The DomeText window is docked to the " + $dockedArea + " side.\n\n");
  } else {
    print("The DomeText window is floating.\n\n");
  }
}


//Add the selected font to the nodes' extra attribute fields
global proc addNodeFontAttrs(string $nodeName){

  //Add font name
  string $attrName ="font";
  string $fontName =`optionMenuGrp -query -value menuFontNameSelect`;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -dt "string" $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr -type "string" ($nodeName+"."+$attrName) $fontName;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
  //Add encoding name
  string $attrName ="textEncoding";
  string $encodingName =`optionMenuGrp -query -value menuTextEncodingSelect`;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -dt "string" $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr -type "string" ($nodeName+"."+$attrName) $encodingName;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
  //Add fontStyle
  string $attrName ="fontStyle";
  int $fontStyle =`optionMenuGrp -query -select menuFontWeightSelect`-1;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at "enum" -en "ALL:Bold:Bolder:Lighter:Normal:" $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $fontStyle;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
  //Add alignment
  string $attrName ="alignment";
  int $fontAlign =`optionMenuGrp -query -select menuFontAlignSelect`-1;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at "enum" -en "NorthWest:North:NorthEast:West:Center:East:SouthWest:South:SouthEast:" $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $fontAlign;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
  //Add alignTextCamera text
  string $attrName ="alignTextCamera";
  string $CameraName = `optionMenuGrp -query -value menuDomeTextCameraSelect`;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -dt "string" $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr -type "string" ($nodeName+"."+$attrName) $CameraName;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
  //Add font size
  string $attrName ="fontSize";
  int $fontSize = `intSliderGrp -query -value sliderPointSize`;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at long -min 0 -max 2048 $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $fontSize;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
  //Add Convert Characters
  string $attrName ="convertCharacters";
  int $convertCharacters =`optionMenuGrp -query -select menuConvertCharacters`-1;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at "enum" -en "Normal Case:Upper Case:Lower Case:Hex Words:Hex Single Column:Binary Words:Binary Single Column:" $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $convertCharacters;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
  //Add Kerning Size
  string $attrName ="kerningSize";
  float $kerningSize = `floatSliderGrp -query -value sliderKerningSize`;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at double -min -1024 -max 2048 $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $kerningSize;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
  //Add Imagemagick custom text
  string $attrName ="imagemagickCustomText";
  string $imagemagickCustomText = `scrollField -query -text scrollImagemagickCustomText`;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -dt "string" $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr -type "string" ($nodeName+"."+$attrName) $imagemagickCustomText;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
}


//Add custom fg and bg color swatches to the nodes' extra attribute fields
global proc addNodeColorAttrs(string $nodeName){
  //string $NodeName = $domeTextFileNode;

  //Color Swatches
  float $foregroundRGBcolor[3] = `colorSliderGrp -query -rgb sliderForeColor`;
  float $backgroundRGBcolor[3] = `colorSliderGrp -query -rgb sliderBackColor`;

  //Show custom DomeText attrs
  // int $showAdvancedDomeAttrs = 1;
  // string $attrName ="showAdvancedDomeAttrs";
  // if (!`attributeExists $attrName $nodeName`) {
    // addAttr -ln $attrName -at bool -keyable true $nodeName;
    // setAttr ($nodeName+"."+$attrName) $showAdvancedDomeAttrs;
    // setAttr -edit -channelBox true  ($nodeName+"."+$attrName);
    // print("Adding custom showAdvancedDomeAttrs attribute " + $nodeName +"." +$attrName + "\n");
  // }
  
  //Add foreground Color
  string $attrName ="foregroundColor";
  string $attrRName = "foregroundColorR";
  string $attrGName = "foregroundColorG";
  string $attrBName = "foregroundColorB";
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at float3 -uac $nodeName;
    addAttr -ln $attrRName -at "float" -p $attrName $nodeName;
    addAttr -ln $attrGName -at "float" -p $attrName $nodeName;
    addAttr -ln $attrBName -at "float" -p $attrName $nodeName;
    //setAttr -type float3 ($nodeName+"."+$attrName) 1.0 1.0 1.0;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr -type float3 ($nodeName+"."+$attrName) $foregroundRGBcolor[0] $foregroundRGBcolor[1] $foregroundRGBcolor[2];
    print("Adding custom attributes " + $nodeName +"." +$attrName + "\n");
  }

  //Add background Color
  string $attrName ="backgroundColor";
  string $attrRName = "backgroundColorR";
  string $attrGName = "backgroundColorG";
  string $attrBName = "backgroundColorB";
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at float3 -uac $nodeName;
    addAttr -ln $attrRName -at "float" -p $attrName $nodeName;
    addAttr -ln $attrGName -at "float" -p $attrName $nodeName;
    addAttr -ln $attrBName -at "float" -p $attrName $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    //setAttr -type float3 ($nodeName+"."+$attrName) 0.0 0.0 0.0;
    setAttr -type float3 ($nodeName+"."+$attrName) $backgroundRGBcolor[0] $backgroundRGBcolor[1] $backgroundRGBcolor[2];
    print("Adding custom attributes " + $nodeName +"." +$attrName + "\n");
  }

     
  //Add Transparency checkBoxGrp
  int $isbackgroundTransparent = `checkBoxGrp -query -value1 checkGrpTransparentBackground`;
  string $attrName ="isBgTransparent";
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at bool $nodeName;
    setAttr ($nodeName+"."+$attrName) $isbackgroundTransparent;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
}


//Add a DomeText version number attribute to the nodes' extra attribute fields
global proc addDomeTextVersionAttrs(string $nodeName){
  //Add Dome Text Node Version
  string $attrName ="DomeTextVersion";
  int $DomeTextVersion = 1;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at long -min 0 $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $DomeTextVersion;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
}


//Return a value of 1 if the current node is a Dome Text based file node
global proc int isDomeTextNode(string $nodeName){
  string $attrName ="DomeTextVersion";
  int $version = 0;
  //Check if the DomeTextVersion attribute exists
  if (`attributeExists $attrName $nodeName`) {
    //Check the version number is a positive value
    $version = `getAttr ($nodeName+"."+$attrName)`;
    if( $version >= 1){
       //This node is a DomeTextVersion 1 or higher node
      return 1;
    }
    else{
       //This node lacks the correct version number
      return 0;
    }
  }
  else{
    //This node lacks the DomeTextVersion attribute
    return 0;
  }
}


//Add the image attributes to the nodes' extra attribute fields
global proc addNodeImageAttrs(string $nodeName){
  //Add image width
  string $attrName = "width";
  int $imageWidth =`optionMenuGrp -query -select menuImageWidthSelect`-1;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at "enum" -en "64:128:256:512:1024:1536:2048:3072:4096:8196:" $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $imageWidth;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
  //Add image width
  string $attrName = "height";
  int $imageHeight =`optionMenuGrp -query -select menuImageHeightSelect`-1;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at "enum" -en "(auto):64:128:256:512:1024:1536:2048:3072:4096:8196:" $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $imageHeight;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }

  //Add texture format 
  string $attrName ="textureFormat";
  int $textureFormat =`optionMenuGrp -query -select menuTextureFormat`-1;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at "enum" -en "Lambert:SurfaceShader:mia_material_x_passes:Skip Node Creation:Update Existing Node" $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $textureFormat;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
 
  // //Add surface node
  // string $attrName ="surfaceNode";
  // int $surfaceMaterialFormat =`optionMenuGrp -query -select menuSurfaceMaterialFormat`-1;
  // if (!`attributeExists $attrName $nodeName`) {
    // addAttr -ln $attrName -at "enum" -en "None:Surface Shader:Lambert:Mia_material_x_passes:" $nodeName;
    // setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    // setAttr ($nodeName+"."+$attrName) $surfaceMaterialFormat;
    // print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  // }
  
  //Add supporting shape 
  string $attrName ="shapeFormat";
  int $shapeFormat =`optionMenuGrp -query -select menuShapeFormat`-1;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at "enum" -en "None:Plane:Cylinder:Dome:" $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $shapeFormat;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
  //Add the shape orientation axis
  string $attrName = "orientationAxis";
  int $planeDirection =`optionMenuGrp -query -select menuDomeOrientationAxis`-1;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at "enum" -en "Right (X):Top (Y):Front (Z):" -keyable true $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $planeDirection;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
}



// Create Scrolling Text Controls for the DomeText image
//example: createScrollingMayaTexExpr("domeTextPlace2dTexture", "domeTextFileNode");
global proc createScrollingMayaTexExpr(string $domePlace2dNode, string $domeTextFileNode){
  //Add horizontal and vertical text scrolling
  
  //Translate Vertical
  addAttr -ln "verticalTranslate"  -at double  -min -100 -max 100 -softMinValue -1.0 -softMaxValue 1.0 -defaultValue 0 -keyable true $domeTextFileNode;

  //Translate Horizontal
  addAttr -ln "horizontalTranslate"  -at double -min -100 -max 100 -softMinValue -1.0 -softMaxValue 1.0 -defaultValue 0 -keyable true $domeTextFileNode;

  //Final Expression:
  //domeTextPlace2dTexture.translateFrameU = domeTextFileNode.horizontalTranslate;
  //domeTextPlace2dTexture.translateFrameV = domeTextFileNode.verticalTranslate;

  string $domeTextScrollerExpr = "";
  $domeTextScrollerExpr += "// Custom Text Scrolling Expressions\n\n";
  $domeTextScrollerExpr += $domePlace2dNode+ ".translateFrameU = " + $domeTextFileNode + ".horizontalTranslate;";
  $domeTextScrollerExpr += $domePlace2dNode+ ".translateFrameV = " + $domeTextFileNode + ".verticalTranslate;";
  
  expression -name "translateTexture" -string $domeTextScrollerExpr -object $domePlace2dNode -alwaysEvaluate 1 -unitConversion all ;
  
  //------------------------------------------------------------------------------------------
  //Add auto scroll animation modes to the horizontalTranslate and verticalTranslate controls.
  
  //Save the current playhead time value
  int $domeGetCurrentTime = `currentTime -query`;
  
  //Figure out the horizontal and vertical translate extra attribute names
  //Attr names: domeTextFileNode.horizontalTranslate and domeTextFileNode.verticalTranslate
  string $horizontalTranslateName = $domeTextFileNode + ".horizontalTranslate";
  string $verticalTranslateName = $domeTextFileNode + ".verticalTranslate";
  
  //Get the animation values from the DomeText UI

  string $nodeName = $domeTextFileNode;
  
  //Add Scroll Direction
  string $attrName = "scrollDirection";
  int $scrollDirectionInt =`optionMenuGrp -query -select menuAutoScrollDirectionSelect`-1;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at "enum" -en "Off:Scroll Left:Scroll Right:Scroll Up:Scroll Down:" $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $scrollDirectionInt;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
  //Add animationStartFrame
  string $attrName ="animationStartFrame";
  int $animationStartFrame = `intFieldGrp -query -value1 intAnimationStartFrame`;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at long -min 0  $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $animationStartFrame;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
  //Add animationEndFrame
  string $attrName ="animationEndFrame";
  int $animationEndFrame = `intFieldGrp -query -value1 intAnimationEndFrame`;
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at long -min 0  $nodeName;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    setAttr ($nodeName+"."+$attrName) $animationEndFrame;
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  
  //Add looping checkBoxGrp
  int $isLoopAnimation = `checkBoxGrp -query -value1 checkGrpLoopAnimation`;
  string $attrName ="LoopAnimation";
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at bool $nodeName;
    setAttr ($nodeName+"."+$attrName) $isLoopAnimation;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }
  


  //Add mirrorText checkBoxGrp
  int $isMirroredText = `checkBoxGrp -query -value1 checkGrpMirrorText`;
  string $attrName ="mirrorText";
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at bool $nodeName;
    setAttr ($nodeName+"."+$attrName) $isMirroredText;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }

  //Add wrapU checkBoxGrp
  int $textWrapU = `checkBoxGrp -query -value1 checkGrpWrapText`;
  string $attrName ="textWrapU";
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at bool $nodeName;
    setAttr ($nodeName+"."+$attrName) $textWrapU;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }

  //Add wrapV checkBoxGrp
  int $textWrapV = `checkBoxGrp -query -value2 checkGrpWrapText`;
  string $attrName ="textWrapV";
  if (!`attributeExists $attrName $nodeName`) {
    addAttr -ln $attrName -at bool $nodeName;
    setAttr ($nodeName+"."+$attrName) $textWrapV;
    setAttr -edit -channelBox true ($nodeName+"."+$attrName);
    print("Adding custom attribute " + $nodeName +"." +$attrName + "\n");
  }

  string $scrollDirection =`optionMenuGrp -query -value menuAutoScrollDirectionSelect`;
  
  int $animationFrameRange = $animationEndFrame - $animationStartFrame;
  
  if($scrollDirection == "Off"){
    print("Auto text scrolling is disabled.\n");
  } else if($scrollDirection == "Scroll Left" ){
    print("Auto text scrolling is set to scroll left over " + $animationFrameRange + " frames.\n");
    
    //Go to frame 1
    currentTime $animationStartFrame ;
    if($textWrapU){
      setAttr $horizontalTranslateName 0; //0 for wrapping
    } else {
      setAttr $horizontalTranslateName 1; //1 for non wrapping
    }
    setKeyframe $horizontalTranslateName;
    
    //Go to the duration set the the "scroll speed" setting
    currentTime $animationEndFrame ;
    setAttr $horizontalTranslateName -1;
    setKeyframe $horizontalTranslateName;
  } else if($scrollDirection == "Scroll Right" ){
    print("Auto text scrolling is set to scroll right over " + $animationFrameRange + " frames.\n");
    
    //Go to frame 1
    currentTime $animationStartFrame ;
    if($textWrapU){
      setAttr $horizontalTranslateName 0; //0 for wrapping
    } else {
      setAttr $horizontalTranslateName -1; //1 for non wrapping
    }
    setKeyframe $horizontalTranslateName;
    
    //Go to the end of the animation
    currentTime $animationEndFrame ;
    setAttr $horizontalTranslateName 1;
    setKeyframe $horizontalTranslateName;
  } else if($scrollDirection == "Scroll Up" ){
    print("Auto text scrolling is set to scroll up over " + $animationFrameRange + " frames.\n");

    //Go to frame 1
    currentTime $animationStartFrame ;
    if($textWrapV){
      setAttr $verticalTranslateName 0; //0 for wrapping
    } else {
      setAttr $verticalTranslateName -1; //1 for non wrapping
    }
    setKeyframe $verticalTranslateName;
    
    //Go to the end of the animation
    currentTime $animationEndFrame ;
    setAttr $verticalTranslateName 1;
    setKeyframe $verticalTranslateName;
  } else if($scrollDirection == "Scroll Down" ){
    print("Auto text scrolling is set to scroll down over " + $animationFrameRange + " frames.\n");
    
    //Go to frame 1
    currentTime $animationStartFrame ;
    if($textWrapV){
      setAttr $verticalTranslateName 0; //0 for wrapping
    } else {
      setAttr $verticalTranslateName 1; //1 for non wrapping
    }
    setKeyframe $verticalTranslateName;
    
    //Go to the end of the animation
    currentTime $animationEndFrame ;
    setAttr $verticalTranslateName -1;
    setKeyframe $verticalTranslateName;
  }
  
  //Set the animation keys to linear keys
  keyTangent -e -itt linear -ott linear -animation objects $verticalTranslateName;
  
  //Check if the animation mode is enabled and the playback should loop
  if($scrollDirection != "Off"){
    if($isLoopAnimation ){
      print("Looping the dometext animation using post infinity cycles.\n");
      if(($scrollDirection == "Scroll Right") || ($scrollDirection == "Scroll Left")){
        //Set the animation to post infinity cycles
        string $domeHorizontalAnimCurves[] = `listConnections -type "animCurveTU" ($horizontalTranslateName)`;
        string $horizontalAnimCurveName = $domeHorizontalAnimCurves[0];
        setAttr ($horizontalAnimCurveName+".postInfinity") 1;
      } else if( ($scrollDirection == "Scroll Up") || ($scrollDirection == "Scroll Down") ){
        //Set the animation to post infinity cycles
        string $domeVerticalAnimCurves[] = `listConnections -type "animCurveTU" ($verticalTranslateName)`;
        string $verticalAnimCurveName = $domeVerticalAnimCurves[0];
        setAttr ($verticalAnimCurveName+".postInfinity") 1;
      }
    } else {
      print("The dometext animation will play a single time.\n");
    }
  }

  //Return the time playhead back to its original position
  currentTime $domeGetCurrentTime;
  
}


//Create a dome text Maya SurfaceShader + a Maya file node with a specified image name and default background color
//example:
//createSurfaceShaderDomeFileNode("sourceimages/bob.png", {0.0, 1.0, 0.0});
global proc string createSurfaceShaderDomeFileNode(string $imagePath, float $bgColor[] ){
  print("Image Path: " + $imagePath + "\n");
  print("Background color: [" + $bgColor[0] + ", " + $bgColor[1] + ", "+ $bgColor[2]+ "]\n");

  //string $domePlace2dNode = "place2dTexture1";
  //string $domeTextFileNode = "file1";

  string $domeTextFileNode = `shadingNode -asTexture file -name "domeTextFileNode"`;
  string $domePlace2dNode = `shadingNode -asUtility place2dTexture -name "domeTextPlace2dTexture"`;

  //float $bgColor[3] = {0.0, 1.0, 0.0};
  //string $imagePath = "sourceimages/bob.png";

  //Connect the place2D texture node to the Maya Dome Text file texture node
  connectAttr -f ($domePlace2dNode+".coverage") ($domeTextFileNode+".coverage");
  connectAttr -f ($domePlace2dNode+".translateFrame") ($domeTextFileNode+".translateFrame");
  connectAttr -f ($domePlace2dNode+".rotateFrame") ($domeTextFileNode+".rotateFrame");
  connectAttr -f ($domePlace2dNode+".mirrorU") ($domeTextFileNode+".mirrorU");
  connectAttr -f ($domePlace2dNode+".mirrorV") ($domeTextFileNode+".mirrorV");
  connectAttr -f ($domePlace2dNode+".stagger") ($domeTextFileNode+".stagger");
  connectAttr -f ($domePlace2dNode+".wrapU") ($domeTextFileNode+".wrapU");
  connectAttr -f ($domePlace2dNode+".wrapV") ($domeTextFileNode+".wrapV");
  connectAttr -f ($domePlace2dNode+".repeatUV") ($domeTextFileNode+".repeatUV");
  connectAttr -f ($domePlace2dNode+".offset") ($domeTextFileNode+".offset");
  connectAttr -f ($domePlace2dNode+".rotateUV") ($domeTextFileNode+".rotateUV");
  connectAttr -f ($domePlace2dNode+".noiseUV") ($domeTextFileNode+".noiseUV");
  connectAttr -f ($domePlace2dNode+".vertexUvOne") ($domeTextFileNode+".vertexUvOne");
  connectAttr -f ($domePlace2dNode+".vertexUvTwo") ($domeTextFileNode+".vertexUvTwo");
  connectAttr -f ($domePlace2dNode+".vertexUvThree") ($domeTextFileNode+".vertexUvThree");
  connectAttr -f ($domePlace2dNode+".vertexCameraOne") ($domeTextFileNode+".vertexCameraOne");
  connectAttr -f ($domePlace2dNode+".outUV") ($domeTextFileNode+".uvCoord");
  connectAttr -f ($domePlace2dNode+".outUvFilterSize") ($domeTextFileNode+".uvFilterSize");

  //Set the default background color
  //setAttr ($domeTextFileNode+".defaultColor") -type double3 0.0 1.0 0.0 ;
  setAttr ($domeTextFileNode+".defaultColor") -type double3 $bgColor[0] $bgColor[1] $bgColor[2] ;

  //Attach the PNG file texture to the file node
  //setAttr -type "string" ($domeTextFileNode+".fileTextureName") "sourceimages/bob.png";
  setAttr -type "string" ($domeTextFileNode+".fileTextureName") $imagePath;

  //Add the Dome Text version to the node
  addDomeTextVersionAttrs($domeTextFileNode);
  
  //Add fg and bg color swatches to the node
  addNodeColorAttrs($domeTextFileNode);
  
  //Add the font name to the file node
  addNodeFontAttrs($domeTextFileNode);
  
  //Add the image attributes to the file node
  addNodeImageAttrs($domeTextFileNode);
  
  //Create a default surfaceShader material
  string $domeTextMatNode = `shadingNode  -name "dometext_material" -asShader surfaceShader`;
  
  // Connect the Maya file texture to the surface shader preview material 
  connectAttr -force ($domeTextFileNode+".outColor") ($domeTextMatNode+".outColor");
  
  //Connect the Maya file texture transparency to the surface shader
  connectAttr -f ($domeTextFileNode+".outTransparency") ($domeTextMatNode+".outTransparency");
  
  //Create the shading group node and connect it to the surface shader
  string $domeTextSGNode = `sets -renderable true -noSurfaceShader true -empty -name ($domeTextMatNode+"SG")`;
  connectAttr -f ($domeTextMatNode+".outColor") ($domeTextSGNode+".surfaceShader");
  
  // Connect the Maya file texture to the lambert incandescent material 
  //connectAttr -force ($domeTextFileNode+".outColor") ($domeTextMatNode+".incandescence");
  
  //Create the supporting geometry
  string $domeGeometry = chooseDomeGeometry();
  
  int $domeShapeFormat = `optionMenuGrp -query -select menuShapeFormat`;
  
  //Check if a supporting shape was created
  if( ($domeShapeFormat > 1 ) && (`objExists $domeGeometry` )  ){
    //Apply the shading group to the selected geometry
    select $domeGeometry;
    hyperShade -assign $domeTextSGNode;
  }else {
    print("Shading group assignment skipped\n");
  }
  
  //Align the dome text to the camera
  aimDomeTextPlane($domeGeometry);
  
  // Create Scrolling Text Controls for the DomeText image
  createScrollingMayaTexExpr( $domePlace2dNode, $domeTextFileNode );
   
  return $domeTextFileNode;
}


//Create a dome text Maya Lambert + a Maya file node with a specified image name and default background color
//example:
//createLambertDomeFileNode("sourceimages/bob.png", {0.0, 1.0, 0.0});
global proc string createLambertDomeFileNode(string $imagePath, float $bgColor[] ){
  print("Image Path: " + $imagePath + "\n");
  print("Background color: [" + $bgColor[0] + ", " + $bgColor[1] + ", "+ $bgColor[2]+ "]\n");

  //string $domePlace2dNode = "place2dTexture1";
  //string $domeTextFileNode = "file1";

  string $domeTextFileNode = `shadingNode -asTexture file -name "domeTextFileNode"`;
  string $domePlace2dNode = `shadingNode -asUtility place2dTexture -name "domeTextPlace2dTexture"`;

  //float $bgColor[3] = {0.0, 1.0, 0.0};
  //string $imagePath = "sourceimages/bob.png";

  //Connect the place2D texture node to the Maya Dome Text file texture node
  connectAttr -f ($domePlace2dNode+".coverage") ($domeTextFileNode+".coverage");
  connectAttr -f ($domePlace2dNode+".translateFrame") ($domeTextFileNode+".translateFrame");
  connectAttr -f ($domePlace2dNode+".rotateFrame") ($domeTextFileNode+".rotateFrame");
  connectAttr -f ($domePlace2dNode+".mirrorU") ($domeTextFileNode+".mirrorU");
  connectAttr -f ($domePlace2dNode+".mirrorV") ($domeTextFileNode+".mirrorV");
  connectAttr -f ($domePlace2dNode+".stagger") ($domeTextFileNode+".stagger");
  connectAttr -f ($domePlace2dNode+".wrapU") ($domeTextFileNode+".wrapU");
  connectAttr -f ($domePlace2dNode+".wrapV") ($domeTextFileNode+".wrapV");
  connectAttr -f ($domePlace2dNode+".repeatUV") ($domeTextFileNode+".repeatUV");
  connectAttr -f ($domePlace2dNode+".offset") ($domeTextFileNode+".offset");
  connectAttr -f ($domePlace2dNode+".rotateUV") ($domeTextFileNode+".rotateUV");
  connectAttr -f ($domePlace2dNode+".noiseUV") ($domeTextFileNode+".noiseUV");
  connectAttr -f ($domePlace2dNode+".vertexUvOne") ($domeTextFileNode+".vertexUvOne");
  connectAttr -f ($domePlace2dNode+".vertexUvTwo") ($domeTextFileNode+".vertexUvTwo");
  connectAttr -f ($domePlace2dNode+".vertexUvThree") ($domeTextFileNode+".vertexUvThree");
  connectAttr -f ($domePlace2dNode+".vertexCameraOne") ($domeTextFileNode+".vertexCameraOne");
  connectAttr -f ($domePlace2dNode+".outUV") ($domeTextFileNode+".uvCoord");
  connectAttr -f ($domePlace2dNode+".outUvFilterSize") ($domeTextFileNode+".uvFilterSize");

  //Set the default background color
  //setAttr ($domeTextFileNode+".defaultColor") -type double3 0.0 1.0 0.0 ;
  setAttr ($domeTextFileNode+".defaultColor") -type double3 $bgColor[0] $bgColor[1] $bgColor[2] ;

  //Attach the PNG file texture to the file node
  //setAttr -type "string" ($domeTextFileNode+".fileTextureName") "sourceimages/bob.png";
  setAttr -type "string" ($domeTextFileNode+".fileTextureName") $imagePath;

  //Add the Dome Text version to the node
  addDomeTextVersionAttrs($domeTextFileNode);
  
  //Add fg and bg color swatches to the node
  addNodeColorAttrs($domeTextFileNode);
  
  //Add the font name to the file node
  addNodeFontAttrs($domeTextFileNode);
  
  //Add the image attributes to the file node
  addNodeImageAttrs($domeTextFileNode);
  
  //Create a default surfaceShader material
  string $domeTextMatNode = `shadingNode  -name "dometext_material" -asShader lambert`;
  
  // Connect the Maya file texture to the lambert shader preview material 
  connectAttr -force ($domeTextFileNode+".outColor") ($domeTextMatNode+".color");
  
  //Connect the Maya file texture transparency to the lambert shader
  connectAttr -f ($domeTextFileNode+".outTransparency") ($domeTextMatNode+".transparency");
  
  //Create the shading group node and connect it to the lambert shader
  string $domeTextSGNode = `sets -renderable true -noSurfaceShader true -empty -name ($domeTextMatNode+"SG")`;
  connectAttr -f ($domeTextMatNode+".outColor") ($domeTextSGNode+".surfaceShader");
  
  // Connect the Maya file texture to the lambert incandescent material 
  connectAttr -force ($domeTextFileNode+".outColor") ($domeTextMatNode+".incandescence");
  
  //Create the supporting geometry
  string $domeGeometry = chooseDomeGeometry();
  
  int $domeShapeFormat = `optionMenuGrp -query -select menuShapeFormat`;
  
  //Check which direction is 'front' for the text
  int $isMirroredText = `checkBoxGrp -query -value1 checkGrpMirrorText`;

  //Check if the texture wrapping is enabled
  int $textWrapU = `checkBoxGrp -query -value1 checkGrpWrapText`;
  int $textWrapV = `checkBoxGrp -query -value2 checkGrpWrapText`;
  setAttr ($domePlace2dNode+".wrapU") $textWrapU;
  setAttr ($domePlace2dNode+".wrapV") $textWrapV;

  //Check if a supporting shape was created
  if( ($domeShapeFormat > 1 ) && (`objExists $domeGeometry` )  ){
    //Apply the shading group to the selected geometry
    select $domeGeometry;
    hyperShade -assign $domeTextSGNode;
     
    //Modify the texture direction on polygon planes
    if ($domeShapeFormat == 2){
      //Check if the mirrored text checkbox is enabled
      if($isMirroredText){
        setAttr ($domePlace2dNode+".repeatU") -1;
      } else {
        setAttr ($domePlace2dNode+".repeatU") 1;
      }
    }
    
    //Modify the shape if it is a NURBS Cylinder
    if ( $domeShapeFormat ==3 ){
      //Creation Axis: Right (X):Top (Y): Front (Z)
      int $cylinderDirection = `optionMenuGrp -query -select menuDomeOrientationAxis`-1;
        
      //Adjust the orientation axis placement of the NURBS Cylinder text.
      if ( $cylinderDirection == 0 ){
        //Right (X)
        //Adjust the texture so it is upright on the NURBS Cylinder
        setAttr ($domePlace2dNode+".rotateFrame") 90;
        setAttr ($domeGeometry+".rotateY") -180;
        
        setAttr ($domePlace2dNode+".repeatV") 1;
        
        //Check if the mirrored text checkbox is enabled
        if($isMirroredText){
          setAttr ($domePlace2dNode+".repeatU") -1;
        } else {
          setAttr ($domePlace2dNode+".repeatU") 1;
        }

      } else if ( $cylinderDirection == 1 ){
        //Top (Y)
        //Adjust the texture so it is upright on the NURBS Cylinder
        setAttr ($domePlace2dNode+".rotateFrame") -90;
        setAttr ($domeGeometry+".rotateZ") -90;
       
        setAttr ($domePlace2dNode+".repeatV") 1;
         //Check if the mirrored text checkbox is enabled
        if($isMirroredText){
          setAttr ($domePlace2dNode+".repeatU") -1;
        } else {
          setAttr ($domePlace2dNode+".repeatU") 1;
        }
        
      }else if ( $cylinderDirection == 2 ){
        //Front (Z)
        //Adjust the texture so it is upright on the NURBS Cylinder
        setAttr ($domePlace2dNode+".rotateFrame") 90;
        setAttr ($domeGeometry+".rotateY") 90;
        
        setAttr ($domePlace2dNode+".repeatV") 1;
        
        //Check if the mirrored text checkbox is enabled
        if($isMirroredText){
          setAttr ($domePlace2dNode+".repeatU") -1;
        } else {
          setAttr ($domePlace2dNode+".repeatU") 1;
        }
      }
    }
  }else {
    print("Shading group assignment skipped\n");
  }
  
  //Align the dome text to the camera
  aimDomeTextPlane($domeGeometry);
  
  // Create Scrolling Text Controls for the DomeText image
  createScrollingMayaTexExpr( $domePlace2dNode, $domeTextFileNode );
   
  return $domeTextFileNode;
}


//Create a dome text mental ray texture file node with a specified image name
//example:
//createDomeMrFileNode("sourceimages/bob.png", {0.0, 1.0, 0.0});
global proc string createDomeMrFileNode(string $imagePath, float $bgColor[] ){
  print("Image Path: " + $imagePath + "\n");
  print("Background color: [" + $bgColor[0] + ", " + $bgColor[1] + ", "+ $bgColor[2]+ "]\n");

  //string $domePlace2dNode = "place2dTexture1";
  //string $domeTextFileNode = "file1";

  string $domeText_tex_vector = `shadingNode -asUtility "mib_texture_vector" -name "domeText_mib_texture_vector1"`;
  string $domeText_tex_remap = `shadingNode -asUtility "mib_texture_remap" -name "domeText_mib_texture_remap1"`;
  string $domeText_tex_lookup= `shadingNode -asUtility "mib_texture_lookup" -name "domeText_mib_texture_lookup1"`;
  string $domeText_mr_tex = `shadingNode -asTexture "mentalrayTexture" -name "domeText_mentalrayTexture1"`; 
  
  string $domeTextMatNode = `shadingNode  -name "dometext_material" -asShader mia_material_x_passes`;

  //float $bgColor[3] = {0.0, 1.0, 0.0};
  //string $imagePath = "sourceimages/bob.png";

  //Connect the color texture nodes
  connectAttr -f ($domeText_tex_vector+".outValue")  ($domeText_tex_remap+".input");
  // mib_texture_vector.outValue -> mib_texture_remap.input

  connectAttr -f ($domeText_tex_remap+".outValue") ($domeText_tex_lookup+".coord");
  // mib_texture_remap.outValue -> mib_texture_lookup.coord

  connectAttr -f  ($domeText_mr_tex+".message")  ($domeText_tex_lookup+".tex");
  // mentalrayTexture.message -> mib_texture_lookup.tex

  //Set the default background color
  //setAttr ($domeTextFileNode+".defaultColor") -type double3 0.0 1.0 0.0 ;
  //setAttr ($domeText_mr_tex+".defaultColor") -type double3 $bgColor[0] $bgColor[1] $bgColor[2] ;

  //Attach the PNG file texture to the mental ray file texture node
  //setAttr -type "string" ($domeTextFileNode+".fileTextureName") "sourceimages/bob.png";
  setAttr -type "string" ($domeText_mr_tex+".fileTextureName") $imagePath;

  //Add the Dome Text version to the node
  addDomeTextVersionAttrs($domeText_mr_tex);
  
  //Add fg and bg color swatches to the nodes
  addNodeColorAttrs($domeText_mr_tex);
  
  //Add the font name to the file node
  addNodeFontAttrs($domeText_mr_tex);
  
  //Add the image attributes to the file node
  addNodeImageAttrs($domeText_mr_tex);
  
  //Set the mia_x_passes material to be glossy
  setAttr ($domeTextMatNode+".refl_color") -type double3 1 1 1;
  setAttr ($domeTextMatNode+".reflectivity") 0;
  setAttr ($domeTextMatNode+".refl_gloss") 0;
  setAttr ($domeTextMatNode+".diffuse_roughness") 0;
  setAttr ($domeTextMatNode+".diffuse_weight") 1;
  setAttr ($domeTextMatNode+".diffuse") -type double3 0 0 0;
  
  //Create the shading group node
  string $domeTextSGNode = `sets -renderable true -noSurfaceShader true -empty -name ($domeTextMatNode+"SG")`;
  
  //Attach the texture lookup node to the mia_x_passes material
  connectAttr -f ($domeText_tex_lookup+".outValue") ($domeTextMatNode+".additional_color");
  connectAttr -f ($domeText_tex_lookup+".outValueA") ($domeTextMatNode+".additional_colorA");
  
  //Attach the texture lookup node to the mia_x_passes material
  connectAttr -f ($domeText_tex_lookup+".outValue") ($domeTextMatNode+".diffuse");
  connectAttr -f ($domeText_tex_lookup+".outValueA") ($domeTextMatNode+".diffuseA");
  
  //Attach the mia_x_passes material to the shading group
  connectAttr -f ($domeTextMatNode+".message") ($domeTextSGNode+".miMaterialShader");
  connectAttr -f ($domeTextMatNode+".message") ($domeTextSGNode+".miPhotonShader");
  connectAttr -f ($domeTextMatNode+".message") ($domeTextSGNode+".miShadowShader");
  
  //Make the surface transparent using the cut-out opacity option
  //int $isbackgroundTransparent = `checkBoxGrp -query -value1 checkGrpTransparentBackground`;
  //if ($isbackgroundTransparent){
  //connectAttr -f ($domeText_tex_lookup+".outValueA") ($domeTextMatNode+".cutout_opacity");
  //}
  
  //Create the supporting geometry
  string $domeGeometry = chooseDomeGeometry();
  int $domeShapeFormat = `optionMenuGrp -query -select menuShapeFormat`;
  
  //Check if a supporting shape was created
  if( ($domeShapeFormat > 1 ) && (`objExists $domeGeometry` )  ){
    //Apply the shading group to the selected geometry
    select $domeGeometry;
    hyperShade -assign $domeTextSGNode;

    //Modify the shape if it is a NURBS Cylinder
    if ( $domeShapeFormat ==3 ){
      //Creation Axis: Right (X):Top (Y): Front (Z)
      int $cylinderDirection = `optionMenuGrp -query -select menuDomeOrientationAxis`-1;
        
      //Adjust the orientation axis placement of the NURBS Cylinder text.
      if ( $cylinderDirection == 0 ){
        //Right (X)
        //setAttr ($domePlace2dNode+".rotateFrame") 90;
        setAttr ($domeGeometry+".rotateY") -180;
      } else if ( $cylinderDirection == 1 ){
        //Top (Y)
        //setAttr ($domePlace2dNode+".rotateFrame") -90;
        setAttr ($domeGeometry+".rotateZ") -90;
      }else if ( $cylinderDirection == 2 ){
        //Front (Z)
        //setAttr ($domePlace2dNode+".rotateFrame") 90;
        setAttr ($domeGeometry+".rotateY") 90;
      }
    }
    
  }else {
    print("Shading group assignment skipped\n");
  }
  
  //Align the dome text to the camera
  aimDomeTextPlane($domeGeometry);
  
  return $domeText_mr_tex;
}

//Align the dome text to the camera
//Syntax: aimDomeTextPlane("DomeTextPlane");
global proc aimDomeTextPlane( string $domeGeometry){
  //Get the camera name
  string $CameraName = `optionMenuGrp -query -value menuDomeTextCameraSelect`;
  
  if ( $CameraName  != "Select a Camera..." ){
    print("Parenting the DomeText " + $domeGeometry +" to the "+ $CameraName + " camera.\n");
    
    //Syntax: pointConstraint parentName childName;
    //pointConstraint -offset 0 0 0 -weight 1 `getObjectParentNode($CameraName)` $domeGeometry;
    
    //Syntax: AimConstrain parentName childName;
    //aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0;
    
    aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $CameraName $domeGeometry;
  }
}

//Toggle the surface material, and shape option menus
global proc disableSurfaceAndShape(){
  if( (`optionMenuGrp -query -select menuTextureFormat`) >=3 ){
    //Disable the selection of the menu items
    //optionMenuGrp -edit -enable false menuSurfaceMaterialFormat;
    optionMenuGrp -edit -enable false menuShapeFormat;
    
    //Reset the menus to the first item in the list
    //optionMenuGrp -edit -select 1 menuSurfaceMaterialFormat;
    //optionMenuGrp -edit -select 1 menuShapeFormat;
  }else{
    //Enable the selection of the menu items
    //optionMenuGrp -edit -enable true menuSurfaceMaterialFormat;
    optionMenuGrp -edit -enable true menuShapeFormat;
    
    //Reset the menus to the defaults
    //optionMenuGrp -edit -select 2 menuSurfaceMaterialFormat;
  }
}


//Toggle the shape option menus
global proc disableShape(){
  //if( 1>=(`optionMenuGrp -query -select menuSurfaceMaterialFormat`) ){
    //Disable the selection of the menu items
  //  optionMenuGrp -edit -enable false menuShapeFormat;
    //Reset the menus to the first item in the list
    // //optionMenuGrp -edit -select 1 menuShapeFormat;
  //}else{
    //Enable the selection of the menu items
    optionMenuGrp -edit -enable true menuShapeFormat;
 // }
}


global proc string getDomeImagePath(){
  //Read the current "sourceimages" directory from the workspace (set project) settings
  string $defaultSourceImages;
  
  // Check if we are running Maya 2011 or higher
  float $mayaVersion = getMayaVersionDome();
  
  //File dialog results path
  string $resultArray[];
  string $result;
  
  //Listed file types
  string $basicFilter = "*.png";
  
  string $advancedFilter = "Images( *.png *.tif *.tga *.bmp *.psd);;PNG (*.png);;Targa (*.tga);;Tiff (*.tif);;Windows Bitmap (*.bmp);;All Files (*.*)";
  
  //Check if  you are running Maya 2011 or newer and then show the fileDialog2 file picker
  if ($mayaVersion >=2011){
    //Maya 2011+ 
    //List directories with starting location and a open button
    
    // $defaultSourceImages  = `workspace -expandName "sourceimages"`;
    $defaultSourceImages =`textFieldGrp -query -text textImageOutputName`;

    $resultArray  = `fileDialog2 
    -fileMode 0 
    -startingDirectory $defaultSourceImages
    -fileFilter $advancedFilter
    -okCaption "Select"
    -cancelCaption "Cancel"
    -caption "Select an Image Path"
    -dialogStyle 2`;
    
    print("Using the FileDialog2 image picker.\n");
    
    $result = $resultArray[0];
  }else{
    //Check if  you are running Maya 2010 or older and then show the classic fileDialog file picker
    $defaultSourceImages  = `workspace -expandName "sourceimages"` + "/" + $basicFilter;
    
    //Maya 2010 or lower
    // list directories with starting location and a open button
   $result = `fileDialog 
    -mode 1 
    -directoryMask $defaultSourceImages
    -title "Select an Image Path"`;
    
  print("Using the FileDialog image picker.\n");
  }

  return $result;
}


//Rebuild the Text Preset option menu
global proc buildTextPresetMenu(){
  if(`optionMenuGrp -exists menuTextPresetSelect`){
    //print("Removing the existing Text Preset menu.\n");
    deleteUI menuTextPresetSelect;
  } else {
    //print("Create the Text Preset menu.\n");
  }

  // Create the Text Preset Pop-up Menu  
  optionMenuGrp
    //-label "Copy Node Settings"
    -label "Copy Text Settings From"
    -columnAlign 1 "right"
    -changeCommand "string $NodeName =`optionMenuGrp -query -value menuTextPresetSelect`;restoreDomeTextPreset($NodeName);"
    -annotation "Load the settings from an existing Dome Text file texture node back into the DomeText window."
    -parent textPresetLayout
     menuTextPresetSelect;

  menuItem -label "Select a DomeText Node...";
  // menuItem -label "file1";
  // menuItem -label "file2";
  // menuItem -label "mentalrayTexture1";
  // menuItem -label "mentalrayTexture2";
 
  //List all of the texture nodes
  string $fileNodeList[] = `lsType("file")`;
  string $mrFileNodeList[] = `lsType("mentalrayTexture")`;
  string $textureNodeItems = "";
  
  //Sort the texture node names alphabetically
  $fileNodeList = sort($fileNodeList);
  $mrFileNodeList = sort($mrFileNodeList);
  
  //print ("Nodes:\n");
  //print ($fileNodeList);
  //print ($mrFileNodeList);
    
  int $i = 0; //track the total number of maya + mr texture nodes
  
  //Scan Maya File Texture Nodes
  for ( $textureNodeItems in $fileNodeList )
  {
     // Look for the last item <done> in the array
     if ( ($textureNodeItems != "<done>") && (isDomeTextNode($textureNodeItems))  ){
       //print ( "Maya Texture[" + $i + "] " + $textureNodeItems + "\n");
       menuItem -label $textureNodeItems;
     }
     $i = $i+1;
  }

  //menuItem -divider true;
  
  //Scan Mental Ray File Texture Nodes
  for ( $textureNodeItems in $mrFileNodeList )
  {
     // Look for the last item <done> in the array
     if ( ($textureNodeItems != "<done>") && (isDomeTextNode($textureNodeItems))  ){
       //print ( "MR Texture[" + $i + "] " + $textureNodeItems + "\n");
       menuItem -label $textureNodeItems;
     }
     $i = $i+1;
  }
  
  optionMenuGrp 
    -edit
    -select 1
    menuTextPresetSelect;
}


//Reload an old DomeText message from the selected texture node
 global proc restoreDomeTextPreset( string $nodeName ){
 
  //Skip processing the popup menu caption text
  if($nodeName == "Select a DomeText Node...") return;

  //Make sure the node exists before working with it
  if(`objExists $nodeName`){
    print("Restoring editable DomeText from: " + $nodeName + "\n");
    
    //Find out if the current node is a maya or mental ray texture
    string $textureNodeType = `nodeType($nodeName)`;
    if( $textureNodeType == "file"){
      //Maya file texture
      optionMenuGrp -edit -select 1 menuTextureFormat;
    } else if ($textureNodeType == "mentalrayTexture"){
      //Mental Ray File Texture
      optionMenuGrp -edit -select 2 menuTextureFormat;
    }
    
    //Restore the note message
    if (`attributeExists "nts" $nodeName`) {
      print "The note attribute exists.\n";
      //Read the textual note from the texture node
      //string $domeTextString = getAttr "file1.nts";
      string $domeTextString = getAttr ($nodeName+".nts");
      //Write the value back to the Dome Text window's text field
      scrollField -edit -text $domeTextString scrollTextString;
      print("Note: " +  $domeTextString + "\n");
    } else {
      print "The note attribute does not exist.\n";
    } //end check if nts attr exists
    
    //Restore the file name field
    string $currentFileName = getAttr ($nodeName+".fileTextureName");
    textFieldGrp -edit -text $currentFileName textImageOutputName;
    
   //Restore Imagemagick custom text field
    if (`attributeExists "imagemagickCustomText" $nodeName`){
      print "The imagemagickCustomText attribute exists.\n";
      string $imagemagickCustomText = getAttr ($nodeName+".imagemagickCustomText");
      scrollField -edit -text $imagemagickCustomText scrollImagemagickCustomText;
    } else {
      print "The imagemagickCustomText attribute does not exist.\n";
    } //end check if imagemagickCustomText attr exists
    
    //Restore foreground and background color swatches
    if (`attributeExists "foregroundColor" $nodeName` && `attributeExists "backgroundColor" $nodeName`) {
      print "The FG & BG color attributes exist.\n";
      //Restore the color swatches from the node's extra attributes
      float $foregroundRGBcolor[3] = `getAttr ($nodeName+".foregroundColor")`;
      float $backgroundRGBcolor[3] = `getAttr ($nodeName+".backgroundColor")`; 
      colorSliderGrp -edit -rgb $foregroundRGBcolor[0] $foregroundRGBcolor[1] $foregroundRGBcolor[2] sliderForeColor;
      colorSliderGrp -edit -rgb $backgroundRGBcolor[0] $backgroundRGBcolor[1] $backgroundRGBcolor[2] sliderBackColor;
    } else {
      print "The FG & BG color attributes do not exist.\n";
    } //end check if fg & bg attr exists
    
    //Restore the background transparent checkBoxGrp
    if (`attributeExists "isBgTransparent" $nodeName`){
      print "The background transparency attribute exists.\n";
      int $isbackgroundTransparent = getAttr ($nodeName+".isBgTransparent");
      checkBoxGrp -edit -value1 $isbackgroundTransparent checkGrpTransparentBackground;
    } else {
      print "The background transparency attribute does not exist.\n";
    } //end check if background transparency attr exists
    
     //Restore the font name
    if (`attributeExists "font" $nodeName`){
      print "The font name attribute exists.\n";
      string $fontName = getAttr ($nodeName+".font");
      optionMenuGrp -edit -value $fontName menuFontNameSelect;
    } else {
      print "The font name attribute does not exist.\n";
    } //end check if font name attr exists
    
     //Restore the encoding name
     if (`attributeExists "textEncoding" $nodeName`){
      print "The text encoding attribute exists.\n";
      string $fontName = getAttr ($nodeName+".textEncoding");
      optionMenuGrp -edit -value $fontName menuTextEncodingSelect;
    } else {
      print "The text encoding attribute does not exist.\n";
    } //end check if the text encoding name attr exists
    
     //Restore the font style
     if (`attributeExists "fontStyle" $nodeName`){
      print "The font style attribute exists.\n";
      int $fontStyle = 1+ getAttr ($nodeName+".fontStyle");
      optionMenuGrp -edit -select $fontStyle menuFontWeightSelect;
    } else {
      print "The font style attribute does not exist.\n";
    } //end check if font style attr exists
    
     //Restore the font alignment
     if (`attributeExists "alignment" $nodeName`){
      print "The alignment attribute exists.\n";
      int $fontAlign = 1+ getAttr ($nodeName+".alignment");
      optionMenuGrp -edit -select $fontAlign menuFontAlignSelect;
    } else {
      print "The alignment attribute does not exist.\n";
    } //end check if alignment attr exists
    
     //Restore the alignTextCamera text
     if (`attributeExists "alignTextCamera" $nodeName`){
      print "The alignTextCamera attribute exists.\n";
      string $CameraName = getAttr ($nodeName+".alignTextCamera");
      optionMenuGrp -edit -value $CameraName menuDomeTextCameraSelect;
    } else {
      print "The align Text Camera attribute does not exist.\n";
    } //end check if the alignTextCamera name attr exists
     
     //Restore the Convert Characters
     if (`attributeExists "convertCharacters" $nodeName`){
      print "The Convert Characters attribute exists.\n";
      int $convertCharacters = 1+ getAttr ($nodeName+".convertCharacters");
      optionMenuGrp -edit -select $convertCharacters menuConvertCharacters;
    } else {
      print "The alignment attribute does not exist.\n";
    } //end check if convertCharacters attr exists   
        
    //Restore the Scroll Direction
    if (`attributeExists "scrollDirection" $nodeName`){
      print "The scrollDirection attribute exists.\n";
      int $scrollDirectionInt = 1+ getAttr ($nodeName+".scrollDirection");
      optionMenuGrp -edit -select $scrollDirectionInt menuAutoScrollDirectionSelect;
    } else {
      print "The scrollDirection attribute does not exist.\n";
    } //end check if scrollDirection attr exists
    
    //Restore the animationStartFrame
    if (`attributeExists "animationStartFrame" $nodeName`){
      print "The animationStartFrame attribute exists.\n";
      int $animationStartFrame = getAttr ($nodeName+".animationStartFrame");
      intFieldGrp -edit -value1 $animationStartFrame intAnimationStartFrame;
    } else {
      print "The animationStartFrame attribute does not exist.\n";
    } //end check if animationStartFrame attr exists
    
    //Restore the animationEndFrame
    if (`attributeExists "animationEndFrame" $nodeName`){
      print "The animationEndFrame attribute exists.\n";
      int $animationEndFrame = getAttr ($nodeName+".animationEndFrame");
      intFieldGrp -edit -value1 $animationEndFrame intAnimationEndFrame;
    } else {
      print "The animationEndFrame attribute does not exist.\n";
    } //end check if animationEndFrame attr exists
    
    //Restore the looping checkBoxGrp
    if (`attributeExists "loopAnimation" $nodeName`){
      print "TheloopAnimation attribute exists.\n";
      int $isLoopAnimation = getAttr ($nodeName+".loopAnimation");
      checkBoxGrp -edit -value1 $isLoopAnimation checkGrpLoopAnimation;
    } else {
      print "The loopAnimation attribute does not exist.\n";
    } //end check if LoopAnimation attr exists
   
    //Restore the mirrorText checkBoxGrp
    if (`attributeExists "mirrorText" $nodeName`){
      print "mirrorText attribute exists.\n";
      int $isMirroredText = getAttr ($nodeName+".mirrorText");
      checkBoxGrp -edit -value1 $isMirroredText checkGrpMirrorText;
    } else {
      print "The mirrorText attribute does not exist.\n";
    } //end check if mirrorText attr exists
   
    //Restore the textWrapU checkBoxGrp
    if (`attributeExists "textWrapU" $nodeName`){
      print "textWrapU attribute exists.\n";
      int $wrapU = getAttr ($nodeName+".textWrapU");
      checkBoxGrp -edit -value1 $wrapU checkGrpWrapText;
    } else {
      print "The textWrapU attribute does not exist.\n";
    } //end check if textWrapU attr exists
   
    //Restore the textWrapV checkBoxGrp
    if (`attributeExists "textWrapV" $nodeName`){
      print "textWrapV attribute exists.\n";
      int $wrapV = getAttr ($nodeName+".textWrapV");
      checkBoxGrp -edit -value2 $wrapV checkGrpWrapText;
    } else {
      print "The textWrapV attribute does not exist.\n";
    } //end check if textWrapV attr exists

    //Restore the font size
    if (`attributeExists "fontSize" $nodeName`){
      print "The font size attribute exists.\n";
      int $fontSize = getAttr ($nodeName+".fontSize");
      intSliderGrp -edit -value $fontSize sliderPointSize;
    } else {
      print "The font size attribute does not exist.\n";
    } //end check if font size attr exists
    
    //Restore the kerning size
    if (`attributeExists "kerningSize" $nodeName`){
      print "The kerningSize attribute exists.\n";
      float $kerningSize = getAttr ($nodeName+".kerningSize");
      floatSliderGrp -edit -value $kerningSize sliderKerningSize;
    } else {
      print "The kerningSize attribute does not exist.\n";
    } //end check if kerningSize attr exists
       
    //Restore the image size
    if (`attributeExists "width" $nodeName`){
      print "The image width attribute exists.\n";
      int $imageWidth = 1+ getAttr ($nodeName+".width");
      optionMenuGrp -edit -select $imageWidth menuImageWidthSelect;
    } else {
      print "The image width attribute does not exist.\n";
    } //end check if image width attr exists
       
    if (`attributeExists "height" $nodeName`){
      print "The image height attribute exists.\n";
      //Restore the image height state
      int $imageheight = 1+ getAttr ($nodeName+".height");
      optionMenuGrp -edit -select $imageheight menuImageHeightSelect;
    } else {
      print "The image height attribute does not exist.\n";
    } //end check if image height attr exists   
    
    //Restore the texture format settings
    if (`attributeExists "textureFormat" $nodeName`){
      print "The texture format attribute exists.\n";
      int $textureFormat = 1+ getAttr ($nodeName+".textureFormat");
      optionMenuGrp -edit -select $textureFormat menuTextureFormat;
    } else {
      print "The texture format attribute does not exist.\n";
    } //end check if texture format attr exists
    
    // //Restore the surface node settings
    // if (`attributeExists "surfaceNode" $nodeName`){
      // print "The surface node attribute exists.\n";
      // int $surfaceMaterialFormat = 1+ getAttr ($nodeName+".surfaceNode");
      // optionMenuGrp -edit -select $surfaceMaterialFormat menuSurfaceMaterialFormat;
    // } else {
      // print "The surface node attribute does not exist.\n";
    // } //end check if surface node attr exists
       
    //Restore the supporting shape settings
    if (`attributeExists "shapeFormat" $nodeName`){
      print "The supporting shape attribute exists.\n";
      int $shapeFormat = 1+ getAttr ($nodeName+".shapeFormat");
      optionMenuGrp -edit -select $shapeFormat menuShapeFormat;
    } else {
      print "The supporting shape attribute does not exist.\n";
    } //end check if the supporting shape attr exists  
    
    //Restore the orientationAxis settings
    if (`attributeExists "orientationAxis" $nodeName`){
      print "The orientationAxis attribute exists.\n";
      int $planeDirection = 1+ getAttr ($nodeName+".orientationAxis");
      optionMenuGrp -edit -select $planeDirection menuDomeOrientationAxis;
    } else {
      print "The orientationAxis attribute does not exist.\n";
    } //end check if the orientationAxis attr exists  
    
    
    
  } else {
    print ("Texture Node Not found");
  }  //end check if node exists
}



//Rebuild the cameras option menu
global proc buildDomeTextCamerasMenu(){
  if(`optionMenuGrp -exists menuDomeTextCameraSelect`){
    //print("Removing the existing cameras menu.\n");
    deleteUI menuDomeTextCameraSelect;
  } else {
    //print("Create the Camera menu.\n");
  }

  // Create the Camera list options menu 
  optionMenuGrp
    -label "Align Text to Camera"
    -columnAlign 1 "right"
    -annotation "Point the DomeText surface towards a camera using an aim constraint."
    -parent domeTextCameraLayout
     menuDomeTextCameraSelect;

  menuItem -label "Select a Camera...";

  //List all of the camera nodes
  string $cameraNodeList[] = `lsType("camera")`;
  string $cameraNodeItems = "";
  
  //Sort the camera node names alphabetically
  $cameraNodeList = sort($cameraNodeList);
  
  //print ("Nodes:\n");
  //print ($cameraNodeList);
    
  int $i = 0; //track the total number of camera nodes
  
  //Scan camera File Texture Nodes
  for ( $cameraNodeItems in $cameraNodeList )
  {
     // Look for the last item <done> in the array
     if ( $cameraNodeItems != "<done>" ){
       //print ( "camera [" + $i + "] " + $cameraNodeItems + "\n");
       //menuItem -label $cameraNodeItems;
       //List the camera's using the base transform node name
       menuItem -label `getObjectParentNode($cameraNodeItems)`;
     }
     $i = $i+1;
  }

  optionMenuGrp 
    -edit
    -select 1
    menuDomeTextCameraSelect;
}


//Create a supporting Polygon Plane Surface
global proc string createDomePlane(){
  //image Size
  float $imageWidth = `optionMenuGrp -query -value menuImageWidthSelect`;
  int $imageMode =`optionMenuGrp -query -select menuImageHeightSelect`-1;
  float $imageHeight = 0.0;
  
  float $polygonHeight = `floatSliderGrp -query -value sliderShapeHeightSize`;
  float $polygonWidth = 0;
  
  //Check if the (auto) mode was enabled
  if ( $imageMode ){
    $imageHeight  = `optionMenuGrp -query -value menuImageHeightSelect`;
  } else {
    print("Automatic image height setting detected. Using a preset 1:1 aspect ratio setting.\n");
    $imageHeight  = $imageWidth;
  }
  
  //Calculate the image aspect ratio
  float $imageAspectRatio = $imageWidth / $imageHeight ;
  print("Image Aspect ratio: " + $imageAspectRatio + ":1\n");
  //Image Dimensions
  print("Image Size: " + $imageWidth + "x" + $imageHeight + "\n");
  //Calculate the polygon size based upon the aspect Ratio
  $polygonWidth = $polygonHeight * $imageAspectRatio;
  print("Polygon Size: " + $polygonWidth + "x" + $polygonHeight + "\n");
  
  // Set up the polygon plane direction
  //"enum" -en "Right (X):Top (Y):Front (Z):" $nodeName;
  //Creation Axis: Right (X):Top (Y): Front (Z)
  
  int $planeDirection = `optionMenuGrp -query -select menuDomeOrientationAxis`-1;

  //int $planeDirection = 1;
  int $planeCreationAxis[3] = {0,0,0};
  
  if ( $planeDirection == 0 ){
    //Right (X)
    $planeCreationAxis = {1,0,0};
  } else if ( $planeDirection == 1 ){
    //Top (Y)
    $planeCreationAxis = {0,1,0};
  }else if ( $planeDirection == 2 ){
    //Front (Z)
    $planeCreationAxis = {0,0,1};
  }
  
  //Create a polygon plane for the text card
  string $domeTextPlane[] = `polyPlane -w 1 -h 1 -sx 1 -sy 1 -ax $planeCreationAxis[0] $planeCreationAxis[1] $planeCreationAxis[2]-cuv 2 -ch 1 -name "DomeTextPlane"`;
  
  //Resize the correct dimension
  if ( $planeDirection == 0 ){
    //Right (X)
    //Resize the polygon plane
    setAttr ($domeTextPlane[0]+".scaleZ") $polygonWidth;
    setAttr ($domeTextPlane[0]+".scaleY") $polygonHeight;
  } else if ( $planeDirection == 1 ){
    //Top (Y)
    //Resize the polygon plane
    setAttr ($domeTextPlane[0]+".scaleX") $polygonWidth;
    setAttr ($domeTextPlane[0]+".scaleZ") $polygonHeight;
  }else if ( $planeDirection == 2 ){
    //Front (Z)
    //Resize the polygon plane
    setAttr ($domeTextPlane[0]+".scaleX") $polygonWidth;
    setAttr ($domeTextPlane[0]+".scaleY") $polygonHeight;
  }

  return $domeTextPlane[0];
}


//Create a supporting NURBS Cylinder Surface
global proc string createDomeCylinder(){
  //image Size
  float $imageWidth = `optionMenuGrp -query -value menuImageWidthSelect`;
  int $imageMode =`optionMenuGrp -query -select menuImageHeightSelect`-1;
  float $imageHeight = 0.0;
  
  float $cylinderHeight = `floatSliderGrp -query -value sliderShapeHeightSize`;
  float $cylinderWidth = 0;
  
  //Check if the (auto) mode was enabled
  if ( $imageMode ){
    $imageHeight  = `optionMenuGrp -query -value menuImageHeightSelect`;
  } else {
    print("Automatic image height setting detected. Using a preset 1:1 aspect ratio setting.\n");
    $imageHeight  = $imageWidth;
  }
  
  //Calculate the image aspect ratio
  float $imageAspectRatio = $imageWidth / $imageHeight ;
  print("Image Aspect ratio: " + $imageAspectRatio + ":1\n");
  //Image Dimensions
  print("Image Size: " + $imageWidth + "x" + $imageHeight + "\n");

  //Calculate the cylinder radius based upon the height
  float $cylinderRadius = (($imageAspectRatio*$cylinderHeight)/3.14)/2;
  
  //Calculate height ratio as circumference = 3.14 * diameter
  //float $heightRatio = 1; 
  float $heightRatio = $cylinderHeight/$cylinderRadius;

  print("Cylinder Size: " + $cylinderHeight + "x" + ($cylinderRadius*2) + "\n");
  
  //float $adjustedRadius = polygonHeight / $heightRatio;
  
  // Set up the NURBS Cylinder direction
  //"enum" -en "Right (X):Top (Y):Front (Z):" $nodeName;
  //Creation Axis: Right (X):Top (Y): Front (Z)
  
  int $cylinderDirection = `optionMenuGrp -query -select menuDomeOrientationAxis`-1;

  //int $cylinderDirection = 1;
  int $cylinderCreationAxis[3] = {0,0,0};
  
  if ( $cylinderDirection == 0 ){
    //Right (X)
    $cylinderCreationAxis = {0,1,0};
  } else if ( $cylinderDirection == 1 ){
    //Top (Y)
    $cylinderCreationAxis = {0,0,1};
  }else if ( $cylinderDirection == 2 ){
    //Front (Z)
    $cylinderCreationAxis = {0,1,0};
  }
  
  //Create a NURBS Cylinder for the text card //default -heightRatio 2
  string $domeTextCylinder[] = `cylinder -pivot 0 0 0 -axis $cylinderCreationAxis[0] $cylinderCreationAxis[1] $cylinderCreationAxis[2] -startSweep 0 -endSweep 360 -radius $cylinderRadius -heightRatio $heightRatio -degree 3 -useTolerance 0 -tolerance 0.01 -sections 8 -spans 1 -constructionHistory 1 -name "DomeTextCylinder"`;
  
  //Resize the correct dimension
  if ( $cylinderDirection == 0 ){
    //Right (X)
    //Resize the NURBS Cylinder
    //setAttr ($domeTextCylinder[0]+".scaleX") $polygonWidth;
    //setAttr ($domeTextCylinder[0]+".scaleZ") $polygonWidth;
    //setAttr ($domeTextCylinder[0]+".scaleY") $polygonHeight;
  } else if ( $cylinderDirection == 1 ){
    //Top (Y)
    //Resize the NURBS Cylinder
    //setAttr ($domeTextCylinder[0]+".scaleX") $polygonWidth;
    //setAttr ($domeTextCylinder[0]+".scaleY") $polygonWidth;
    //setAttr ($domeTextCylinder[0]+".scaleZ") $polygonHeight;

  }else if ( $cylinderDirection == 2 ){
    //Front (Z)
    //Resize the NURBS Cylinder
    //setAttr ($domeTextCylinder[0]+".scaleX") $polygonWidth;
    //setAttr ($domeTextCylinder[0]+".scaleZ") $polygonWidth;
    //setAttr ($domeTextCylinder[0]+".scaleY") $polygonHeight;
  }

  return $domeTextCylinder[0];
}


global proc domeText(){
  global int $domeWindowHeight = 625;
  global int $domeWindowWidth = 584;
  
  
  //old window width = 500

  //-------------------------------------------------
  //Get the current Maya Platform using python
  //      The $mayaPlatform options are:
  //          "windows", "darwin", "linux"
  //-------------------------------------------------

   //Check the operating system
  string $mayaPlatform = getMayaPlatform();

  // Check if we are running Maya 2011 or higher
  float $mayaVersion = getMayaVersionDome();

  // Write out the current Maya version number and detected operating system
  print("Maya " + $mayaVersion + " on " + $mayaPlatform  + " detected.\n");

  if ($mayaVersion >=2011){
  // Remove an existing docked control window when running the DomeText tool for a 2nd time.
    if (`dockControl -exists domeTextDockControl`){ 
      deleteUI -control domeTextDockControl; 
      print( "Removing an existing docked Dome Text Window\n");}

  if (`window -exists domeTextWin`){
      deleteUI domeTextWin;
      windowPref -remove domeTextWin;
      print("Reloading the Dome Text window elements\n");}
  }else{
    // You are running Maya 2010 or lower - skip the dockcontrols
    // Remove an existing window when running the DomeText tool for a 2nd time.
    if (`window -exists domeTextWin`){
      deleteUI domeTextWin;
      windowPref -remove domeTextWin;
      print("Reloading the Dome Text window elements\n");}
  }

  string $domeTextWindow = `window 
    -title "Dome Text Tool" 
    //-width $domeWindowWidth
    -widthHeight $domeWindowWidth $domeWindowHeight 
    domeTextWin`; 
 
  string $domeScrollableLayout = `scrollLayout 
    -horizontalScrollBarThickness 18
    -verticalScrollBarThickness   18
    -childResizable 1
    //-width $domeWindowWidth
    `;

    columnLayout 
      //-width ($domeWindowWidth-30)
      //-width $domeWindowWidth
      -adjustableColumn true
      textPresetLayout;
      
      //Create the Text Presets Option Menu
      buildTextPresetMenu();
      
    setParent ..;
    
  frameLayout 
    -label "Text Entry"
    -collapsable true
    -collapse false
    -borderStyle "etchedIn";
    
    columnLayout 
      //-width $domeWindowWidth
      -adjustableColumn true;

      scrollField 
        -wordWrap true 
        //-width $domeWindowWidth       
        -annotation "Enter your message in the text field."
        -text "Hello Dome World!"
        
        //-text "" scrollTextString;
        //-text "Ext. Moon - Night                \n\nTwo astronauts are driving across the lunar surface on a moon buggy.\n\nMacGee\n(laughing)\nWhy do they even pay us to work?\n\nConrad\n(frankly)\nBecause ground control is scared shitless..." scrollTextString;
        //-text "Ext. Moon - Night                1\n\nTwo astronauts are driving across the lunar surface on a moon buggy.\n\nMacGee\n(laughing)\nWhy do they even pay us to work?\n\nConrad\n(frankly)\nBecause ground control is scared shitless...\n\nThe moon buggy comes to an abrupt stop infront of a large abandoned quonset hut structure. The roof shows signs of meteor damage and there is debris strew around the entrance." 

        scrollTextString;
      
    setParent ..;
  setParent ..;

  frameLayout
    -label "Font Styles"
    -collapsable true
    -collapse false
    -borderStyle "etchedIn";
    
    columnLayout
      //-width ($domeWindowWidth-30)
      //-width $domeWindowWidth
      //-adjustableColumn true
      ;
      
      // Create the Font Selector Pop-up Menu  
      optionMenuGrp
        -label "Font"
        -columnAlign 1 "right"
        -annotation 
        "Choose a font name to change the appearance of the generated text. The installed fonts \nare listed by scanning the operating system's font folder paths."
        menuFontNameSelect;

      //Scan the system for installed fonts
      string $fontFolderPath;
      string $installedFonts[];
              
      if ($mayaPlatform  == "windows"){
        //Windows 32/x64
        // Font Folders: C:/Windows/Fonts/
        
        $fontFolderPath = "C:\\Windows\\Fonts\\";     
        $installedFonts = `getFileList -folder $fontFolderPath`;
        
      }else if ($mayaPlatform  == "darwin"){
        //Mac OS X
        //Font Folders: /System/Library/Fonts/:/Library/Fonts/:~/Library/Fonts/";

        $fontFolderPath = "/Library/Fonts/";
        string $fontFolderPath2 = "/System/Library/Fonts/";

        //Build the user fonts folder path
        //string $fontFolderPath3 = "~/Library/Fonts/";
        string $macHomePath = `getenv "HOME"`;
				string $fontFolderPath3 = $macHomePath + "/Library/Fonts/";
				
        //Scan the three mac font locations for files
        string $fontTemp1[] = `getFileList -folder $fontFolderPath`;
        string $fontTemp2[] = `getFileList -folder $fontFolderPath2`;
        string $fontTemp3[] = `getFileList -folder $fontFolderPath3`;
        
        //Add the folder path as a prefix to each of the array items
			  stringArrayAddPrefix( $fontTemp1, ($fontFolderPath) );
        stringArrayAddPrefix( $fontTemp2, ($fontFolderPath2) );
        stringArrayAddPrefix( $fontTemp3, ($fontFolderPath3) );
        
        //Merge the list of installed fonts
        //$installedFonts = stringArrayCatenate($fontTemp1, $fontTemp2);
        //$installedFonts = stringArrayCatenate($installedFonts, $fontTemp3);
        
        $installedFonts = stringArrayCatenate($fontTemp3, $fontTemp1 );
        $installedFonts = stringArrayCatenate($installedFonts, $fontTemp2);
        
      }else {  
        //Linux
        //Font Folders: /usr/share/fonts/
				//  
        //$fontFolderPath = "/usr/share/fonts/";
        //$fontFolderPath = "/usr/share/fonts/dejavu/";
        //$installedFonts = `getFileList -folder $fontFolderPath`;
        
        //Location of the Linux Font folders:
        $fontFolderPath = "/usr/share/fonts/";

				//Scan the first level of folders:
        string $installedFontFolders[] = `getFileList -folder $fontFolderPath`; 
        string $installedFontsSubFolders;
        string $installedFontsSubSubFolders;

        //List of all the fonts
        string $fontTemp1[];

				//Scan the second level of folders:	
        for ( $installedFontsSubFolders in $installedFontFolders ) {
          $fontTemp1 = `getFileList -folder ($fontFolderPath+$installedFontsSubFolders+"/") `;
          //-filespec "*.ttf"
					//Add the folder path as a prefix to each of the array items
					stringArrayAddPrefix( $fontTemp1, ($fontFolderPath+$installedFontsSubFolders+"/") );
          $installedFonts = stringArrayCatenate($installedFonts, $fontTemp1);
        }

				//Scan the third level of folders:	
        for ( $installedFontsSubSubFolders in $installedFonts ) {
          $fontTemp1 = `getFileList -folder ($installedFontsSubSubFolders+"/") `;
          //-filespec "*.ttf"
					//Add the folder path as a prefix to each of the array items
					stringArrayAddPrefix( $fontTemp1, ($installedFontsSubSubFolders+"/") );
          $installedFonts = stringArrayCatenate($installedFonts, $fontTemp1);
        }
 
				//Sort the list of fonts
			  $installedFonts = sort($installedFonts);
    
      }
      
      //print("Installed Fonts: \n");
      //print $installedFonts;
      //print("End of the installed fonts list\n");

      int $i_count = 0; //track the total number of included fonts
      string $installedFontsItems;
      
      //Scan the font array list
      for ( $installedFontsItems in $installedFonts )
      {
        menuItem -label $installedFontsItems;
        $i_count = $i_count+1;
      }
      
      //optionMenuGrp -edit
      //  -select 1
      // menuFontNameSelect;
      
      //Preselect Arial in font name options menu 
      string $fontFilenameString = "";
      string $defaultfontName = "";
      
      if ($mayaPlatform  == "windows"){
        //Windows 32/x64
        $defaultfontName = "arial.ttf";
        $fontFilenameString = $fontFolderPath + $defaultfontName;
      }else if ($mayaPlatform  == "darwin"){
        //Mac OS X
        //$defaultfontName = "Arial.ttf";
        $defaultfontName = "/Library/Fonts/Arial.ttf";
        $fontFilenameString = $defaultfontName;
      }else {  
        //Linux
        $defaultfontName = "/usr/share/fonts/dejavu/DejaVuSans.ttf";
        $fontFilenameString = $defaultfontName;
      }
        
       
      
      //Check if the font exists
      if (`filetest -f $fontFilenameString`){
        print("Setting " + $fontFilenameString + " as the default font.\n");
        optionMenuGrp -edit -value $defaultfontName menuFontNameSelect;
      }else{
        print("The default font " + $fontFilenameString + " does not exist.\n");
      } 
      

      // Create the Text Encoding Pop-up Menu  
      // Font Style options: "English ascii", "Chinese big5", "Hong Kong Supplementary Character Set big5hkscs"
      optionMenuGrp
        -label "Text Encoding"
        -columnAlign 1 "right"
        -annotation "The \"Text Encoding\" controls the conversion of international character sets to UTF8 text."
        menuTextEncodingSelect;

      menuItem -label "Windows Default - Western Europe windows-1252";
      menuItem -label "English ascii";
      menuItem -label "Traditional Chinese big5";
      menuItem -label "Traditional Chinese big5hkscs";
      menuItem -label "English cp037";
      menuItem -label "Hebrew cp424";
      menuItem -label "English cp437";
      menuItem -label "Western Europe cp500";
      menuItem -label "Arabic cp720";
      menuItem -label "Greek cp737";
      menuItem -label "Baltic languages cp775";
      menuItem -label "Western Europe cp850";
      menuItem -label "Central and Eastern Europe cp852";
      menuItem -label "Bulgarian, Byelorussian, Macedonian, Russian, Serbian cp855";
      menuItem -label "Hebrew cp856";
      menuItem -label "Turkish cp857";
      menuItem -label "Western Europe cp858";
      menuItem -label "Portuguese cp860";
      menuItem -label "Icelandic cp861";
      menuItem -label "Hebrew cp862";
      menuItem -label "Canadian cp863";
      menuItem -label "Arabic cp864";
      menuItem -label "Danish, Norwegian cp865";
      menuItem -label "Russian cp866";
      menuItem -label "Greek cp869";
      menuItem -label "Thai cp874";
      menuItem -label "Greek cp875";
      menuItem -label "Japanese cp932";
      menuItem -label "Korean cp949";
      menuItem -label "Traditional Chinese cp950";
      menuItem -label "Urdu cp1006";
      menuItem -label "Turkish cp1026";
      menuItem -label "Western Europe cp1140";
      menuItem -label "Central and Eastern Europe cp1250";
      menuItem -label "Bulgarian, Byelorussian, Macedonian, Russian, Serbian cp1251";
      menuItem -label "Western Europe cp1252";
      menuItem -label "Greek cp1253";
      menuItem -label "Turkish cp1254";
      menuItem -label "Hebrew cp1255";
      menuItem -label "Arabic cp1256";
      menuItem -label "Baltic languages cp1257";
      menuItem -label "Vietnamese cp1258";
      menuItem -label "Japanese euc_jp";
      menuItem -label "Japanese euc_jis_2004";
      menuItem -label "Japanese euc_jisx0213";
      menuItem -label "Korean euc_kr";
      menuItem -label "Simplified Chinese gb2312";
      menuItem -label "Unified Chinese gbk";
      menuItem -label "Unified Chinese gb18030";
      menuItem -label "Simplified Chinese hz";
      menuItem -label "Japanese iso2022_jp";
      menuItem -label "Japanese iso2022_jp_1";
      menuItem -label "Japanese, Korean, Simplified Chinese, Western Europe, Greek iso2022_jp_2";
      menuItem -label "Japanese iso2022_jp_2004";
      menuItem -label "Japanese iso2022_jp_3";
      menuItem -label "Japanese iso2022_jp_ext";
      menuItem -label "Korean iso2022_kr";
      menuItem -label "West Europe latin_1";
      menuItem -label "Central and Eastern Europe iso8859_2";
      menuItem -label "Esperanto, Maltese iso8859_3";
      menuItem -label "Baltic languages iso8859_4";
      menuItem -label "Bulgarian, Byelorussian, Macedonian, Russian, Serbian iso8859_5";
      menuItem -label "Arabic iso8859_6";
      menuItem -label "Greek iso8859_7";
      menuItem -label "Hebrew iso8859_8";
      menuItem -label "Turkish iso8859_9";
      menuItem -label "Nordic languages iso8859_10";
      menuItem -label "Baltic languages iso8859_13";
      menuItem -label "Celtic languages iso8859_14";
      menuItem -label "Western Europe iso8859_15";
      menuItem -label "South-Eastern Europe iso8859_16";
      menuItem -label "Korean johab";
      menuItem -label "Russian koi8_r";
      menuItem -label "Ukrainian koi8_u";
      menuItem -label "Bulgarian, Byelorussian, Macedonian, Russian, Serbian mac_cyrillic";
      menuItem -label "Greek mac_greek";
      menuItem -label "Icelandic mac_iceland";
      menuItem -label "Central and Eastern Europe mac_latin2";
      menuItem -label "Western Europe mac_roman";
      menuItem -label "Turkish mac_turkish";
      menuItem -label "Kazakh ptcp154";
      menuItem -label "Japanese shift_jis";
      menuItem -label "Japanese shift_jis_2004";
      menuItem -label "Japanese shift_jisx0213";
      menuItem -label "all languages utf_32";
      menuItem -label "all languages utf_32_be";
      menuItem -label "all languages utf_32_le";
      menuItem -label "all languages utf_16";
      menuItem -label "all languages (BMP only) utf_16_be";
      menuItem -label "all languages (BMP only) utf_16_le";
      menuItem -label "all languages utf_7";
      menuItem -label "all languages utf_8";
      menuItem -label "all languages utf_8_sig";

      //Preselect the first pop-up menu option
      optionMenuGrp 
        -edit
        -select 1
        menuTextEncodingSelect;
      
      // Create the Font Style Selector Pop-up Menu  
      // Font Style options: ALL, Bold, Bolder, Lighter, Normal
      optionMenuGrp
        -label "Font Style"
        -columnAlign 1 "right"
        -annotation "The \"Font Style\" controls can make a font appear thicker, or thinner."
        menuFontWeightSelect;

      menuItem -label "ALL";
      menuItem -label "Bold";
      menuItem -label "Bolder";
      menuItem -label "Lighter";
      menuItem -label "Normal";

      //Preselect the "ALL" pop-up menu option
      optionMenuGrp 
        -edit
        -select 1
        menuFontWeightSelect;

      optionMenuGrp
        -label "Alignment"
        -columnAlign 1 "right"
        -annotation "\"Alignment\" controls the position of the text in the image using a compass direction. \nCenter alignment will place the text in the middle of the image. North places the text at \nthe top of the image, and South places the text at the bottom. If you change the image \nheight from (auto) to a specific size you will notice the vertical alignment controls have \nmore effect."
        menuFontAlignSelect;
    
      menuItem -label "NorthWest";
      menuItem -label "North";
      menuItem -label "NorthEast";
      menuItem -label "West";
      menuItem -label "Center"; 
      menuItem -label "East";
      menuItem -label "SouthWest";
      menuItem -label "South";
      menuItem -label "SouthEast";

      optionMenuGrp 
        -edit
        -select 5
        menuFontAlignSelect;
        
       optionMenuGrp
        -label "Convert Characters to"
        -columnAlign 1 "right"
        -annotation "Change the text to UPPER CASE, lower case, hex ( 6e 65 61 74 ), or binary (01100010) formats."
        menuConvertCharacters;

      menuItem -label "Normal Case";
      menuItem -label "Upper Case";
      menuItem -label "Lower Case";
      menuItem -label "Hex Words";
      menuItem -label "Hex Single Column";
      menuItem -label "Binary Words";
      menuItem -label "Binary Single Column";

      //Preselect the normal pop-up menu option
      optionMenuGrp
        -edit
        -select 1
        menuConvertCharacters;   
     
      intSliderGrp 
        -label "Font Size" 
        //-extraLabel "Points" 
        //-columnWidth 2 90
        -field true
        -minValue 6 -maxValue 2048
        -fieldMinValue 6 -fieldMaxValue 2048
        -value 96 
        -annotation "Choose a font size in points. In digital typography 72 points = 1 inch."
        sliderPointSize;
          
      floatSliderGrp 
        -label "Kerning" 
        //-extraLabel "Points" 
        //-columnWidth 2 90
        -field true
        -minValue -1024 -maxValue 2048
        -fieldMinValue -1024  -fieldMaxValue 2048
        -value 0
        -annotation "Choose a kerning value in points. In digital typography 72 points = 1 inch."
        sliderKerningSize;
        
      setParent ..;
    setParent ..;
  setParent ..;

  frameLayout 
    -label "Color Styles"
    -collapsable true
    -collapse false
    -borderStyle "etchedIn";
    
  columnLayout 
    //-width $domeWindowWidth
    -adjustableColumn true ;

    //Color Pickers
    //To convert from a 0-255 to 0-1 Color = value*0.003921568627451

    colorSliderGrp 
      -label "Foreground Color" 
      -rgb 0.968 0.76 0.07 
      -annotation "Choose a foreground color for the Dome Text."
      sliderForeColor;

    colorSliderGrp 
      -label "Background Color" 
      -rgb 0.0 0.0 0.0 
      -annotation "Choose a background color for the Dome Text."
      sliderBackColor;
   
    checkBoxGrp
      -numberOfCheckBoxes 1
      -label "Transparent Background"  
      -value1 1
      -annotation "Render the foreground Dome Text over a transparent background."
      checkGrpTransparentBackground;
      
    setParent ..;
  setParent ..;

  frameLayout 
    -label "Image Controls"
    -collapsable true
    -collapse true
    -borderStyle "etchedIn";
    
    columnLayout 
      //-width $domeWindowWidth
      -adjustableColumn true;

      //Check the platform to come up with the correct source images folder

      //Read the current "sourceimages" directory from the workspace (set project) settings
      string $defaultSourceImages = `workspace -expandName "sourceimages"`;
      
      //Copy the current date and time in the format 2013-10-10_10.47.07
      string $currentDateTime = `date -format "YYYY-MM-DD_hh.mm.ss"`;
      
      //The image name without a leading slash
      string $imageFilename = "text_string_" + $currentDateTime + ".png";

      //The path to the image directory with a trailing slash
      string $imageFilePath = "";

      if ($mayaPlatform  == "windows"){
        //Windows 32/x64
        //$imageFilePath = "%USERPROFILE%\\My Documents\\maya\\projects\\default\\sourceimages\\"+ $imageFilename;
        //$imageFilePath = "C:\\"+ $imageFilename;
        $imageFilePath = $defaultSourceImages + "/" + $imageFilename;
      }else if ($mayaPlatform  == "darwin"){
        //Mac OS X
        //$imageFilePath = "~/Documents/maya/projects/default/sourceimages/" + $imageFilename;
        $imageFilePath = $defaultSourceImages + "/" + $imageFilename;
      }else {  
        //Linux
        //$imageFilePath = "~/Documents/maya/projects/default/sourceimages/" + $imageFilename;
        $imageFilePath = $defaultSourceImages + "/" + $imageFilename;
      }
      
      rowLayout 
        -numberOfColumns 2
        -adjustableColumn2 1
        imageSaveAsLayout;
        
        textFieldGrp
          -label "Save Image As"
          -text $imageFilePath
          -adjustableColumn 2
          -annotation "Choose the file name and destination folder for the Dome Text generated image. You can create an image in the \nPNG, TIFF, TGA, BMP and PSD image formats based upon the file extension you enter. By clicking on the folder \nicon you can choose an existing file on your hard drive."
          textImageOutputName;
          
        symbolButton 
          -image "navButtonBrowse.png"
          -annotation "Choose the file name and destination folder for the Dome Text generated image. You can create an image in the \nPNG, TIFF, TGA, BMP and PSD image formats based upon the file extension you enter. By clicking on the folder \nicon you can choose an existing file on your hard drive."
          -command "string $tempPath = getDomeImagePath(); textFieldGrp -edit -text $tempPath textImageOutputName;"
          symbolImageSaveAsbrowser;
      setParent ..;

      // Create the image width option menu  
      // options: 64, 128, 256, 512, 1024, 1536, 2048, 3072, 4096
      optionMenuGrp
        -label "Image Width" -extraLabel "Pixels" 
        -columnWidth 2 70 
        -annotation "Set the horizontal resolution of the Dome Text image. The width is defined in pixels."
        menuImageWidthSelect;
        
      menuItem -label "64";
      menuItem -label "128";
      menuItem -label "256";
      menuItem -label "512";
      menuItem -label "1024";
      menuItem -label "1536";
      menuItem -label "2048";
      menuItem -label "3072";
      menuItem -label "4096";
      menuItem -label "8192";

      //Preselect the "1024" option menu
      optionMenuGrp
        -edit
        -select 5
        menuImageWidthSelect;
        
      // Create the image height option menu    
      optionMenuGrp
        -label "Image Height" -extraLabel "Pixels" 
        -columnWidth 2 70 
        -annotation "Set the vertical resolution of the Dome Text image. The height is defined in pixels."
        menuImageHeightSelect;
        
      menuItem -label "(auto)";
      menuItem -label "64";
      menuItem -label "128";
      menuItem -label "256";
      menuItem -label "512";
      menuItem -label "1024";
      menuItem -label "1536";
      menuItem -label "2048";
      menuItem -label "3072";
      menuItem -label "4096";
      menuItem -label "8192";

      //Preselect the "(auto)" option menu
      optionMenuGrp 
        -edit
        -select 6
        menuImageHeightSelect;

    setParent ..;
  setParent ..; 

  frameLayout 
      -label "Shape Controls"
      -collapsable true
      -collapse true
      -borderStyle "etchedIn";
      
    columnLayout
      -adjustableColumn true
      domeTextCameraLayout;
      
      //Create the Camera option menu
      buildDomeTextCamerasMenu();
    setParent ..;    
      
      
    columnLayout 
      //-width ($domeWindowWidth-30)
      //-width $domeWindowWidth
      -adjustableColumn true
      TextureControlsLayout;
      
    optionMenuGrp
      -label "Texture Node" 
      // "Maya File Texture" "mentalrayTexture" "Skip Node Creation" "Update Existing Node"
     -annotation "Choose between a classic Maya Software material, or a native Mental Ray material, \nskip the creation of a new texture node, or update an existing node."
      //Toggle the surface node, and shape node option menus
      -changeCommand "disableSurfaceAndShape();"
      menuTextureFormat;
      
    menuItem -label "Lambert";  
    menuItem -label "SurfaceShader";
    menuItem -label "mia_material_x_passes";
    menuItem -label "Skip Node Creation";
    menuItem -label "Update Existing Node" -enable false;
      
     //Preselect the "Maya Lambert" option menu
    optionMenuGrp 
      -edit
      -select 1
      menuTextureFormat;

  setParent ..;
     
  columnLayout 
    //-width ($domeWindowWidth-30)
    //-width $domeWindowWidth
    -adjustableColumn true
    ShapeControlsLayout;  
     
    optionMenuGrp 
      -label "Supporting Shape" 
      // "None" "Rectangle" "Cylinder" "Dome"
      -annotation "Choose the base geometry that the Dome Text material is applied to."
      menuShapeFormat;
      
      menuItem -label "None";
      menuItem -label "Plane";
      //menuItem -label "Cylinder" -enable false;
      menuItem -label "Cylinder";
	 //menuItem -label "Dome" -enable false;
      menuItem -label "Dome" -enable false;
	  
    //Preselect the "Plane" option menu
    optionMenuGrp -edit
      -select 2
      menuShapeFormat;
      
    optionMenuGrp
      -label "Orientation Axis" 
      // Creation Axis: Right (X):Top (Y): Front (Z)
     -annotation "Choose which view to use when placing the supporting surface."
      //Toggle the surface node, and shape node option menus
      -changeCommand "disableSurfaceAndShape();"
      menuDomeOrientationAxis;
      
    menuItem -label "Right (X)";
    menuItem -label "Top (Y)";
    menuItem -label "Front (Z)";
      
     //Preselect the right (x) option menu
    optionMenuGrp 
      -edit
      -select 3
      menuDomeOrientationAxis;
      
    floatSliderGrp 
        -label "Shape Height" 
        -field true
        -minValue 0.1 -maxValue 1000
        -fieldMinValue 0  -fieldMaxValue 1000
        -value 10
        -annotation 
        "Control the height of the polygon plane, cylinder, or dome surface in scene units. Note: The width or radius value \nis automatically set based upon the image aspect ratio."
        sliderShapeHeightSize; 
 
    setParent ..;
  setParent ..;

   frameLayout 
      -label "Texture Placement"
      -collapsable true
      -collapse true
      -borderStyle "etchedIn";
      
    columnLayout
      -adjustableColumn true
      domeTextCameraLayout;       

    checkBoxGrp
      -numberOfCheckBoxes 1
      -label "Flip Text Direction"
      -value1 false
      -annotation "This will flip the the text horizontally. This is useful for adjusting the readability of the dome text on the inside vs outside face of a cylindrical surface"
      checkGrpMirrorText;

    checkBoxGrp
      -numberOfCheckBoxes 2
      -label "Text Wrapping"
      -label1 "WrapU"
      -label2 "WrapV"
      -value1 true
      -value2 true
      -annotation "Wrap the texture map around the UV Border. This is useful when combined with animating the horizontal and vertical texture offset, and the domeText animation controls."
      checkGrpWrapText;
      
    setParent ..;
  setParent ..;
  
  frameLayout 
    -label "Text Animation Controls"
    -collapsable true
    -collapse true
    -borderStyle "etchedIn";
    
    optionMenuGrp
      -label "Auto Scroll Direction"
      -columnAlign 1 "right"
      -annotation "Choose the direction of the automatic text scrolling effect."
      menuAutoScrollDirectionSelect;

    menuItem -label "Off";
    menuItem -label "Scroll Left";
    menuItem -label "Scroll Right";
    menuItem -label "Scroll Up"; 
    menuItem -label "Scroll Down";
    
    optionMenuGrp 
      -edit
      -select 1
      menuAutoScrollDirectionSelect;
    
    rowLayout 
      -numberOfColumns 2
      -adjustableColumn 2
      -columnWidth2 260 260
      -columnAlign2 "left" "left";

      //Get the current frame range
      int $minFrame = `playbackOptions -query -min`;
      int $maxFrame = `playbackOptions -query -max`;
      
      intFieldGrp 
        -numberOfFields 1
        -label "Start Frame" 
        -value1 $minFrame
        -annotation "Choose the starting frame for the animated title scroll."
        intAnimationStartFrame;

      intFieldGrp 
        -numberOfFields 1
        -label "End Frame" 
        -value1 $maxFrame
        -annotation "Choose the ending frame for the animated title scroll."
        intAnimationEndFrame;
        
    setParent ..;
 
    checkBoxGrp
      -numberOfCheckBoxes 1
      -label "Loop Animation"
      -value1 true
      -annotation "Enables continuous scrolling of the animated text."
      checkGrpLoopAnimation;
 
  setParent ..;
  
  frameLayout 
    -label "Custom ImageMagick Text Options"
    -collapsable true
    -collapse true
    -borderStyle "etchedIn";
  
    //columnLayout 
     // -adjustableColumn true;
      
      rowLayout 
        -numberOfColumns 2
        -adjustableColumn 1
        -columnWidth2 340 50
        -columnAlign2 "left" "center";
      
      scrollField
        -wordWrap true 
        //-width $domeWindowWidth
        -height 60
        -text ""
        -numberOfLines 3
        -annotation "Enter your custom Imagemagick command line options."
        scrollImagemagickCustomText; 
      
      iconTextButton 
        //-style "iconAndTextHorizontal"
        -style "iconAndTextVertical"
        -image1 "imagemagick.png" 
        -label "Imagemagick Help"
        -align "center"
        -annotation "Load the Imagemagick command line help webpage."
        -command "showHelp -absolute \"http://www.imagemagick.org/script/convert.php\";" 
        buttonImagemagickHelp;
      
    setParent ..;
  setParent ..;
      
  columnLayout 
    //-width $domeWindowWidth
    -adjustableColumn true ;

    button 
      -label "Create Text"
      -annotation "Create a new Dome Text based raster image."
      -command "createDomeText()"; 
      
    //button -label "Close"
    //  -command "deleteUI domeTextWin;";
    setParent ..;
    
  columnLayout 
    //-width ($domeWindowWidth-30)
    //-width $domeWindowWidth
    -adjustableColumn true
    LoadViewlayout;
      
    button
      -label "Load Image in Render View"
      -annotation 
      "This button loads the current image that is listed in the \"Save Image As\" text field in the Render View \nwindow. The image is auto sized to fit the window size. You can view the image at the native resolution \nby pressing the 1:1 button in the Render View. You can also view the alpha channel in the render view."
      -command "loadInRenderView()"; 
      
  setParent ..;
  
  //----------------------------------------------------------------------
  //Show the window
  //On Maya 2011 and higher provide access to the dockable UI 
  //----------------------------------------------------------------------
  
  string $dockedArea = "";
  int $dockedFloating = 0;

  //Load the dockControl Settings
  if ($mayaVersion >= 2011) {
    //Is the window docked to the left or right of the screen?
    if(`optionVar -exists "domeTextDockControlArea"`){
      $dockedArea = `optionVar -query "domeTextDockControlArea"`;
    } else{
      $dockedArea = "right";
    }

    //Is the window floating or not?
    if(`optionVar -exists "domeTextDockControlFloating"`){
      $dockedFloating = `optionVar -query "domeTextDockControlFloating"`;
    } else {
      $dockedFloating = 0;
    }
  }
  
  if ( $mayaVersion == 2011 ){
  //Make the Maya 2011 or higher window dockable
  string $domeTextDockControl = `dockControl 
        -label "Dome Text"
				-area $dockedArea 
				// -area "right" //snap to the right side of the view next to the attribute editor
				//-area "left"     //snap to the left side of the view next to the tool settings tab
        -content domeTextWin
				-floating $dockedFloating
				//-floating 1 //floating window
				//-floating 0 //docked window
		    -height $domeWindowHeight
        -width $domeWindowWidth
        //-allowedArea "all"
        -allowedArea "left"
        -allowedArea "right"
        -raise
        // Disabled for Maya 2011 compatibility testing
        //-floatChangeCommand "evalDeferred(\"dockControl -e -width $domeWindowWidth domeTextDockControl;dockControl -e -height $domeWindowHeight domeTextDockControl;SaveDockedDomeTextWindowPos();\")"
        domeTextDockControl`;
  
  //Force the window back to the right size
  evalDeferred("dockControl -e -width $domeWindowWidth domeTextDockControl;dockControl -e -height $domeWindowHeight domeTextDockControl;SaveDockedDomeTextWindowPos();");

  //Get the current window size
  print ("\nDome Text Window Size: " 
            + `dockControl -q -width domeTextDockControl` 
            + " width " 
            + `dockControl -q -height domeTextDockControl` 
            + " height\n");
  }else if ( $mayaVersion >= 2012 ) {
  //Make the Maya 2011 or higher window dockable
  string $domeTextDockControl = `dockControl 
        -label "Dome Text"
				-area $dockedArea 
				// -area "right" //snap to the right side of the view next to the attribute editor
				//-area "left"     //snap to the left side of the view next to the tool settings tab
        -content domeTextWin
				-floating $dockedFloating
				//-floating 1 //floating window
				//-floating 0 //docked window
		    -height $domeWindowHeight
        -width $domeWindowWidth
        //-allowedArea "all"
        -allowedArea "left"
        -allowedArea "right"
        -raise
        // Disabled for Maya 2011 compatibility testing
        -floatChangeCommand "evalDeferred(\"dockControl -e -width $domeWindowWidth domeTextDockControl;dockControl -e -height $domeWindowHeight domeTextDockControl;SaveDockedDomeTextWindowPos();\")"
        domeTextDockControl`;
  
  //Force the window back to the right size
  evalDeferred("dockControl -e -width $domeWindowWidth domeTextDockControl;dockControl -e -height $domeWindowHeight domeTextDockControl;SaveDockedDomeTextWindowPos();");

  //Get the current window size
  print ("\nDome Text Window Size: " 
            + `dockControl -q -width domeTextDockControl` 
            + " width " 
            + `dockControl -q -height domeTextDockControl` 
            + " height\n");
 
  } else{
    //Make the Maya 2010 or lower window a regular window type
    //showWindow $domeTextWindow;
    showWindow domeTextWin;
    
    //Get the current window size
    print ("\nDome Text Window Size: "  
             + `window -q -width domeTextWin` 
             + " width " 
             + `window -q -height domeTextWin` 
             + " height\n"); 
  }
}


//Load the generated image in the Maya Render View window
global proc loadInRenderView(){
  //Get the generated image filename
  string $filenameString = `textFieldGrp -query -text textImageOutputName`;

  //Check if the generated image exists
  if (`filetest -f $filenameString`){
    print("Loading image " + $filenameString + " in the render view\n");
    //string $editor = `renderWindowEditor`;
    string $editor = "renderView";
    renderWindowEditor -edit -autoResize true -loadImage $filenameString $editor;
  }else{
    print("Image " + $filenameString + " does not exist.\n");
  }
}


global proc createDomeText(){
  python( "import sys" );

   //Check the operating system
  string $mayaPlatform = getMayaPlatform();
  
  //Check if we are running Maya 2011 or higher
  float $mayaVersion = getMayaVersionDome();
  print("Maya " + $mayaVersion + " on " + $mayaPlatform  + " detected.\n");

  //Get the camera name
  string $CameraName = `optionMenuGrp -query -value menuDomeTextCameraSelect`;

  //Convert 0-1 color values to a 0-255 range
  float $floatToEightBitColor = 256;
  
  //Font Controls
  int $fontId = `optionMenuGrp -query -select menuFontNameSelect`;
  string $fontName =`optionMenuGrp -query -value menuFontNameSelect`;
  string $textEncoding = `optionMenuGrp -query -value menuTextEncodingSelect`;
  int $fontSize = `intSliderGrp -query -value sliderPointSize`;
  float $kerningSize = `floatSliderGrp -query -value sliderKerningSize`;
  string $fontAlign = `optionMenuGrp -query -value menuFontAlignSelect`;
  string $fontStyle =`optionMenuGrp -query -value menuFontWeightSelect`;
  string $convertCharacters = `optionMenuGrp -query -value menuConvertCharacters`;
  
  //Select "Maya File Texture" or "Mental Ray Texture" node generation
  int $textureFormat = `optionMenuGrp -query -select menuTextureFormat`;
  
  //Select the domeText geometry format: None:Plane:Cylinder:Dome
  int $domeShapeFormat = `optionMenuGrp -query -select menuShapeFormat`;
  //Write the geometry format as a plain text string
  string $domeShapeType = `optionMenuGrp -query -value menuShapeFormat`;
  
  //User entered text
  string $domeTextString = `scrollField -query -text scrollTextString`;
  
  //User entered Imagemagick custom text options
  string $imagemagickCustomText = `scrollField -query -text scrollImagemagickCustomText`;
  
  //Generated Filename
  string $filenameString = `textFieldGrp -query -text textImageOutputName`;

  //Generated image width and height in pixels
  string $imageWidth =`optionMenuGrp -query -value menuImageWidthSelect`;
  string $imageHeight = `optionMenuGrp -query -value menuImageHeightSelect`;
  
  //Color Swatches
  float $foregroundRGBcolor[] = `colorSliderGrp -query -rgb sliderForeColor`;
  float $backgroundRGBcolor[] = `colorSliderGrp -query -rgb sliderBackColor`;
  
  int $isbackgroundTransparent = `checkBoxGrp -query -value1 checkGrpTransparentBackground`;
  
  
  //Debug Values
  print("Output Geometry: " + $domeShapeType + "\n");
  print("File texture node format: " + $textureFormat + "\n");
  print("Font: " + $fontName + " Font ID: " + $fontId + "\n");
  print("Text Encoding: " + $textEncoding + "\n");
  print("Font Style: " + $fontStyle + "\n");
  print("Convert Case: " + $convertCharacters + "\n");
  print("Point Size: " + $fontSize + "\n");
  print("Kerning Size: " + $kerningSize + "\n");
  
  print("Foreground Color: "  
  + $foregroundRGBcolor[0] + " " 
  + $foregroundRGBcolor[1] + " " 
  + $foregroundRGBcolor[2] + "\n"); 
  
  print("Background Color: " 
  + $backgroundRGBcolor[0] + " " 
  + $backgroundRGBcolor[1] + " " 
  + $backgroundRGBcolor[2] + " " 
  + "\n");
  
  print("Transparent BG: " + $isbackgroundTransparent + "\n");
  
  print("Image Filename: " + $filenameString + "\n");
  print("Image Size: " + $imageWidth + "x"+ $imageHeight + "\n");
  
  print("\nText: " + $domeTextString + "\n");
  
  print("\nImagemagick Custom Text: " + $imagemagickCustomText + "\n");
  
  if ( $CameraName  != "Select a Camera..." ){
    print("The DomeText align to camera feature is enabled. The DomeText will be aligned to the " + $CameraName + "\n");
  } else{
    print("The DomeText camera alignment feature was disabled as no camera was selected.\n");
  }
  
  //Speak the text aloud
  //system("say \"" + $domeTextString + "\"");
  
  // Create a custom text file
  $textFilenameString = ( `internalVar -userTmpDir` + "dometext.txt" );
  //$textFilenameString = $filenameString + ".txt";
  $fileId=`fopen $textFilenameString "w"`;
  fprint $fileId ($domeTextString + "\n");
  fclose $fileId;
  
  //Convert the file to UTF8
  string $utfTextFilenameString = ( `internalVar -userTmpDir` + "dometext_utf8.txt" );
  //$textFilenameString = $filenameString + "utf8.txt";
  
  //Choose the text encoding format
  string $textEncodingFormat = "";
    
  if ( $textEncoding == "Windows Default - Western Europe windows-1252" ){
    $textEncodingFormat = "windows-1252";
  } else if ( $textEncoding == "English ascii" ){
    $textEncodingFormat = "ascii";
  } else if ( $textEncoding == "Traditional Chinese big5" ){
    $textEncodingFormat = "big5";
  } else if ( $textEncoding == "Traditional Chinese big5hkscs" ){
    $textEncodingFormat = "big5hkscs";
  } else if ( $textEncoding == "English cp037" ){
    $textEncodingFormat = "cp037";
  } else if ( $textEncoding == "Hebrew cp424" ){
    $textEncodingFormat = "cp424";
  } else if ( $textEncoding == "English cp437" ){
    $textEncodingFormat = "cp437";
  } else if ( $textEncoding == "Western Europe cp500" ){
    $textEncodingFormat = "cp500";
  } else if ( $textEncoding == "Arabic cp720" ){
    $textEncodingFormat = "cp720";
  } else if ( $textEncoding == "Greek cp737" ){
    $textEncodingFormat = "cp737";
  } else if ( $textEncoding == "Baltic languages cp775" ){
    $textEncodingFormat = "cp775";
  } else if ( $textEncoding == "Western Europe cp850" ){
    $textEncodingFormat = "cp850";
  } else if ( $textEncoding == "Central and Eastern Europe cp852" ){
    $textEncodingFormat = "cp852";
  } else if ( $textEncoding == "Bulgarian, Byelorussian, Macedonian, Russian, Serbian cp855" ){
    $textEncodingFormat = "cp855";
  } else if ( $textEncoding == "Hebrew cp856" ){
    $textEncodingFormat = "cp856";
  } else if ( $textEncoding == "Turkish cp857" ){
    $textEncodingFormat = "cp857";
  } else if ( $textEncoding == "Western Europe cp858" ){
    $textEncodingFormat = "cp858";
  } else if ( $textEncoding == "Portuguese cp860" ){
    $textEncodingFormat = "cp860";
  } else if ( $textEncoding == "Icelandic cp861" ){
    $textEncodingFormat = "cp861";
  } else if ( $textEncoding == "Hebrew cp862" ){
    $textEncodingFormat = "cp862";
  } else if ( $textEncoding == "Canadian cp863" ){
    $textEncodingFormat = "cp863";
  } else if ( $textEncoding == "Arabic cp864" ){
    $textEncodingFormat = "cp864";
  } else if ( $textEncoding == "Danish, Norwegian cp865" ){
    $textEncodingFormat = "cp865";
  } else if ( $textEncoding == "Russian cp866" ){
    $textEncodingFormat = "cp866";
  } else if ( $textEncoding == "Greek cp869" ){
    $textEncodingFormat = "cp869";
  } else if ( $textEncoding == "Thai cp874" ){
    $textEncodingFormat = "cp874";
  } else if ( $textEncoding == "Greek cp875" ){
    $textEncodingFormat = "cp875";
  } else if ( $textEncoding == "Japanese cp932" ){
    $textEncodingFormat = "cp932";
  } else if ( $textEncoding == "Korean cp949" ){
    $textEncodingFormat = "cp949";
  } else if ( $textEncoding == "Traditional Chinese cp950" ){
    $textEncodingFormat = "cp950";
  } else if ( $textEncoding == "Urdu cp1006" ){
    $textEncodingFormat = "cp1006";
  } else if ( $textEncoding == "Turkish cp1026" ){
    $textEncodingFormat = "cp1026";
  } else if ( $textEncoding == "Western Europe cp1140" ){
    $textEncodingFormat = "cp1140";
  } else if ( $textEncoding == "Central and Eastern Europe cp1250" ){
    $textEncodingFormat = "cp1250";
  } else if ( $textEncoding == "Bulgarian, Byelorussian, Macedonian, Russian, Serbian cp1251" ){
    $textEncodingFormat = "cp1251";
  } else if ( $textEncoding == "Western Europe cp1252" ){
    $textEncodingFormat = "cp1252";
  } else if ( $textEncoding == "Greek cp1253" ){
    $textEncodingFormat = "cp1253";
  } else if ( $textEncoding == "Turkish cp1254" ){
    $textEncodingFormat = "cp1254";
  } else if ( $textEncoding == "Hebrew cp1255" ){
    $textEncodingFormat = "cp1255";
  } else if ( $textEncoding == "Arabic cp1256" ){
    $textEncodingFormat = "cp1256";
  } else if ( $textEncoding == "Baltic languages cp1257" ){
    $textEncodingFormat = "cp1257";
  } else if ( $textEncoding == "Vietnamese cp1258" ){
    $textEncodingFormat = "cp1258";
  } else if ( $textEncoding == "Japanese euc_jp" ){
    $textEncodingFormat = "euc_jp";
  } else if ( $textEncoding == "Japanese euc_jis_2004" ){
    $textEncodingFormat = "euc_jis_2004";
  } else if ( $textEncoding == "Japanese euc_jisx0213" ){
    $textEncodingFormat = "euc_jisx0213";
  } else if ( $textEncoding == "Korean euc_kr" ){
    $textEncodingFormat = "euc_kr";
  } else if ( $textEncoding == "Simplified Chinese gb2312" ){
    $textEncodingFormat = "gb2312";
  } else if ( $textEncoding == "Unified Chinese gbk" ){
    $textEncodingFormat = "gbk";
  } else if ( $textEncoding == "Unified Chinese gb18030" ){
    $textEncodingFormat = "gb18030";
  } else if ( $textEncoding == "Simplified Chinese hz" ){
    $textEncodingFormat = "hz";
  } else if ( $textEncoding == "Japanese iso2022_jp" ){
    $textEncodingFormat = "iso2022_jp";
  } else if ( $textEncoding == "Japanese iso2022_jp_1" ){
    $textEncodingFormat = "iso2022_jp_1";
  } else if ( $textEncoding == "Japanese, Korean, Simplified Chinese, Western Europe, Greek iso2022_jp_2" ){
    $textEncodingFormat = "iso2022_jp_2";
  } else if ( $textEncoding == "Japanese iso2022_jp_2004" ){
    $textEncodingFormat = "iso2022_jp_2004";
  } else if ( $textEncoding == "Japanese iso2022_jp_3" ){
    $textEncodingFormat = "iso2022_jp_3";
  } else if ( $textEncoding == "Japanese iso2022_jp_ext" ){
    $textEncodingFormat = "iso2022_jp_ext";
  } else if ( $textEncoding == "Korean iso2022_kr" ){
    $textEncodingFormat = "iso2022_kr";
  } else if ( $textEncoding == "West Europe latin_1" ){
    $textEncodingFormat = "latin_1";
  } else if ( $textEncoding == "Central and Eastern Europe iso8859_2" ){
    $textEncodingFormat = "iso8859_2";
  } else if ( $textEncoding == "Esperanto, Maltese iso8859_3" ){
    $textEncodingFormat = "iso8859_3";
  } else if ( $textEncoding == "Baltic languages iso8859_4" ){
    $textEncodingFormat = "iso8859_4";
  } else if ( $textEncoding == "Bulgarian, Byelorussian, Macedonian, Russian, Serbian iso8859_5" ){
    $textEncodingFormat = "iso8859_5";
  } else if ( $textEncoding == "Arabic iso8859_6" ){
    $textEncodingFormat = "iso8859_6";
  } else if ( $textEncoding == "Greek iso8859_7" ){
    $textEncodingFormat = "iso8859_7";
  } else if ( $textEncoding == "Hebrew iso8859_8" ){
    $textEncodingFormat = "iso8859_8";
  } else if ( $textEncoding == "Turkish iso8859_9" ){
    $textEncodingFormat = "iso8859_9";
  } else if ( $textEncoding == "Nordic languages iso8859_10" ){
    $textEncodingFormat = "iso8859_10";
  } else if ( $textEncoding == "Baltic languages iso8859_13" ){
    $textEncodingFormat = "iso8859_13";
  } else if ( $textEncoding == "Celtic languages iso8859_14" ){
    $textEncodingFormat = "iso8859_14";
  } else if ( $textEncoding == "Western Europe iso8859_15" ){
    $textEncodingFormat = "iso8859_15";
  } else if ( $textEncoding == "South-Eastern Europe iso8859_16" ){
    $textEncodingFormat = "iso8859_16";
  } else if ( $textEncoding == "Korean johab" ){
    $textEncodingFormat = "johab";
  } else if ( $textEncoding == "Russian koi8_r" ){
    $textEncodingFormat = "koi8_r";
  } else if ( $textEncoding == "Ukrainian koi8_u" ){
    $textEncodingFormat = "koi8_u";
  } else if ( $textEncoding == "Bulgarian, Byelorussian, Macedonian, Russian, Serbian mac_cyrillic" ){
    $textEncodingFormat = "mac_cyrillic";
  } else if ( $textEncoding == "Greek mac_greek" ){
    $textEncodingFormat = "mac_greek";
  } else if ( $textEncoding == "Icelandic mac_iceland" ){
    $textEncodingFormat = "mac_iceland";
  } else if ( $textEncoding == "Central and Eastern Europe mac_latin2" ){
    $textEncodingFormat = "mac_latin2";
  } else if ( $textEncoding == "Western Europe mac_roman" ){
    $textEncodingFormat = "mac_roman";
  } else if ( $textEncoding == "Turkish mac_turkish" ){
    $textEncodingFormat = "mac_turkish";
  } else if ( $textEncoding == "Kazakh ptcp154" ){
    $textEncodingFormat = "ptcp154";
  } else if ( $textEncoding == "Japanese shift_jis" ){
    $textEncodingFormat = "shift_jis";
  } else if ( $textEncoding == "Japanese shift_jis_2004" ){
    $textEncodingFormat = "shift_jis_2004";
  } else if ( $textEncoding == "Japanese shift_jisx0213" ){
    $textEncodingFormat = "shift_jisx0213";
  } else if ( $textEncoding == "all languages utf_32" ){
    $textEncodingFormat = "utf_32";
  } else if ( $textEncoding == "all languages utf_32_be" ){
    $textEncodingFormat = "utf_32_be";
  } else if ( $textEncoding == "all languages utf_32_le" ){
    $textEncodingFormat = "utf_32_le";
  } else if ( $textEncoding == "all languages utf_16" ){
    $textEncodingFormat = "utf_16";
  } else if ( $textEncoding == "all languages (BMP only) utf_16_be" ){
    $textEncodingFormat = "utf_16_be";
  } else if ( $textEncoding == "all languages (BMP only) utf_16_le" ){
    $textEncodingFormat = "utf_16_le";
  } else if ( $textEncoding == "all languages utf_7" ){
    $textEncodingFormat = "utf_7";
  } else if ( $textEncoding == "all languages utf_8" ){
    $textEncodingFormat = "utf_8";
  } else if ( $textEncoding == "all languages utf_8_sig" ){
    $textEncodingFormat = "utf_8_sig";
  }else{
    //Windows default format - Western Europe fallback
    $textEncodingFormat = "windows-1252";
  }
  
  // Actual command:
  // import domeTextUTF as domeTextUTF
  // domeTextUTF.convertTextToUTF('C:/dometext.txt', 'C:/dometext_utf8.txt', 'big5', 'Normal Case')
  string $utfPythonConvertString  = "";
  $utfPythonConvertString += "import domeTextUTF as domeTextUTF\n";
  $utfPythonConvertString += "reload(domeTextUTF)\n";
  $utfPythonConvertString += "domeTextUTF.convertTextToUTF(";
  $utfPythonConvertString += "'" + $textFilenameString + "', '" + $utfTextFilenameString + "', '" + $textEncodingFormat +  "', '" + $convertCharacters + "')";
  
  //Convert the text formats to UTF8
  python($utfPythonConvertString);
  
  //Send the text commands to ImageMagick
  //Check the platform to come up with the correct syntax
  string $changeWorkingDir = "";
  string $imagemagickPath = "";

  if ($mayaPlatform  == "windows"){
    //Windows 32/x64
    //Warning: The convert.exe program has the same name as a windows 7 system tool so it has been renamed domeconvert.exe

    //Debug testing alternate paths
    //$imagemagickPath = "\"C:\\Program Files\\Domemaster3D\\bin\\domeconvert.exe\"";
    //$imagemagickPath = "\"%PROGRAMFILES%\"\\Domemaster3D\\bin\\domeconvert.exe";
    //$imagemagickPath = " \"\"%PROGRAMFILES%\"\"\\Domemaster3D\\bin\\domeconvert.exe ";
   
   //Added to system path: ";C:\Program Files\Domemaster3D\bin"
    $imagemagickPath = "domeconvert.exe";
  }else if ($mayaPlatform  == "darwin"){
    //Mac OS X
    //Check for ImageMagick installs on Mac OS X
    string $optLocalBin = "/opt/local/bin/convert";
    string $optImageMagickBin = "/opt/ImageMagick/bin/convert";

    //Verify which ImageMagick paths exist on the system
    if(`file -query -exists $optLocalBin`){
      $imagemagickPath = $optLocalBin;
      print("ImageMagick was found in " + $imagemagickPath + "\n");
    } else if (`file -query -exists $optImageMagickBin`){
      $imagemagickPath = $optImageMagickBin;
      print("ImageMagick was found in " + $imagemagickPath + "\n");
    } else {
      $imagemagickPath = "convert";
      print("Looking for ImageMagick in the system $PATH locations.\n");
    }
  }else {  
    //Linux
    //$imagemagickPath = "convert";
    $imagemagickPath = "/usr/bin/convert";
  }
 
  //Pick the correct font settings for the current platform
  string $fontString = "";
  string $fontFolderPath;   

  //Select the fonts
  if ($mayaPlatform  == "windows"){
    //Windows 32/x64
    //$fontString = " -font \"" + "c:\\windows\\fonts\\courbd.ttf" + "\"";
    //$fontString =  " -font \"" + "Courier-New-Bold" + "\"";
    $fontFolderPath = "C:/Windows/Fonts/";
    $fontString =  " -font \"" + $fontFolderPath + $fontName + "\"";
  }else if ($mayaPlatform  == "darwin"){
    //Mac OS X
    //$fontString =  " -font \"" + "Courier" + "\"";
    $fontString =  " -font \"" + $fontName + "\"";
  }else{  
    //Linux
    //$fontString =  " -font \"" + "Courier" + "\"";
    $fontString =  " -font \"" + $fontName + "\"";
  }

  //Set up the custom font styles
  string $fontStyleString = "";

  //start by adding the Unicode text encoding flag as the first item
  //$fontStyleString += " -encoding Unicode ";
  $fontStyleString += " -pointsize \"" + $fontSize + "\"";
  $fontStyleString += " -kerning \"" + $kerningSize + "\"";
  $fontStyleString += " -weight \"" + $fontStyle + "\"";
  $fontStyleString += " -size \"" + $imageWidth + "\"x";
   
   //Check if the image height is set to the automatic size mode
   if ($imageHeight != "(auto)"){
    $fontStyleString += "\"" + $imageHeight + "\"";
   }

  $fontStyleString += " -gravity " + $fontAlign; 

  //Create the text caption string elements
  //Pick the correct text caption settings for the current platform
  string $captionString = "";

  //Select the platform
  if ($mayaPlatform  == "windows"){
    //Windows 32/x64 - Use @file for text contents
    //$captionString = " caption:@" + $textFilenameString;
    $captionString = " caption:@" + $utfTextFilenameString;
    
  }else if ($mayaPlatform  == "darwin"){
    //Mac OS X - Use @file for text contents
    //$captionString =  " caption:@" + $textFilenameString;
    $captionString = " caption:@" + $utfTextFilenameString;
  }else{  
    //Linux - Use @file for text contents
    //$captionString = " caption:@" + $textFilenameString;
    $captionString = " caption:@" + $utfTextFilenameString;
  }

  //Checks for transparency and writes the background color to a string
  string $backgroundColorString = "";
  string $fillColorString = "";

  if ($isbackgroundTransparent){
    $backgroundColorString = " -background none";

    //extra imagemagick composite flag
    //$backgroundColorString = $backgroundColorString+ " -composite ";

  } else{
      $backgroundColorString = " -background \"rgb("
      + trunc($backgroundRGBcolor[0]*$floatToEightBitColor) + ", " 
      + trunc($backgroundRGBcolor[1]*$floatToEightBitColor) + ", " 
      + trunc($backgroundRGBcolor[2]*$floatToEightBitColor)
      + ")\"";
      
      // $backgroundColorString = " -background \"rgb("
      // + ceil($backgroundRGBcolor[0]*$floatToEightBitColor) + ", " 
      // + ceil($backgroundRGBcolor[1]*$floatToEightBitColor) + ", " 
      // + ceil($backgroundRGBcolor[2]*$floatToEightBitColor)
      // + ")\"";
  }

  //Write the foreground fill color values to a string
  $fillColorString = " -fill \"rgb("
      + trunc($foregroundRGBcolor[0]*$floatToEightBitColor) + ", " 
      + trunc($foregroundRGBcolor[1]*$floatToEightBitColor) + ", " 
      + trunc($foregroundRGBcolor[2]*$floatToEightBitColor)
      + ")\"";

  //$fillColorString = " -fill \"rgb("
      // + ceil($foregroundRGBcolor[0]*$floatToEightBitColor) + ", " 
      // + ceil($foregroundRGBcolor[1]*$floatToEightBitColor) + ", " 
      // + ceil($foregroundRGBcolor[2]*$floatToEightBitColor)
      // + ")\"";

  //Save the system console command string to a variable
  string $systemCommandString = "";

  $systemCommandString += $imagemagickPath;
  $systemCommandString += $backgroundColorString;
  $systemCommandString += $fillColorString;
  $systemCommandString += $fontString;
  $systemCommandString += $fontStyleString;
  $systemCommandString += $captionString;
  $systemCommandString += " " + $imagemagickCustomText + " ";
  $systemCommandString += " " + "\"" + $filenameString + "\"";
  $systemCommandString += "\n";
  
  print("DomeConvert Command: " + $systemCommandString + "\n");
  string $result = system($systemCommandString);
  print ("Feedback: " + $result + "\n");
   
   
  //Create a new dometext command log file for debugging
  //The log file is called DomeTextLog.txt and is stored in the user's temp directory
  $logFileNameString = ( `internalVar -userTmpDir` + "DomeTextLog.txt" );
  $logFileId = `fopen $logFileNameString "w"`;
  print ("Writing log file to: " + $logFileNameString + "\n");
  //Save command line log file
  fprint $logFileId ("DomeConvert Command: " + $systemCommandString + "\n");
  fprint $logFileId ("Feedback: " + $result + "\n");
  fclose $logFileId; 
   
  /*
  //Add the text string to the image as an embedded metadata tag
  string $commentString = "";

  //Use either the "-set comment" or "-set label" commands for metadata captions
  //Select the platform
  if ($mayaPlatform  == "windows"){
    //Windows 32/x64 - Use @file for text contents
    //$commentString = " -label @" + $textFilenameString;
    $commentString = " -set label \"Hello Domies\"";
  }else if ($mayaPlatform  == "darwin"){
    //Mac OS X - Use @file for text contents
    $commentString =  " -set label @" + $textFilenameString;
  }else{  
    //Linux - Use @file for text contents
    $commentString = " -set label @" + $textFilenameString;
  }
  
  $systemCommandString = "";
  $systemCommandString += $imagemagickPath;
  $systemCommandString += $commentString;
  $systemCommandString += " " + "\"" + $filenameString + "\"";
  $systemCommandString += "\n";
  
  print("Comment Command: " + $systemCommandString);
  string $result = system($systemCommandString);
  print ("Feedback: " + $result);
  */
  
  //Refresh the image file texture 
  //AEfileTextureReloadCmd file1.fileTextureName;
  
  //Get the file texture node name
  global string $texNodeName = "";
  
  //Generate the correct file texture node
  if($textureFormat == 1){
    //Create a new Maya Lambert + Maya file texture node
    //createDomeFileNode("sourceimages/bob2.png", {0.0, 1.0, 0.0});
    if ($isbackgroundTransparent){
      $texNodeName = createLambertDomeFileNode( $filenameString, {0.0, 0.0, 0.0});
    }else{
      $texNodeName = createLambertDomeFileNode( $filenameString, {$backgroundRGBcolor[0], $backgroundRGBcolor[1], $backgroundRGBcolor[2]});  
     }
  } else if($textureFormat == 2){
    //Create a new Maya SurfaceShader + Maya file texture node
    //createDomeFileNode("sourceimages/bob2.png", {0.0, 1.0, 0.0});
    if ($isbackgroundTransparent){
      $texNodeName = createSurfaceShaderDomeFileNode( $filenameString, {0.0, 0.0, 0.0});
    }else{
      $texNodeName = createSurfaceShaderDomeFileNode( $filenameString, {$backgroundRGBcolor[0], $backgroundRGBcolor[1], $backgroundRGBcolor[2]});  
    } 
  }else if ($textureFormat == 3){
    //Create a new mental ray file texture node
    //createDomeMrFileNode("sourceimages/bob2.png", {0.0, 1.0, 0.0});
    if ($isbackgroundTransparent){
      $texNodeName = createDomeMrFileNode( $filenameString, {0.0, 0.0, 0.0});
    }else{
      $texNodeName = createDomeMrFileNode( $filenameString, {$backgroundRGBcolor[0], $backgroundRGBcolor[1], $backgroundRGBcolor[2]});
    }
  }else if ($textureFormat == 4){
    print("Skipping file texture node creation.\n");
  } //End of file texture node generation
    
  //Create the note message if generating a Maya or Mental Ray node 
  if ( ($textureFormat == 1) || ($textureFormat == 2) || ($textureFormat == 3)) {
    //Write the Dome Text message to the domeText Note fields:
    print("Adding note to " + $texNodeName + " file node\n");
    string $domeTextNoteString = "";
    $domeTextNoteString += $domeTextString;
    //Write the settings to the attribute editor note fields
    setNotesAttribute( $texNodeName, "notes", "nts", "string", `scrollField -edit -text $domeTextNoteString AENotesScrollField`); 
  } //end note generation  
  
  //Regenerate the Text Presets option menu after adding a new node
  buildTextPresetMenu();
  
  //Display the texture node in the attribute editor
  //evalDeferred("showEditorExact ($texNodeName);");
  
  //Enable hardware texturing
  modelEditor -edit -displayAppearance smoothShaded -displayTextures true modelPanel1;
  modelEditor -edit -displayAppearance smoothShaded -displayTextures true modelPanel4;
}


global proc string chooseDomeGeometry(){
  //Select the domeText geometry format: None:Plane:Cylinder:Dome
  int $domeShapeFormat = `optionMenuGrp -query -select menuShapeFormat`;

  string $domeGeometry = "";

  //Check what type of supporting geometry is required
  if ( $domeShapeFormat == 1 ){
    print("Skipping geometry creation\n");
    $domeGeometry = "";
  } else if ( $domeShapeFormat == 2 ){
    print("Creating a new DomeText polygon plane surface.\n");
    $domeGeometry = createDomePlane();
  } else if ( $domeShapeFormat ==3 ){
    print("Creating a new DomeText cylinder surface.\n");
    //$domeGeometry = "pCylinder";
    $domeGeometry = createDomeCylinder();
  } else if ( $domeShapeFormat == 4 ){
    print("Creating a new DomeText dome surface.\n");
    //$domeGeometry = "pDome";
    $domeGeometry = "";
  }
  
  return $domeGeometry;
}


//Find the object's child node
global proc string getObjectShapeNode ( string $object ) {
  string $shapes[] = `listRelatives -children -shapes $object`;
  return $shapes[0];
}

//Find the object's parent node
//example: print `getObjectParentNode( "domeAFL_FOV_CameraShape2")`;
global proc string getObjectParentNode ( string $object ) {
  string $shapes[] = `listRelatives -parent -shapes $object`;
  return $shapes[0];
}
