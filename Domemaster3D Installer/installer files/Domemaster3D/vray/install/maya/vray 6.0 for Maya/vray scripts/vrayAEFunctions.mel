proc string tokenizeWidget(string $widget) {
	string $tokens[];
	string $layoutFromWidget;  // To determine sibling widgets names.

	int $numTokens = tokenize($widget, "|", $tokens);
	for ($i = 0; $i < $numTokens-1; $i++) {
		if ($i > 0) $layoutFromWidget += "|";
		$layoutFromWidget += $tokens[$i];
	}
	return $layoutFromWidget + "|";
}

proc vrayDimAllControls(string $node, string $attrNames[], string $widgetName, int $dim, string $suff) {
	for ($j = 0; $j < size($attrNames); $j++) {
		// This is needed to disable/enable the control next time it is created in vrayAddControl()
		string $attrName = $attrNames[$j];
		if (`objExists ($node+"."+$attrName)`) {
			// referenced nodes can't be locked/unlocked
			// that code is needed for the old scenes that have locked attributes
			// unfortunatelly we can't unlock the attributes from a referenced scene, they have to be unlocked in the original scene
			if ((`getAttr -lock ($node+"."+$attrName)`) && (!`referenceQuery -isNodeReferenced $node`)) {
				setAttr -lock $dim ($node+"."+$attrName); 
			}
			// Dynamic VRay attributes controls for Property Editor 2016 have the pattern "_PE[windowIndex]_tabIndex".
			// To recognize them properly, if the widget layout matches this check then add it also to the control
			string $addPPsuff = match("_PE[0-9]+_[0-9]+", $widgetName);
			string $controlName = $widgetName + $attrName + "_" + (`nodeType $node`) + $suff + $addPPsuff;
			if (`control -exists $controlName`)
				disable -v $dim $controlName;
			else {
				// test if this is a valid layout by checking the possible names for custom control layouts
				string $layoutNames[];
				$layoutNames[0] = $controlName + "_row";
				$layoutNames[1] = makeControlName($attrName) + "Layout";
				for ($layoutName in $layoutNames)
					if (`layout -exists $layoutName`) {
						layout -e -enable (!$dim) $layoutName;
						break;
					}
			}
		}
	}	
}

// Helper function to dim a list of attributes for a specific node
proc vrayDimControls(string $node, string $attrNames[], string $widget, int $dim) {
	string $widgetBase;
	global int $gVRayFrameArrSize;
	global string $gVRayFrameNames[];
	global int $gGeomObjNumIdx[];
	global int $gVRayFrameSuff[];
	global string $gVRayFullFrameNames[]; 
	global string $gBasicFormsNames[];
	global string $gCurrBasicFormName;
	global int $gBaseFormNeedUpdate;

	int $curNodeIdx = getGeomObjNum($node);
	int $i, $j;

	$widgetBase = tokenizeWidget($widget);

	int $objIdx = getGeomObjNum($node);
	if (($gBaseFormNeedUpdate == 1) && ($objIdx > -1)) {
		$gBasicFormsNames[$objIdx] = tokenizeWidget($gCurrBasicFormName);
		$gNewObjAdded = 0;
	}

	// full name of the dynamically created CopyTab form
	for ($i = 0; $i < $gVRayFrameArrSize; $i++) {
		if (($gVRayFrameNames[$i] != "") && (startString($widgetBase, size($gVRayFrameNames[$i])) == $gVRayFrameNames[$i])) {
			$gVRayFullFrameNames[$i] = $widgetBase;
			break;
		}
	}

	for ($i = 0; $i < $gVRayFrameArrSize; $i++) {
		// update forms only for $node
		if (getGeomObjNum($node) != $gGeomObjNumIdx[$i]) continue;
		vrayDimAllControls($node, $attrNames, $gVRayFullFrameNames[$i], $dim, $gVRayFrameSuff[$i]);		
	}

	string $baseForm;
	if ($objIdx >= 0)	$baseForm = $gBasicFormsNames[$objIdx];
	else $baseForm = $widgetBase;
	vrayDimAllControls($node, $attrNames, $baseForm, $dim, "");
}


// These are used just to suppress the map buttons in editorTemplate calls
global proc string makeControlName(string $attrName) {
	string $tokens[];
	string $controlName = ($attrName+"Grp");
	if (tokenize($controlName, "\.", $tokens) == 2) $controlName = $tokens[1];
	$controlName=substitute("\\[", $controlName, "_");
	$controlName=substitute("\\]", $controlName, "_");
	return $controlName;
}

// Returns a control name based on node type and attribute extracted from the given $nodeDotAttr
global proc string vrayMakeNodeAttrControlName(string $nodeDotAttr) {
	string $nodeName = vrayGetPlugNodeName($nodeDotAttr);
	string $nodeType = `nodeType $nodeName`;
	string $attrName = `attributeName -long $nodeDotAttr`;
	string $controlName = $nodeType+"_"+$attrName+"_control";
	return $controlName;
}
// The following drag callback is used for custom controls which should support drag and drop functionality with
// the render setup override system in Maya versions over 2016.5. Currently the supported drag control types are
// {attrFieldSliderGrp, attrColorSliderGrp} whose objectTypeUI is "rowGroupLayout".
global proc string[] vrayCommonDragCallback(string $dragControlName, int $x, int $y, int $modifiers) {
	string $objectTypeUI = `objectTypeUI $dragControlName`;
	if ($objectTypeUI == "rowGroupLayout") {
		string $attribute = `attrControlGrp -q -attribute $dragControlName`;
		return { $attribute };
	}
	else {
		error("vrayCommonDragCallback - Unsupported UI object type");
		return {};
	}
}
// This is a common drag callback for controls that originally don't have embedded attribute support but are connected to one.
// The return value is a string array and its first string represents the type of drag message which should be considered
// in an eventual drop callback. Because we currently don't do anything special, (just like in AEdragCallback) we return the attribute name.
global proc string[] vrayNoAttrControlDragCallback(string $fullAttrName, string $dragControlName, int $x, int $y, int $modifiers) {
	string $nodeName = vrayGetPlugNodeName($fullAttrName);
	string $attrName = `attributeName -long $fullAttrName`;
	if (`attributeExists $attrName $nodeName`)
		return { $fullAttrName };
	error("vrayNoAttrControlDragCallback -Invalid attribute name: "+$fullAttrName);
	return {};
}
// This is a generic function for adding a drag callback used in the render setup override system for Maya versions over 2016.5
// $control - name of the control which should support the drag and drop override capability
// $dragCallback - name of the drag function
// $extraArgs - additional arguments for the drag function (like the attribute name in vrayNoAttrControlDragCallback)
global proc vrayAddDragCallbackForRenderSetupOverride(string $control, string $dragCallback, string $extraArgs) {
	if (`control -ex $control`)
		control -e -dragCallback ($dragCallback+" "+$extraArgs) $control;
}
// For numbers.
global proc floatTexNoMapNew( string $attrLabel, string $attrName ) {
	attrFieldSliderGrp -attribute $attrName -label $attrLabel -hideMapButton true `makeControlName($attrName)`;
	floatTexNoMapReplace($attrLabel, $attrName);
}
global proc floatTexNoMapReplace( string $attrLabel, string $attrName ) {
	string $controlName = `makeControlName($attrName)`;
	attrFieldSliderGrp -e -attribute $attrName $controlName;

	vrayAddDragCallbackForRenderSetupOverride($controlName, "vrayCommonDragCallback", "");
}
global proc editorTemplateFloatNoMap( string $attrName, string $attrLabel) {
	editorTemplate -callCustom ("floatTexNoMapNew \""+$attrLabel+"\" ") ("floatTexNoMapReplace \""+$attrLabel+"\" ") $attrName;
	editorTemplate -suppress $attrName;
}
// Creates a custom control whose visibility depends on whether the current production renderer is GPU.
// $disabledOrInvisible: 0- should disable/dim control for GPU, 1-should make the control invisible for GPU
global proc editorTemplateControlGPUDependentNew(string $attrLabel, int $hideMapButton, int $disabledOrInvisible, string $changeCommand, string $attrName) {
	setUITemplate -pst attributeEditorTemplate;
	string $controlName = vrayMakeNodeAttrControlName($attrName);

	string $changeCommandString = "";
	if ($changeCommand!="") {
		string $nodeName = vrayGetPlugNodeName($attrName);
		$changeCommandString = "-changeCommand (\""+$changeCommand+" "+$nodeName+"\")";
	}

	string $id = eval("attrControlGrp -attribute \""+$attrName+"\" -label \""+$attrLabel+"\" -hideMapButton "+$hideMapButton+" "+$changeCommandString+" "+$controlName);

	if ($disabledOrInvisible == 0)
		vrayDisabledOnGPU("attrControlGrp", $id);
	else
		vrayInvisibleOnGPU($id);
	setUITemplate -ppt;
}
// Updates the connected attribute of a custom control whose visibility depends on whether the current production renderer is GPU.
// $disabledOrInvisible: 0- should disable/dim control for GPU, 1-should make the control invisible for GPU
global proc editorTemplateControlGPUDependentReplace(string $attrLabel, int $hideMapButton, int $disabledOrInvisible, string $changeCommand, string $attrName) {
	string $controlName = vrayMakeNodeAttrControlName($attrName);

	// Maya bug when using attrControlGrp for certain types of attributes with a map button. Maya incorrectly links
	// the map button to the attribute of the node, for which the AE template was generated initially.
	// As a workaround, the type specific commands are used for those types of attributes, which apparently fix the bug.

	string $changeCommandString = "";
	if ($changeCommand!="") {
		string $nodeName = vrayGetPlugNodeName($attrName);
		$changeCommandString = "-changeCommand (\""+$changeCommand+" "+$nodeName+"\")";
	}

	if (`attrFieldSliderGrp -q -ex $controlName`) {
		eval("attrFieldSliderGrp -e -attribute \""+$attrName+"\" "+$changeCommandString+" "+$controlName);
	} else {
		eval("attrControlGrp -e -attribute \""+$attrName+"\" "+$changeCommandString+" "+$controlName);
	}

	vrayApplyGPUStateToUI();
}
// Used for controls (of integer/float/bool attributes) whose visibility depends on whether the current production renderer is GPU
// For color attributes use editorTemplateColorGPUDependent()
// $disabledOrInvisible: 0- should disable/dim control for GPU, 1-should make the control invisible for GPU
global proc editorTemplateControlGPUDependent( string $attrName, string $attrLabel, int $hideMapButton, int $disabledOrInvisible) {
	editorTemplate -callCustom
		("editorTemplateControlGPUDependentNew \""+$attrLabel+"\" "+$hideMapButton+" "+$disabledOrInvisible+" \"\" ")
		("editorTemplateControlGPUDependentReplace \""+$attrLabel+"\" "+$hideMapButton+" "+$disabledOrInvisible+" \"\" ")
		$attrName;
	editorTemplate -suppress $attrName;
}

// Used for controls (of integer/float/bool attributes) whose visibility depends on whether the current production renderer is GPU
// For color attributes use editorTemplateColorGPUDependent()
// $disabledOrInvisible: 0- should disable/dim control for GPU, 1-should make the control invisible for GPU
// $changeCommand: A command, which will be executed when the control is used to change its attribute value
global proc editorTemplateControlGPUDependentChangeCommand( string $attrName, string $attrLabel, int $hideMapButton, int $disabledOrInvisible, string $changeCommand) {
	editorTemplate -callCustom
		("editorTemplateControlGPUDependentNew \""+$attrLabel+"\" "+$hideMapButton+" "+$disabledOrInvisible+" \""+$changeCommand+"\" ")
		("editorTemplateControlGPUDependentReplace \""+$attrLabel+"\" "+$hideMapButton+" "+$disabledOrInvisible+" \""+$changeCommand+"\" ")
		$attrName;
	editorTemplate -suppress $attrName;
}

// Creates a custom control whose visibility depends on whether the current production renderer is GPU.
// $disabledOrInvisible: 0- should disable/dim control for GPU, 1-should make the control invisible for GPU
global proc editorTemplateColorGPUDependentNew(string $attrLabel, int $showMapButton, int $disabledOrInvisible, string $attrName) {
	setUITemplate -pst attributeEditorTemplate;
	string $controlName = vrayMakeNodeAttrControlName($attrName);
	string $id = `attrColorSliderGrp -attribute $attrName -label $attrLabel -showButton $showMapButton $controlName`;
	if ($disabledOrInvisible == 0)
		vrayDisabledOnGPU("attrColorSliderGrp", $id);
	else
		vrayInvisibleOnGPU($id);
	setUITemplate -ppt;
}
// Updates the connected attribute of a custom control whose visibility depends on whether the current production renderer is GPU.
// $disabledOrInvisible: 0- should disable/dim control for GPU, 1-should make the control invisible for GPU
global proc editorTemplateColorGPUDependentReplace(string $attrLabel, int $showMapButton, int $disabledOrInvisible, string $attrName) {
	string $controlName = vrayMakeNodeAttrControlName($attrName);
	attrColorSliderGrp -e -attribute $attrName $controlName;
	vrayApplyGPUStateToUI();
}
// Used for color controls whose visibility depends on whether the current production renderer is GPU
// $disabledOrInvisible: 0- should disable/dim control for GPU, 1-should make the control invisible for GPU
global proc editorTemplateColorGPUDependent(string $attrName, string $attrLabel, int $showMapButton, int $disabledOrInvisible) {
	editorTemplate -callCustom
		("editorTemplateColorGPUDependentNew \""+$attrLabel+"\" "+$showMapButton+" "+$disabledOrInvisible+" ")
		("editorTemplateColorGPUDependentReplace \""+$attrLabel+"\" "+$showMapButton+" "+$disabledOrInvisible+" ")
		$attrName;
	editorTemplate -suppress $attrName;
}


global proc floatTexNoMapNewCmd( string $attrLabel, string $command, string $attrName ){
	string $buffer[];
	tokenize($attrName, ".", $buffer);
	attrFieldSliderGrp -attribute $attrName -label $attrLabel -hideMapButton true -changeCommand($command + "\"" + $buffer[0] + "\"") `makeControlName($attrName)`;
}
global proc floatTexNoMapReplaceCmd( string $attrLabel, string $command, string $attrName ){
	string $buffer[];
	tokenize($attrName, ".", $buffer);
	attrFieldSliderGrp -e -attribute $attrName -changeCommand($command + "\"" + $buffer[0] + "\"") `makeControlName($attrName)`;
}
global proc editorTemplateFloatNoMapCmd( string $attrName, string $attrLabel, string $command ){
	editorTemplate -callCustom	("floatTexNoMapNewCmd \""    +$attrLabel+"\" \""+$command+"\" ") 
								("floatTexNoMapReplaceCmd \""+$attrLabel+"\" \""+$command+"\" ") $attrName;
	editorTemplate -suppress $attrName;
}

// For colors.
global proc colorTexNoMapNew( string $attrLabel, string $attrName ) {
	attrColorSliderGrp -attribute $attrName -label $attrLabel -showButton false `makeControlName($attrName)`;
	colorTexNoMapReplace($attrLabel, $attrName);
}

global proc colorTexNoMapReplace( string $attrLabel, string $attrName ) {
	string $controlName = `makeControlName($attrName)`;
	attrColorSliderGrp -e -attribute $attrName $controlName;
	
	vrayAddDragCallbackForRenderSetupOverride($controlName, "vrayCommonDragCallback", "");
}

global proc editorTemplateColorNoMap( string $attrName, string $attrLabel ) {
	editorTemplate -callCustom ("colorTexNoMapNew \""+$attrLabel+"\" ") ("colorTexNoMapReplace \""+$attrLabel+"\" ") $attrName;
	editorTemplate -suppress $attrName;
}

// For vectors without map button (we don't support export of mapped vector attribute).
global proc vectorNoMapNew( string $attrLabel, string $attrName ) {
	string $controlName = `makeControlName($attrName)`;
	floatFieldGrp -numberOfFields 3 -label $attrLabel $controlName;
	//indexes in controls start from 1, and 1 is for the text label
	connectControl -index 2 $controlName ($attrName+"0");
	connectControl -index 3 $controlName ($attrName+"1");
	connectControl -index 4 $controlName ($attrName+"2");
}

global proc vectorNoMapReplace( string $attrLabel, string $attrName ) {
	string $controlName = `makeControlName($attrName)`;
	//indexes in controls start from 1, and 1 is for the text label
	connectControl -index 2 $controlName ($attrName+"0");
	connectControl -index 3 $controlName ($attrName+"1");
	connectControl -index 4 $controlName ($attrName+"2");
}

global proc editorTemplateVectorNoMap( string $attrName, string $attrLabel) {
	editorTemplate -callCustom ("vectorNoMapNew \""+$attrLabel+"\" ") ("vectorNoMapReplace \""+$attrLabel+"\" ") $attrName;
	editorTemplate -suppress $attrName;
}

// For navigation controls accepting only connections without a color picker. Suitable for textures/materials
// $nodeTypesFlag - string accepted by the MEL procedure createRenderNode() like "-allWithTexturesUp"/"-allWithShadersUp".
//  It specifies what node types are shown and selected in "Create Render Node" window.
global proc vrayMapNoColorNew(string $attrLabel, string $nodeTypesFlag, string $nodeDotAttr) {
	string $controlName = vrayMakeNodeAttrControlName($nodeDotAttr);
	string $navigationCmd = "defaultNavigation -force true -connectToExisting -source %node -destination ";
	string $createCmdTex = "createRenderNode "+ $nodeTypesFlag +" \"" + $navigationCmd + $nodeDotAttr + "\" \"\"";
	attrNavigationControlGrp -attribute $nodeDotAttr -label $attrLabel -createNew $createCmdTex $controlName;
}
global proc vrayMapNoColorReplace(string $attrLabel, string $nodeTypesFlag, string $nodeDotAttr) {
	string $controlName = vrayMakeNodeAttrControlName($nodeDotAttr);
	string $navigationCmd = "defaultNavigation -force true -connectToExisting -source %node -destination ";
	string $createCmdTex = "createRenderNode " + $nodeTypesFlag + " \"" + $navigationCmd + $nodeDotAttr + "\" \"\"";
	attrNavigationControlGrp -edit -attribute $nodeDotAttr -createNew $createCmdTex $controlName;
}

// For textures without a color selector
global proc vrayTextureNoColorNew(string $attrLabel, string $attrName) {
	vrayMapNoColorNew($attrLabel, "-allWithTexturesUp", $attrName);
}
global proc vrayTextureNoColorReplace(string $attrLabel, string $attrName) {
	vrayMapNoColorReplace($attrLabel, "-allWithTexturesUp", $attrName);
}
global proc vrayEditorTemplateTextureNoColor(string $attrName, string $attrLabel) {
	editorTemplate -callCustom ("vrayTextureNoColorNew \""+$attrLabel+"\" ") ("vrayTextureNoColorReplace \""+$attrLabel+"\" ") $attrName;
	editorTemplate -suppress $attrName;
}

// For material controls without a color selector (accepting only connections)
global proc vrayMaterialNoColorNew(string $attrLabel, string $nodeDotAttr) {
	vrayMapNoColorNew($attrLabel, "-allWithShadersUp", $nodeDotAttr);
}
global proc vrayMaterialNoColorReplace(string $attrLabel, string $nodeDotAttr) {
	vrayMapNoColorReplace($attrLabel, "-allWithShadersUp", $nodeDotAttr);
}
global proc vrayEditorTemplateMaterialNoColor(string $attrName, string $attrLabel) {
	editorTemplate -callCustom
		("vrayMaterialNoColorNew \"" + $attrLabel + "\" ")
		("vrayMaterialNoColorReplace \"" + $attrLabel + "\" ")
		$attrName;
	editorTemplate -suppress $attrName;
}

// For float sliders with a texture connection
global proc vrayFloatTextureNew(string $attrLabel, string $attrName) {
	setUITemplate -pst attributeEditorTemplate;

	string $controlName = makeControlName($attrName);
	string $symbolBtnName = $controlName+"Map";
	string $fLayout = `formLayout -numberOfDivisions 100`;
	attrFieldSliderGrp -attribute $attrName -label $attrLabel $controlName;
	symbolButton -image "navButtonUnconnected.png" $symbolBtnName;
	formLayout -edit
		-attachForm	$controlName	"left"	0
		-attachForm	$controlName	"right"	30
		-attachForm	$symbolBtnName	"right"	10
	$fLayout;
	setParent ..;

	setUITemplate -ppt;
	vrayFloatTextureReplace($attrLabel, $attrName);
}
global proc vrayFloatTextureReplace(string $attrLabel, string $attrName) {
	string $navigationCmd = "defaultNavigation -force true -connectToExisting -source %node -destination " + $attrName;
	string $createCmdTex = "createRenderNode -allWithTexturesUp \"" + $navigationCmd + "\" \"\"";
	string $connections[] = `listConnections -plugs true -source true $attrName`;
	string $imageName = (size($connections) > 0 ? "navButtonConnected.png" : "navButtonUnconnected.png");
	string $controlName = makeControlName($attrName);
	string $symbolBtnName = $controlName+"Map";
	attrFieldSliderGrp -edit -attribute $attrName $controlName;
	symbolButton -edit -image ($imageName)
		-c
		("string $c[] = `listConnections -plugs true -source true "+$attrName+"`; " +
		"if (size($c)>0) showEditor $c[0]; else " + $createCmdTex)
	$symbolBtnName;

	scriptJob -connectionChange $attrName 
	("string $c[] = `listConnections -plugs true -source true "+$attrName+"`; " +
	"symbolButton -edit -image (size($c)>0 ? \"navButtonConnected.png\" : \"navButtonUnconnected.png\") " + $symbolBtnName);
}
global proc vrayEditorTemplateFloatTextureConnection(string $attrName, string $attrLabel) {
	editorTemplate -callCustom ("vrayFloatTextureNew \""+$attrLabel+"\" ") ("vrayFloatTextureReplace \""+$attrLabel+"\" ") $attrName;
	editorTemplate -suppress $attrName;
}

global proc string vrayShaderConnectionDefaultTraversal(string $attrName) {
	string $connectedNodes[] = `listConnections -source true -destination false $attrName`;
	if (size($connectedNodes)==0) return "";
	string $connectedNode = $connectedNodes[0]; // we expect only one input connection
	if (`nodeType $connectedNode` != "VRayMeshShadingGroup") return $connectedNode;

	// Request the input connections again, but this time ask for the whole plug, with the -plugs flag
	string $connectedPlugs[] = `listConnections -source true -destination false -plugs true $attrName`;
	string $connectedPlug = $connectedPlugs[0]; // we expect only one output connection
	string $shaderPlug = substitute(".mesh_connections", $connectedPlug, ".shader_connections");

	string $shader[] = `listConnections -source false -destination true $shaderPlug`;
	if (size($shader)==0) return "";
	return $shader[0]; // we expect only one output connection
}

global proc string vrayCallCreateShaderNode(string $cmd) {
	return "createRenderNode -allWithShadersUp \"" + $cmd + "\" \"\"";
}

// For shaders
global proc vrayShaderConnectionNew(string $attrLabel, string $typeName, string $attrName) {
  string $navigationCmd = "defaultNavigation -force true -connectToExisting -source %node -destination ";
  string $createCmdShader = vrayCallCreateShaderNode($navigationCmd + $attrName);
  string $ctrlName = $typeName + makeControlName($attrName);
  attrNavigationControlGrp 
	-attribute $attrName 
	-label $attrLabel 
	-createNew $createCmdShader 
	-defaultTraversal ("vrayShaderConnectionDefaultTraversal " + $attrName)
	$ctrlName;
}
global proc vrayShaderConnectionReplace(string $attrLabel, string $typeName, string $attrName) {
  string $navigationCmd = "defaultNavigation -force true -connectToExisting -source %node -destination ";
  string $createCmdShader = vrayCallCreateShaderNode($navigationCmd + $attrName);
  
  string $ctrlName = $typeName + makeControlName($attrName);
  attrNavigationControlGrp -edit -defaultTraversal ("vrayShaderConnectionDefaultTraversal " + $attrName) $ctrlName;
  attrNavigationControlGrp -edit 
	-attribute $attrName 
	-label $attrLabel 
	-createNew $createCmdShader 
	$ctrlName;
}
global proc vrayEditorTemplateShaderConnection(string $attrName, string $attrLabel) {
  editorTemplate -callCustom ("vrayShaderConnectionNew \""+$attrLabel+"\" \"\" ") ("vrayShaderConnectionReplace \""+$attrLabel+"\" \"\" ") $attrName;
  editorTemplate -suppress $attrName;
}

// For textures
global proc vrayTextureConnectionNew(string $attrLabel, string $typeName, string $attrName) {
  string $navigationCmd = "defaultNavigation -force true -connectToExisting -source %node -destination ";
  string $createCmdTexture = "createRenderNode -allWithTexturesUp \"" + $navigationCmd + $attrName + "\" \"\"";
  string $ctrlName = $typeName + makeControlName($attrName);
  attrNavigationControlGrp 
	-attribute $attrName 
	-label $attrLabel 
	-createNew $createCmdTexture 
	$ctrlName;
}
global proc vrayTextureConnectionReplace(string $attrLabel, string $typeName, string $attrName) {
  string $navigationCmd = "defaultNavigation -force true -connectToExisting -source %node -destination ";
  string $createCmdTexture = "createRenderNode -allWithTexturesUp \"" + $navigationCmd + $attrName + "\" \"\"";
  
  string $ctrlName = $typeName + makeControlName($attrName);
  attrNavigationControlGrp -edit 
	-attribute $attrName 
	-label $attrLabel 
	-createNew $createCmdTexture 
	$ctrlName;
}
global proc vrayEditorTemplateTextureConnection(string $attrName, string $attrLabel) {
  editorTemplate -callCustom ("vrayTextureConnectionNew \""+$attrLabel+"\" \"\" ") ("vrayTextureConnectionReplace \""+$attrLabel+"\" \"\" ") $attrName;
  editorTemplate -suppress $attrName;
}

// For filenames with browser buttons
// The file browsing functions are based on AEfileTemplate.mel.
global proc AE_VRAY_fileNameNew(string $label, string $ext, int $mode, string $fileAttribute) {
	setUITemplate -pst attributeEditorTemplate;
		rowLayout -nc 3 fileNameLayout;
		text -l $label;
		textField txtField;
		symbolButton -image "navButtonBrowse.xpm" browser;
		setParent ..;
		setUITemplate -ppt;
	AE_VRAY_fileNameReplace($label, $ext, $mode, $fileAttribute);
}
global proc AE_VRAY_fileNameReplace(string $label, string $ext, int $mode, string $fileAttribute) {
	connectControl -fileName txtField $fileAttribute;
	button -e -c ("AE_VRAY_fileBrowser \"" + $fileAttribute + "\"\"" + $label + "\"\"" + $ext + "\" "+$mode) browser;
}
global proc AE_VRAY_fileBrowser(string $fileAttribute, string $label, string $ext, int $mode) {
	global float $g_mayaVersion;
	// If there is a path set in the attribute then use it as starting path in the file browser dialog.
	// If not use the root for the current workspace.
	string $oldFileName=fromNativePath(`getAttr $fileAttribute`);
	string $fileBrowserStartDir = `workspace -q -rootDirectory`;
	if ($oldFileName!="") {
		// Sometimes the path is not absolute, so we need to make it such.
		if (!vrayIsAbsolutePath($oldFileName))
			$oldFileName=`workspace -q -rootDirectory`+"/"+$oldFileName;
		$fileBrowserStartDir = dirname($oldFileName);
	}

	string $filename = vrayBrowseForFileStringWithTitle($ext, $mode, "", $fileBrowserStartDir);
	if ($filename != "") setAttr $fileAttribute -type "string" $filename;
}
global proc vrayEditorTemplateFileBrowser(string $attrLabel, string $attrName, string $ext, int $mode) {
	editorTemplate -callCustom ("AE_VRAY_fileNameNew \""+$attrLabel+"\" \"" + $ext + "\" "+$mode+" ") 
			("AE_VRAY_fileNameReplace \""+$attrLabel+"\" \"" + $ext + "\" "+$mode+ " ") $attrName;
	editorTemplate -suppress $attrName;
}

global proc int vrayAttributeExists(string $node, string $attrName) {
	return (`objExists $node` && `attributeQuery -exists -node $node $attrName`);
}

global proc vrayOnSubdivOverrideEnable(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayOverrideGlobalSubQual"`) {
		int $dim = (! `getAttr ($node + ".vrayOverrideGlobalSubQual")`);

		string $attrNames[] = {"vrayViewDep", "vrayEdgeLength", "vrayMaxSubdivs"};

		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnSubdivUVs(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vraySubdivUVs"`) {
		int $dim = (! `getAttr ($node + ".vraySubdivUVs")`);
		$dim += (! `getAttr ($node + ".vraySubdivEnable")`);

		string $attrNames[] = {"vrayPreserveMapBorders"};

		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnSubdivEnable(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vraySubdivEnable"`) {
		int $dim = (! `getAttr ($node + ".vraySubdivEnable")`);

		string $attrNames[] = {"vrayPreserveMapBorders", "vraySubdivUVs", "vrayStaticSubdiv", "vrayClassicalCatmark", "vrayPreserveGeometryBorders" };

		vrayDimControls($node, $attrNames, $widget, $dim);
		if(!$dim) vrayOnSubdivUVs($node, $attrName, $widget);
	}
}

global proc vrayOnOsdSubdivUVs(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayOsdSubdivUVs"`) {
		int $dim = (! `getAttr ($node + ".vrayOsdSubdivUVs")`);
		$dim += (! `getAttr ($node + ".vrayOsdSubdivEnable")`);

		string $attrNames[] = {"vrayOsdPreserveMapBorders"};

		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}


global proc vrayOnOsdSubdivEnable(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayOsdSubdivEnable"`) {
		int $dim = (! `getAttr ($node + ".vrayOsdSubdivEnable")`);

		string $attrNames[] = {"vrayOsdSubdivType", "vrayOsdSubdivDepth", "vrayOsdSubdivUVs", "vrayOsdPreserveMapBorders", "vrayOsdPreserveGeomBorders" };

		vrayDimControls($node, $attrNames, $widget, $dim);
		if(!$dim) vrayOnOsdSubdivUVs($node, $attrName, $widget);
	}
}

global proc vrayOnEnableDisplacementNone (string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayDisplacementNone"`) {
		int $dim = (`getAttr ($node + ".vrayDisplacementNone")`);

		string $attrNames[] = {
			"vrayDisplacementType", "vrayDisplacementAmount", "vrayDisplacementShift", "vrayDisplacementKeepContinuity",
			"vrayEnableWaterLevel", "vrayWaterLevel", "vray2dDisplacementResolution", "vray2dDisplacementPrecision", "vray2dDisplacementTightBounds",
			"vray2dDisplacementFilterTexture", "vray2dDisplacementFilterBlur", "vray2dDisplacementMultiTile", "vrayDisplacementUseBounds",
			"vrayDisplacementMinValueFloat", "vrayDisplacementMaxValueFloat", "vrayDisplacementStatic"
		};
		vrayDimControls($node, $attrNames, $widget, $dim);

	if (!$dim) {
		vrayOnDisplacementType($node, $attrName, $widget);
		vrayOnEnableWaterLevel($node, $attrName, $widget);
		vrayOnDisplacementUseBounds($node, $attrName, $widget);
		vrayOnDisplacementFilterBlur($node, $attrName, $widget);
		}
	}
}

proc int vrayGetDisplacementNone(string $node) {
	int $none=0;
	if (vrayAttributeExists($node, "vrayDisplacementNone"))
		$none=(`getAttr ($node + ".vrayDisplacementNone")`)!=0;
	return $none;
}

global proc vrayOnDisplacementType(string $node, string $attrName, string $widget) {
  if (vrayAttributeExists($node, "vrayDisplacementType")) {
    int $dim1 = (`getAttr ($node+".vrayDisplacementType")`!=0);
    int $none=vrayGetDisplacementNone($node);
    
    $dim1 +=$none;
    int $dim2 = (`getAttr ($node+".vrayDisplacementType")`==0);
    $dim2 += !$none;

    if (vrayAttributeExists($node, "vray2dDisplacementResolution")) {
      string $attrNames[] = {"vray2dDisplacementResolution", "vray2dDisplacementPrecision", "vray2dDisplacementTightBounds", "vray2dDisplacementMultiTile"};
      vrayDimControls($node, $attrNames, $widget, $dim1);
    }

    if (vrayAttributeExists($node, "vrayDisplacementKeepContinuity")) {
      string $attrNames2[] = {"vrayDisplacementKeepContinuity"};
      vrayDimControls($node, $attrNames2, $widget, !$dim2);
    }
   
  }

  vrayOnDisplacementUseBounds($node, $attrName, $widget);
}

global proc vrayOnDisplacementFilterBlur(string $node, string $attrName, string $widget) {
  if (vrayAttributeExists($node, "vray2dDisplacementFilterTexture"))
  {
    int $dimBlur = (!`getAttr ($node+".vray2dDisplacementFilterTexture")`);
    $dimBlur += vrayGetDisplacementNone($node);
    string $attrNames[] = {"vray2dDisplacementFilterBlur"};
    vrayDimControls($node, $attrNames, $widget, $dimBlur);
  }
}

global proc vrayOnEnableWaterLevel(string $node, string $attrName, string $widget) {
  if (`attributeQuery -exists -node $node "vrayEnableWaterLevel"`) {
		int $dim = (! `getAttr ($node + ".vrayEnableWaterLevel")`);
		$dim += vrayGetDisplacementNone($node);

		string $attrNames[] = {"vrayWaterLevel"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnDisplacementUseBounds(string $node, string $attrName, string $widget) {
  if (vrayAttributeExists($node, "vrayDisplacementType") && vrayAttributeExists($node, "vrayDisplacementUseBounds")) {
    int $dim = (! `getAttr ($node + ".vrayDisplacementUseBounds")`);
    int $dimType = (`getAttr ($node+".vrayDisplacementType")`==0);
    $dimType += vrayGetDisplacementNone($node);;

    string $attrNames[] = { "vrayDisplacementUseBounds" };
    vrayDimControls($node, $attrNames, $widget, $dimType);

    string $attrNames2[] = { "vrayDisplacementMinValueFloat", "vrayDisplacementMaxValueFloat" };
    vrayDimControls($node, $attrNames2, $widget, $dim || $dimType);
  }
}

global proc vrayOnDisplacementBoundsMinChange(string $node, string $attrName, string $widget) {
	// If the old, deprecated attribute exists, the new one will set its new value in it
	if (vrayAttributeExists($node, "vrayDisplacementMinValueFloat") && vrayAttributeExists($node, "vrayDisplacementMinValue")) {
		 float $newVal = `getAttr ($node + ".vrayDisplacementMinValueFloat")`;
		 setAttr ($node + ".vrayDisplacementMinValue") -type float3 $newVal $newVal $newVal;
	}
}

global proc vrayOnDisplacementBoundsMinCreated(string $node, string $attrName, string $widget) {
	// If old attribute exists, initialize the new attribute with the old value for compatibility
	if (vrayAttributeExists($node, "vrayDisplacementMinValue")) {
		float $a[] =  `getAttr "vrayDisplacement.vrayDisplacementMinValue"`;
		float $minVal = min( $a[2], min ($a[0], $a[1]));
		setAttr ($node + ".vrayDisplacementMinValueFloat") $minVal;
	}
}

global proc vrayOnDisplacementBoundsMaxChange(string $node, string $attrName, string $widget) {
	// If the old, deprecated attribute exists, the new one will set its new value in it
	if (vrayAttributeExists($node, "vrayDisplacementMaxValueFloat") && vrayAttributeExists($node, "vrayDisplacementMaxValue")) {
		 float $newVal = `getAttr ($node + ".vrayDisplacementMaxValueFloat")`;
		 setAttr ($node + ".vrayDisplacementMaxValue") -type float3 $newVal $newVal $newVal;
	}
}

global proc vrayOnDisplacementBoundsMaxCreated(string $node, string $attrName, string $widget) {
	// If old attribute exists, initialize the new attribute with the old value for compatibility
	if (vrayAttributeExists($node, "vrayDisplacementMaxValue")) {
		float $a[] =  `getAttr "vrayDisplacement.vrayDisplacementMaxValue"`;
		float $maxVal = max( $a[2], max ($a[0], $a[1]));
		setAttr ($node + ".vrayDisplacementMaxValueFloat") $maxVal;
	}
}
 
global proc vrayOnEnableRoundEdges(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayRoundEdges"`) {
		int $dim = (! `getAttr ($node + ".vrayRoundEdges")`);
		string $attrNames[] = {"vrayRoundEdgesRadius", "vrayRoundEdgesConsiderSameObjectsOnly", "vrayRoundEdgesCorners"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnOverrideGlossiness(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayOverride"`) {
		int $dim = (! `getAttr ($node + ".vrayOverride")`);

		string $attrNames[] = {"vrayReflectionGlossiness"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnCameraDomeOn(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayCameraDomeOn"`) {
		int $dim = (! `getAttr ($node + ".vrayCameraDomeOn")`);
		if ($dim == 0) {
			// disable the physical camera
			if (`attributeQuery -exists -node $node "vrayCameraPhysicalOn"` && `getAttr ($node + ".vrayCameraPhysicalOn")`) {
				setAttr ($node + ".vrayCameraPhysicalOn") false;
				string $tmpWidget = tokenizeWidget(tokenizeWidget($widget));
				vrayOnCameraPhysicalOn($node, $attrName, $tmpWidget + "vray_cameraPhysical_camera|dummy");
			}
			// disable the DomemasterStereo camera
			if (`attributeQuery -exists -node $node "vrayDomemasterStereoOn"` && `getAttr ($node + ".vrayDomemasterStereoOn")`) {
				setAttr ($node + ".vrayDomemasterStereoOn") false;
				string $tmpWidget = tokenizeWidget(tokenizeWidget($widget));
				vrayOnLatLongStereoOn($node, $attrName, $tmpWidget + "vray_DomemasterStereo_camera|dummy");
			}
			// disable the LatlongStereo camera
			if (`attributeQuery -exists -node $node "vrayLatLongStereoOn"` && `getAttr ($node + ".vrayLatLongStereoOn")`) {
				setAttr ($node + ".vrayLatLongStereoOn") false;
				string $tmpWidget = tokenizeWidget(tokenizeWidget($widget));
				vrayOnLatLongStereoOn($node, $attrName, $tmpWidget + "vray_LatLongStereo_camera|dummy");
			}
		}
		string $attrNames[] = {"vrayCameraDomeFlipX", "vrayCameraDomeFlipY", "vrayCameraDomeFov" };
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

// returns true for cameras part of a (maya/vray) stereo rig
proc int isPartOfStereoRig(string $node) {
    if(attributeExists("vrayStereoRigCameraCenter", $node) || attributeExists("vrayStereoRigCameraLeft", $node) || attributeExists("vrayStereoRigCameraRight", $node))
        return 1;
    return `nodeType -api $node` == "kStereoCameraMaster";
}

// callback for the vrayCameraStereoscopicView attribute - controls get dimmed depending on this
global proc vrayOnCameraStereoscopicView(string $node, string $attrName, string $widget) {
    if(`attributeQuery -exists -node $node "vrayCameraStereoscopicView"`) {
        int $stereoEnabled = `getAttr ($node + ".vrayCameraStereoscopicOn")`;
        if($stereoEnabled) {
            int $state = `getAttr ($node + ".vrayCameraStereoscopicView")`;
            if(!isPartOfStereoRig($node))
                vrayDimControls($node, {"vrayCameraStereoscopicInterocularMethod"}, $widget, $state == 3);
            vrayDimControls($node, {"vrayCameraStereoscopicOutputLayout", "vrayCameraStereoscopicAdjustResolution"}, $widget, !($state == 0));
        }
    }
}

// callback for the vrayCameraStereoscopicOn attribute - controls get dimmed depending on this
global proc vrayOnCameraStereoscopicOn(string $node, string $attrName, string $widget) {
    if(`attributeQuery -exists -node $node "vrayCameraStereoscopicOn"`) {
        int $dim = (! `getAttr ($node + ".vrayCameraStereoscopicOn")`);
        string $attrNames[] = {"vrayCameraStereoscopicEyeDistance", "vrayCameraStereoscopicSpecifyFocus", "vrayCameraStereoscopicFocusDistance", 
                               "vrayCameraStereoscopicFocusMethod", "vrayCameraStereoscopicInterocularMethod", "vrayCameraStereoscopicView",
							   "vrayCameraStereoscopicOutputLayout", "vrayCameraStereoscopicAdjustResolution", "vrayCameraStereoscopicTopMergeAngle",
							   "vrayCameraStereoscopicBottomMergeAngle"};
        vrayDimControls($node, $attrNames, $widget, $dim);
        if ($dim == 0) {
            if(isPartOfStereoRig($node)) {
                // always dim these controlls for stereo cameras because they make no sense on a stereo rig
                $attrNames = {"vrayCameraStereoscopicEyeDistance", "vrayCameraStereoscopicSpecifyFocus", "vrayCameraStereoscopicFocusDistance", 
                              "vrayCameraStereoscopicFocusMethod", "vrayCameraStereoscopicInterocularMethod", 
                              "vrayCameraStereoscopicTopMergeAngle", "vrayCameraStereoscopicBottomMergeAngle"};
                vrayDimControls($node, $attrNames, $widget, 1);
            } else {
                // Here $widget is not the one corresponding to the attribute, but they have the same parent, which is enough.
                vrayOnCameraStereoscopicSpecifyFocus($node, $attrName, $widget);
            }
        }
		vrayCreateVRaySettingsNode();	// create vraySettings if needed before modifying its attributes
        setAttr "vraySettings.rt_stereoVisionEnable" (!$dim);
    }
}

global proc vrayOnCameraStereoscopicEyeDistance(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayCameraStereoscopicEyeDistance"`) {
		float $eyeDistance = `getAttr ($node + ".vrayCameraStereoscopicEyeDistance")`;
		setAttr "vraySettings.rt_eyeDistance" $eyeDistance;
	}
}

// callback for the vrayCameraStereoscopicSpecifyFocus attribute (dropdown)
global proc vrayOnCameraStereoscopicSpecifyFocus(string $node, string $attrName, string $widget) {
    if (`attributeQuery -exists -node $node "vrayCameraStereoscopicSpecifyFocus"`) {
        int $dim = (! `getAttr ($node + ".vrayCameraStereoscopicSpecifyFocus")`);
        $dim += (! `getAttr ($node + ".vrayCameraStereoscopicOn")`);

        string $attrNames[] = {"vrayCameraStereoscopicFocusDistance"};
        vrayDimControls($node, $attrNames, $widget, $dim);
    }
}

global proc vrayOnCameraPhysicalOn(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayCameraPhysicalOn"`) {
		int $dim = (! `getAttr ($node + ".vrayCameraPhysicalOn")`);
		string $attrNames[] = {"vrayCameraPhysicalType", "vrayCameraPhysicalFilmWidth", "vrayCameraPhysicalFocalLength", 
								"vrayCameraPhysicalZoomFactor", "vrayCameraPhysicalDistortionType", "vrayCameraPhysicalDistortion", 
								"vrayCameraPhysicalLensFile", "vrayCameraPhysicalDistortionMap", "vrayCameraPhysicalFNumber", "vrayCameraPhysicalLensShift", 
								"vrayCameraPhysicalHorizLensShift", "vrayCameraPhysicalLensAutoVShift",
								"vrayCameraPhysicalShutterSpeed", "vrayCameraPhysicalShutterAngle", "vrayCameraPhysicalShutterOffset", 
								"vrayCameraPhysicalLatency", "vrayCameraPhysicalISO", "vrayCameraPhysicalSpecifyFocus", "vrayCameraPhysicalFocusDistance", 
								"vrayCameraPhysicalExposure", "vrayCameraPhysicalWhiteBalance", "vrayCameraPhysicalVignetting", 
								"vrayCameraPhysicalVignettingAmount", "vrayCameraPhysicalBladesEnable", "vrayCameraPhysicalBladesNum", 
								"vrayCameraPhysicalBladesRotation", "vrayCameraPhysicalCenterBias", "vrayCameraPhysicalAnisotropy", 
								"vrayCameraPhysicalUseDof", "vrayCameraPhysicalUseMoBlur",
								"vrayCameraPhysicalSpecifyFOV", "vrayCameraPhysicalFOV",
								"vrayCameraPhysicalApertureMap", "vrayCameraPhysicalApertureMapAffectsExposure",
								"vrayCameraPhysicalOpticalVignetting",
								"vrayCameraPhysicalRollingShutterMode", "vrayCameraPhysicalRollingShutterDuration"};
		vrayDimControls($node, $attrNames, $widget, $dim);
		if ($dim == 0) {
			// Here $widget is not the one corresponding to the attribute, but they have the same parent, which is enough.
			vrayOnCameraPhysicalType($node, $attrName, $widget);
			vrayOnCameraPhysicalSpecifyFocus($node, $attrName, $widget);
			vrayOnCameraPhysicalBladesEnable($node, $attrName, $widget);
			vrayOnCameraPhysicalDistortionType($node, $attrName, $widget);
			vrayOnCameraPhysicalSpecifyFOV($node, $attrName, $widget);
			vrayOnCameraPhysicalUseMoBlur($node, $attrName, $widget);
			vrayOnCameraPhysicalExposure($node, $attrName, $widget);
			
			// disable the dome camera
			if (`attributeQuery -exists -node $node "vrayCameraDomeOn"` && `getAttr ($node + ".vrayCameraDomeOn")`) {
				setAttr ($node + ".vrayCameraDomeOn") false;
				string $tmpWidget = tokenizeWidget(tokenizeWidget($widget));
				vrayOnCameraDomeOn($node, $attrName, $tmpWidget + "vray_cameraDome_camera|dummy");
			}
			// disable the DomemasterStereo camera
			if (`attributeQuery -exists -node $node "vrayDomemasterStereoOn"` && `getAttr ($node + ".vrayDomemasterStereoOn")`) {
				setAttr ($node + ".vrayDomemasterStereoOn") false;
				string $tmpWidget = tokenizeWidget(tokenizeWidget($widget));
				vrayOnLatLongStereoOn($node, $attrName, $tmpWidget + "vray_DomemasterStereo_camera|dummy");
			}
			// disable the LatlongStereo camera
			if (`attributeQuery -exists -node $node "vrayLatLongStereoOn"` && `getAttr ($node + ".vrayLatLongStereoOn")`) {
				setAttr ($node + ".vrayLatLongStereoOn") false;
				string $tmpWidget = tokenizeWidget(tokenizeWidget($widget));
				vrayOnLatLongStereoOn($node, $attrName, $tmpWidget + "vray_LatLongStereo_camera|dummy");
			}
		}
		if (`connectionInfo -isDestination ($node + ".focalLength")`) {
			string $attrNames2[] = {"vrayCameraPhysicalFilmWidth", "vrayCameraPhysicalFocalLength", "vrayCameraPhysicalSpecifyFOV", "vrayCameraPhysicalFOV" };
			vrayDimControls($node, $attrNames2, $widget, 1);
		}
	}
}

global proc vrayOnCameraPhysicalType(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayCameraPhysicalOn"` && `getAttr ($node + ".vrayCameraPhysicalOn")` &&
	`attributeQuery -exists -node $node "vrayCameraPhysicalType"`) 	{
		int $cameraType = `getAttr ($node + ".vrayCameraPhysicalType")`; 
		vrayDimControls($node, {"vrayCameraPhysicalShutterSpeed"}, $widget, $cameraType != 0);
		vrayDimControls($node, {"vrayCameraPhysicalShutterAngle", "vrayCameraPhysicalShutterOffset"}, $widget, $cameraType != 1);
		vrayDimControls($node, {"vrayCameraPhysicalLatency"}, $widget, $cameraType != 2);
	}
}

global proc vrayOnCameraPhysicalDistortionType(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayCameraPhysicalOn"` && `getAttr ($node + ".vrayCameraPhysicalOn")` &&
	     `attributeQuery -exists -node $node "vrayCameraPhysicalDistortionType"`) {
		int $distortionType = `getAttr ($node + ".vrayCameraPhysicalDistortionType")`;
		vrayDimControls($node, {"vrayCameraPhysicalDistortion"}, $widget, $distortionType != 0 && $distortionType != 1);
		vrayDimControls($node, {"vrayCameraPhysicalLensFile"}, $widget, $distortionType != 2);
		vrayDimControls($node, {"vrayCameraPhysicalDistortionMap"}, $widget, $distortionType != 3);
	}
}

global proc vrayOnCameraPhysicalSpecifyFocus(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayCameraPhysicalSpecifyFocus"`) {
		int $dim = (! `getAttr ($node + ".vrayCameraPhysicalSpecifyFocus")`);
		$dim += (! `getAttr ($node + ".vrayCameraPhysicalOn")`);

		string $attrNames[] = {"vrayCameraPhysicalFocusDistance"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnCameraPhysicalSpecifyFOV(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayCameraPhysicalSpecifyFOV"`) {
		if (!`connectionInfo -isDestination ($node + ".focalLength")`) {
			int $camPhysicalOn = (`getAttr ($node + ".vrayCameraPhysicalOn")`);
			int $FOVType = (`getAttr ($node + ".vrayCameraPhysicalSpecifyFOV")`);
			vrayDimControls($node, {"vrayCameraPhysicalFOV"}, $widget, !($FOVType == 1 && $camPhysicalOn));
			vrayDimControls($node, {"vrayCameraPhysicalFocalLength"}, $widget, !($FOVType == 0 && $camPhysicalOn));
		} else {
			vrayDimControls($node, {"vrayCameraPhysicalFOV"}, $widget, 1);
			vrayDimControls($node, {"vrayCameraPhysicalFocalLength"}, $widget, 1);
		}
	}
}

global proc vrayOnCameraPhysicalVignetting(string $node, string $attrName, string $widget) {
  if (`attributeQuery -exists -node $node "vrayCameraPhysicalVignetting"` && `getAttr ($node + ".vrayCameraPhysicalOn")`) {
    int $dim = (! `getAttr ($node + ".vrayCameraPhysicalVignetting")`);
    string $attrNames[] = {"vrayCameraPhysicalVignettingAmount"};
    vrayDimControls($node, $attrNames, $widget, $dim);
  }
}

global proc vrayOnCameraPhysicalExposure(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayCameraPhysicalExposure"`) {
		int $exposureMode = `getAttr ($node + ".vrayCameraPhysicalExposure")`;
		int $dimWhiteBalance = (!$exposureMode);
		int $dimExposureValue = ($exposureMode!=2);
		int $dimISO = ($exposureMode!=1);
		if (! `getAttr ($node + ".vrayCameraPhysicalOn")`) {
			$dimWhiteBalance=$dimExposureValue=$dimISO=true;
		}

		string $attrNames[] = {"vrayCameraPhysicalWhiteBalance"};
		vrayDimControls($node, $attrNames, $widget, $dimWhiteBalance);
		$attrNames[0] = "vrayCameraPhysicalExposureValue";
		vrayDimControls($node, $attrNames, $widget, $dimExposureValue);
		$attrNames[0] = "vrayCameraPhysicalISO";
		vrayDimControls($node, $attrNames, $widget, $dimISO);
	}
}

global proc vrayOnCameraPhysicalBladesEnable(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayCameraPhysicalBladesEnable"`) {
		int $dim = (! `getAttr ($node + ".vrayCameraPhysicalBladesEnable")`);
		$dim += (! `getAttr ($node + ".vrayCameraPhysicalOn")`);

		string $attrNames[] = {"vrayCameraPhysicalBladesNum", "vrayCameraPhysicalBladesRotation"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnCameraPhysicalAutoVShift(string $node, string $attrName) {
    if (`attributeQuery -exists -node $node "vrayCameraPhysicalLensShift"`) {
        float $shift=`vray physicalCameraAutoShift $node`;
        setAttr ($node+".vrayCameraPhysicalLensShift") $shift;
    }
}

global proc vrayOnCameraPhysicalUseMoBlur(string $node, string $attrName, string $widget) {
    if (`attributeQuery -exists -node $node "vrayCameraPhysicalUseMoBlur"`) {
		int $dim = (! `getAttr ($node + ".vrayCameraPhysicalUseMoBlur")`);
		$dim += (! `getAttr ($node + ".vrayCameraPhysicalOn")`);

		string $attrNames[] = {"vrayCameraPhysicalRollingShutterMode", "vrayCameraPhysicalRollingShutterDuration"};
		vrayDimControls($node, $attrNames, $widget, $dim);

		if ($dim == 0) {
			vrayOnCameraPhysicalRollingShutterMode($node, $attrName, $widget);
		}
    }
}

global proc vrayOnCameraPhysicalRollingShutterMode(string $node, string $attrName, string $widget) {
    if (`attributeQuery -exists -node $node "vrayCameraPhysicalRollingShutterMode"` &&
			`attributeQuery -exists -node $node "vrayCameraPhysicalUseMoBlur"`) {
		int $dim = (! `getAttr ($node + ".vrayCameraPhysicalRollingShutterMode")`);
		$dim += (! `getAttr ($node + ".vrayCameraPhysicalUseMoBlur")`);
		$dim += (! `getAttr ($node + ".vrayCameraPhysicalOn")`);

		string $attrNames[] = {"vrayCameraPhysicalRollingShutterDuration"};
		vrayDimControls($node, $attrNames, $widget, $dim);
    }
}

global proc vrayOnCameraOverridesOn(string $node, string $attrName, string $widget) {
  int $off = !(`getAttr ($node + ".vrayCameraOverridesOn")`);
  string $attrNamesList[] = {"vrayCameraType", "vrayCameraOverrideFOV", "vrayCameraFOV", 
    "vrayCameraHeight", "vrayCameraVerticalFOV", "vrayCameraAutoFit", "vrayCameraDist", "vrayCameraCurve"};
  vrayDimControls($node, $attrNamesList, $widget, $off);
  if (!$off) {
    vrayOnCameraType($node, $attrName, $widget);
    vrayOnCameraOverrideFOV($node, $attrName, $widget);
  }
}

global proc vrayOnCameraType(string $node, string $attrName, string $widget) {
  if (`attributeQuery -exists -node $node "vrayCameraType"`) {
    int $type = `getAttr ($node + ".vrayCameraType")`;
    
    // FOV cannot be overridden for "box" and "cube 6x1"
    int $dimOverrideFOV = ($type == 4) || ($type == 10);
    vrayDimControls($node, {"vrayCameraOverrideFOV"}, $widget, $dimOverrideFOV);
    vrayOnCameraOverrideFOV($node, $attrName, $widget);
    if($dimOverrideFOV) vrayDimControls($node, {"vrayCameraFOV"}, $widget, $dimOverrideFOV);

    int $dimHeight = !($type == 3);
    string $attrNamesHeight[] = {"vrayCameraHeight"};
    vrayDimControls($node, $attrNamesHeight, $widget, $dimHeight);
    
    int $dimFish = !($type == 5 || $type == 6);
    $dimFish += !(`getAttr ($node + ".vrayCameraOverridesOn")`);
    string $attrNamesFish[] = {"vrayCameraAutoFit", "vrayCameraCurve"};
    vrayDimControls($node, $attrNamesFish, $widget, $dimFish);
    
    int $dimVerticalFov = !($type == 9);
    string $attrNamesVerticalFov[] = {"vrayCameraVerticalFOV"};
    vrayDimControls($node, $attrNamesVerticalFov, $widget, $dimVerticalFov);
    
    int $dimDist = ($dimFish || (`getAttr ($node + ".vrayCameraAutoFit")`));
    $dimDist += !(`getAttr ($node + ".vrayCameraOverridesOn")`);

    string $attrNamesDist[] = {"vrayCameraDist"};
    vrayDimControls($node, $attrNamesDist, $widget, $dimDist);
  }
}

global proc vrayOnCameraOverrideFOV(string $node, string $attrName, string $widget) {
  if (`attributeQuery -exists -node $node "vrayCameraOverrideFOV"`) {
    int $dim = !(`getAttr ($node + ".vrayCameraOverrideFOV")`);
    $dim += !(`getAttr ($node + ".vrayCameraOverridesOn")`);
    string $attrNames[] = {"vrayCameraFOV"};
    vrayDimControls($node, $attrNames, $widget, $dim);
  }
}

global proc vrayOnDepthFromCameraZDepthRE(string $node, string $attrName, string $widget) {
  if (`attributeQuery -exists -node $node "vray_depthFromCamera_zdepth"`) {
    int $dim = `getAttr ($node + ".vray_depthFromCamera_zdepth")`;
    string $attrNames[] = { "vray_depthBlack", "vray_depthWhite" };
    vrayDimControls($node, $attrNames, $widget, $dim);
  }
}

global proc vrayOnFilteringZDepthRE(string $node, string $attrName, string $widget) {
  if (`attributeQuery -exists -node $node "vray_filtering_zdepth"`) {
    int $dim = !(`getAttr ($node + ".vray_filtering_zdepth")`);
    string $attrNames[] = { "vray_dontFilterEnv_zdepth" };
    vrayDimControls($node, $attrNames, $widget, $dim);
  }
}

global proc vrayOnLightOverrideMBSamples(string $node, string $attrName, string $widget) {
  if (`attributeQuery -exists -node $node "vrayOverrideMBSamples"`) {
    int $dim = !(`getAttr ($node + ".vrayOverrideMBSamples")`);
    string $attrNames[] = {"vrayMBSamples"};
    vrayDimControls($node, $attrNames, $widget, $dim);
  }
}

global proc vrayOnBifrostExportPart(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayBifrostExportPart"`) {
		int $dim = !getAttr ($node + ".vrayBifrostExportPart");
		string $attrNames[] = {"vrayBifrostExportDens"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnFileGammaEnable(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayFileGammaEnable"`) {
		int $dim = !(`getAttr ($node + ".vrayFileGammaEnable")`);
		string $attrNames[] = {"vrayFileColorSpace"};
		vrayDimControls($node, $attrNames, $widget, $dim);
		vrayOnFileColorSpace($node, $attrName, $widget);
	}
}

global proc vrayOnFileColorSpace(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayFileGammaEnable"` && `attributeQuery -exists -node $node "vrayFileColorSpace"`) {
		int $dim = !getAttr ($node + ".vrayFileGammaEnable") || getAttr ($node + ".vrayFileColorSpace") != 1;
		string $attrNames[] = {"vrayFileGammaValue"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnOverrideTextureFilter(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayOverrideTextureFilter"`) {
		int $dim = !(`getAttr ($node + ".vrayOverrideTextureFilter")`);
		string $attrNames[] = { "vrayTextureFilter", "vrayTextureSmoothType" };
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
	vrayOnTextureFilter($node, $attrName, $widget);
}

global proc vrayOnTextureFilter(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayOverrideTextureFilter"` && `attributeQuery -exists -node $node "vrayTextureFilter"`) {
		int $filterType = getAttr ($node + ".vrayTextureFilter");
		int $smoothFilter = $filterType==0 || $filterType==1;
		int $dim = !(`getAttr ($node + ".vrayOverrideTextureFilter")`) || !$smoothFilter;
		string $attrNames[] = { "vrayTextureSmoothType" };
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnOverrideTextureFormat(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayOverrideTextureFormat"`) {
		int $dim = !(`getAttr ($node + ".vrayOverrideTextureFormat")`);
		string $attrNames[] = {"vrayTextureFormat"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnEnableAllOverrides(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayEnableAllOverrides"`) {
		int $dim = !(`getAttr ($node + ".vrayEnableAllOverrides")`);

		string $attrNames[] = {"vrayEnableSpecificSurfaceShader", "vraySpecificSurfaceShader", "vrayEnableGIMaterial", "vrayGIMaterial", "vrayEnableReflectMaterial", "vrayReflectMaterial", "vrayEnableRefractMaterial", "vrayRefractMaterial", "vrayEnableShadowMaterial", "vrayShadowMaterial", "vrayEnableEnvironmentOverride", "vrayMtlEnvironmentOverride", "vrayMtlEnvironmentPriority"};
		vrayDimControls($node, $attrNames, $widget, $dim);

		if ($dim == 0) {
			vrayOnEnableSpecificSurfaceShader($node, $attrName, $widget);
			vrayOnEnableGIMaterial($node, $attrName, $widget);
			vrayOnEnableReflectMaterial($node, $attrName, $widget);
			vrayOnEnableRefractMaterial($node, $attrName, $widget);
			vrayOnEnableShadowMaterial($node, $attrName, $widget);
			vrayOnEnableEnvironmentOverride($node, $attrName, $widget);
		}
	}
}

global proc vrayOnEnableSpecificSurfaceShader(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayEnableSpecificSurfaceShader"`) {
		int $dim = !(`getAttr ($node + ".vrayEnableSpecificSurfaceShader")`);
		$dim += (! `getAttr ($node + ".vrayEnableAllOverrides")`);

		string $attrNames[] = {"vraySpecificSurfaceShader"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnEnableGIMaterial(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayEnableGIMaterial"`) {
		int $dim = !(`getAttr ($node + ".vrayEnableGIMaterial")`);
		$dim += (! `getAttr ($node + ".vrayEnableAllOverrides")`);

		string $attrNames[] = {"vrayGIMaterial"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnEnableReflectMaterial(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayEnableReflectMaterial"`) {
		int $dim = !(`getAttr ($node + ".vrayEnableReflectMaterial")`);
		$dim += (! `getAttr ($node + ".vrayEnableAllOverrides")`);

		string $attrNames[] = {"vrayReflectMaterial"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnEnableRefractMaterial(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayEnableRefractMaterial"`) {
		int $dim = !(`getAttr ($node + ".vrayEnableRefractMaterial")`);
		$dim += (! `getAttr ($node + ".vrayEnableAllOverrides")`);

		string $attrNames[] = {"vrayRefractMaterial"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnEnableShadowMaterial(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayEnableShadowMaterial"`) {
		int $dim = !(`getAttr ($node + ".vrayEnableShadowMaterial")`);
		$dim += (! `getAttr ($node + ".vrayEnableAllOverrides")`);

		string $attrNames[] = {"vrayShadowMaterial"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnEnableEnvironmentOverride(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayEnableEnvironmentOverride"`) {
		int $dim = !(`getAttr ($node + ".vrayEnableEnvironmentOverride")`);
		$dim += (! `getAttr ($node + ".vrayEnableAllOverrides")`);

		string $attrNames[] = {"vrayMtlEnvironmentOverride", "vrayMtlEnvironmentPriority"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayAddMtlEnvironmentOverride(string $node, string $attrName) {
	string $nodeDotAttr = ($node+"."+$attrName);
	int $jobId = `scriptJob -killWithScene -connectionChange $nodeDotAttr ("vrayCreatePlaceEnvTex(\""+$nodeDotAttr+"\", 2, 0, 1)")`;
	scriptJob -runOnce true -killWithScene -attributeDeleted $nodeDotAttr ("scriptJob -kill " + $jobId);
}

global proc vrayOnNurbsCurveLockEndWidth(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayNurbsCurveRenderable"` && `attributeQuery -exists -node $node "vrayNurbsCurveLockEndWidth"`) {
		int $dim = (! `getAttr ($node + ".vrayNurbsCurveRenderable")`) || (`getAttr ($node + ".vrayNurbsCurveLockEndWidth")`);
		string $attrNames[] = {"vrayNurbsCurveEndWidth"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

global proc vrayOnNurbsCurveRenderable(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayNurbsCurveRenderable"`) {
		int $dim = (! `getAttr ($node + ".vrayNurbsCurveRenderable")`);

		string $attrNames[] = {"vrayNurbsCurveMaterial", "vrayNurbsCurveTesselation", "vrayNurbsCurveStartWidth", "vrayNurbsCurveEndWidth", "vrayNurbsCurveLockEndWidth"};
		vrayDimControls($node, $attrNames, $widget, $dim);
		
		if (!$dim)
			vrayOnNurbsCurveLockEndWidth($node, $attrName, $widget);
	}
}

// This procedure updates the dim state of the extra attributes in Maya Fluids
// When Enable Rendering is disabled, Light Power on Self should be dimmed
// Light Power on Self also depends on Create Fire Lights, i.e. vrayFluidAlEnable
global proc vrayOnFluidRenderChanged(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayFluidRender"` 
		&& `attributeQuery -exists -node $node "vrayFluidAlEnable"` 
		&& `attributeQuery -exists -node $node "vrayFluidShader"`
		) {
		int $type = ( `getAttr ($node + ".vrayFluidShader")`);
		int $dim = (! `getAttr ($node + ".vrayFluidRender")`) || (! `getAttr ($node + ".vrayFluidAlEnable")` || ($type == 2));
		string $attrNames[] = {"vrayFluidLightsMultSelf"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

// This procedure updates the dim state of the extra attributes in Maya Fluids
// When Create Fire Lights is disabled, the related controls should be dimmed
global proc vrayOnFluidAlEnableChanged(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayFluidAlEnable"` 
		&& `attributeQuery -exists -node $node "vrayFluidShader"`
		) {
		int $type = ( `getAttr ($node + ".vrayFluidShader")`);
		int $dim = (! `getAttr ($node + ".vrayFluidAlEnable")`) || ($type == 2);
		string $attrNames[] = {"vrayFluidLightsMult", "vrayFluidSelfShadow", "vrayFluidGridReduct", 
								"vrayFluidLightsCut", "vrayFluidPersistLights"};
		vrayDimControls($node, $attrNames, $widget, $dim);
		// Update the Light Power on Self control, i.e. vrayFluidLightsMultSelf
		// Light Power on Self also depends on Enable Rendering, i.e. vrayFluidRender
		vrayOnFluidRenderChanged($node, $attrName, $widget);
	}
}
// Called when creating the fluid shader control
global proc vrayOnFluidShaderCreated(string $node, string $attrName, string $widget) {
	if (!`attributeQuery -exists -node $node "vrayFluidShader"`)
		return;
	int $type = (`getAttr ($node + ".vrayFluidShader")`);
	// value Auto(0) was removed from UI so convert it to Phoenix(1)
	if ($type==0)
		setAttr ($node + ".vrayFluidShader") 1;
}
// This procedure updates the dim state of the extra attributes in Maya Fluids
// When the Volume Shader is not Phoenix, the Create Fire Lights controls should be dimmed
global proc vrayOnFluidShaderChanged(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayFluidShader"`) {
		int $type = ( `getAttr ($node + ".vrayFluidShader")`);
		int $dim = ($type == 2); // Volume Shader is Environment Fog
		string $attrNames[] = {"vrayFluidRender", "vrayFluidAlEnable", "vrayFluidLightsMult",
								"vrayFluidLightsMultSelf", "vrayFluidSelfShadow", "vrayFluidGridReduct",
								"vrayFluidLightsCut", "vrayFluidPersistLights"};
		vrayDimControls($node, $attrNames, $widget, $dim);
		// When $type != 2 update the rest of the controls
		if ($dim == 0) {
			vrayOnFluidAlEnableChanged($node, $attrName, $widget);
		}
	}
}

global proc vrayOnFluidScatterGIChanged(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayFluidScatterGI"`) {
		int $dim = !`getAttr ($node + ".vrayFluidScatterGI")`;

		string $attrNames[] = {"vrayFluidScatterBounces"};
		vrayDimControls($node, $attrNames, $widget, $dim);
	}
}

//this procedure is used to update controls in Extra Texture render element.
//it has 3 type of textures int/float/color and only one can be used at a time
global proc vrayOnExtraTexTypeChanged(string $nodeName, string $attrName, string $ctrl) {
	if (`attributeQuery -exists -node $nodeName "vray_type_extratex"`) {
		// texType represents the type of texture
		//0 for texture, 1 - float texture and 2 for int texture
		int $texType = `getAttr ($nodeName + ".vray_type_extratex")`;
		string $attrNames[] = {"vray_texture_extratex"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($texType != 0));
		$attrNames = {"vray_float_texture_extratex"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($texType != 1));
		$attrNames = {"vray_int_texture_extratex"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($texType != 2));

		// if int or float is choosen disable AA and filter
		$attrNames = {"vray_considerforaa_extratex", "vray_filtering_extratex"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($texType != 0));
	}
}

// This procedure is used for enable/disable hardware acceleration option
// of the denoiser render element depending on the denoiser engine.
global proc vrayOnDenoiserEngineChanged(string $nodeName, string $attrName, string $ctrl) {
	if (`attributeExists $attrName $nodeName`) {
		string $nodeDotAttr = $nodeName + "." + $attrName;
		int $engineValue = `getAttr $nodeDotAttr`;
		// The hardware acceleration option is not available for the NVIDIA and Intel denoisers
		string $attrNames[] = {"vray_preset_denoiser", "vray_hardware_accel_denoiser"};
		vrayDimControls($nodeName, $attrNames, $ctrl, ($engineValue > 0));
		// Radius and strength also depend on the engine
		vrayOnDenoiserPresetChanged($nodeName, $attrName, $ctrl);
		// Temporal mode is available only for NVIDIA denoiser
		$attrNames = {"vray_temporal_mode_denoiser"};
		vrayDimControls($nodeName, $attrNames, $ctrl, ($engineValue != 1));
	}
}

//this procedure is used to update controls in Denoiser render element.
global proc vrayOnDenoiserPresetChanged(string $nodeName, string $attrName, string $ctrl) {
	if (`objExists $nodeName`) {
		int $engineValue = `getAttr ($nodeName + ".vray_engine_denoiser")`;
		int $presetValue = `getAttr ($nodeName + ".vray_preset_denoiser")`;
		// The radius and strength are available only with the custom preset (preset value=3) and only for our denoiser
		string $attrNames[] = {"vray_radius_denoiser", "vray_strength_denoiser"};
		vrayDimControls($nodeName, $attrNames, $ctrl, ($engineValue>0 || $presetValue!=3));
	}
}

//this procedure is executed when Refresh button in denoiser AE is pressed
//it takes denoiser RE attributes and pass them to c++ function refreshDenoiser in vraycmd
//attrName is useless in this call
global proc  vrayOnRefreshDenoiserPressed(string $nodeName, string $attrName) {
	// When hitting Denoiser "Update" button while IPR or viewport IPR running, just do nothing and exit
	int $iprOn = vrayIsRunningIpr() || `vray viewportIPRRunning`;
	if ($iprOn) {
		warning("\nV-Ray : Cannot update Denoiser render element while IPR is running.");
		return;
	}
	
	string $cmd = "vray refreshDenoiser ";
	string $attrList[] = {
		"enabled",
		"vray_alias_denoiser",
		"vray_name_denoiser",
		"vray_mode_denoiser",
		"vray_type_denoiser", // deprecated
		"vray_preset_denoiser",
		"vray_strength_denoiser",
		"vray_radius_denoiser",
		"vray_hardware_accel_denoiser",
		"vray_progressive_update_denoiser", 
		"vray_denoise_alpha_denoiser",
		"vray_engine_denoiser"
	};
	for($attr in $attrList)
	{
		if (`attributeExists $attr $nodeName`) {
			$cmd = $cmd + " " + `getAttr ($nodeName + "." + $attr)`;
		} else {
			$cmd = $cmd + " 0"; // Dummy value, it may be missing because it's deprecated
		}
	}
	eval($cmd);

}

// this procedure is executed when LPE builder button in Light Select AE is pressed
// It opens the LPE builder helper tool
global proc  vrayOnLpeBuilderPressed(string $nodeName, string $attrName) {
	python( "import webbrowser as web;web.open('https://lpe-builder.chaosgroup.com/')" );
}


// This procedure is used to dim controls in SamplerInfo render element according to its type:
// 0 - Point
// 1 - Normal
// 2 - Reflection
// 3 - Refraction
// 4 - UVW channel
// 5 - Bump normal
// 6 - Backward occlusion
// 7 - Forward occlusion
// 8 - Integer ID from node user attribute
// 9 - Float number from node user attribute
// 10 - Face index
// 11 - Barycentric coordinates in face
// 12 - Tangent vector in uv space
// 13 - Biangent vector in uv space
global proc vrayOnSamplerInfoTypeChanged(string $nodeName, string $attrName, string $ctrl) {
	if (`attributeQuery -exists -node $nodeName "vray_type_samplerinfo"`) {
		int $samplerInfoType = `getAttr ($nodeName + ".vray_type_samplerinfo")`;

		// Hide point multiplier if type is not point.
		string $attrNames[] = {"vray_point_multiplier_samplerinfo"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($samplerInfoType != 0));

		// Hide IOR value if type is not refraction.
		$attrNames = {"vray_refraction_ior_samplerinfo"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($samplerInfoType != 3));

		// Hide UVW channel if type is not UVW channel or bi/tangent in object space.
		$attrNames = {"vray_uvw_channel_samplerinfo"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($samplerInfoType != 4 && $samplerInfoType != 12 && $samplerInfoType != 13));

		// Hide other UVW options if type is not UVW channel.
		$attrNames = {"vray_uvw_channel_name_samplerinfo", "vray_uvw_mode_samplerinfo"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($samplerInfoType != 4));

		// Hide the possibility to chose coordinate system and use world space for types:
		// UVW channel, Forward and backward occlusion, Integer ID and float number from Node user attribite,
		// Face index, Barycentric coordinates, Bi/Tangent in object space.
		$attrNames = {"vray_coord_system_samplerinfo", "vray_relative_node_samplerinfo"};
		$dimCoordSys = (-1!=intArrayFind($samplerInfoType, 0, {4, 6, 7, 8, 9, 10, 11, 12, 13}));
		if ($dimCoordSys) {
			setAttr ($nodeName + ".vray_coord_system_samplerinfo") 0;
		}
		vrayDimControls($nodeName,  $attrNames, $ctrl, $dimCoordSys);

		// Hide the possibility to chose color output [0, 1] and use only vector output for types:
		// Point, UVW channel, Forward and backward occlusion, User attributes.
		$attrNames = {"vray_output_samplerinfo"};
		$dimOutput = ($samplerInfoType == 0 || $samplerInfoType == 4 || $samplerInfoType == 6 || $samplerInfoType == 7 || $samplerInfoType == 8 || $samplerInfoType == 9);
		if ($dimOutput) {
			setAttr ($nodeName + ".vray_output_samplerinfo") 0;
		}
		vrayDimControls($nodeName,  $attrNames, $ctrl, $dimOutput);

		// Hide user attribute input if type is not node user attribute.
		$attrNames = {"vray_user_attribute_samplerinfo"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($samplerInfoType != 8 && $samplerInfoType != 9));

		// Hide occlusion bias parameter if type is not forward or backward occlusion.
		$attrNames = {"vray_occlusion_bias_samplerinfo"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($samplerInfoType != 6 && $samplerInfoType != 7));
		
		// Dim the "Denoise" option if the type is set to use integer/float node user attributes
		// because in these cases the exported plugins do not support this option.
		$attrNames = {"vray_denoise_samplerinfo"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($samplerInfoType == 8 || $samplerInfoType == 9));
	}
}

global proc vrayOnSamplerInfoCoordSystemChanged(string $nodeName, string $attrName, string $ctrl) {
	if (`objExists $nodeName` && `attributeQuery -exists -node $nodeName "vray_coord_system_samplerinfo"`) {
		int $samplerInfoCoordSystem = `getAttr ($nodeName + ".vray_coord_system_samplerinfo")`;
		// dim relative node when coordinate system is set to something different from 3 (relative)
		string $attrNames[] = {"vray_relative_node_samplerinfo"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($samplerInfoCoordSystem != 3));
	}
}

global proc vrayOnLightingAnalysisDisplayChanged(string $nodeName, string $attrName, string $ctrl) {
	if (`objExists $nodeName` && `attributeQuery -exists -node $nodeName "vray_display_lighting_analysis"`) {
		int $display = `getAttr ($nodeName + ".vray_display_lighting_analysis")`;
			// dim grid controls when display is not 1 (Grid overlay)
			string $attrNames[] = {"vray_horizontal_lighting_analysis", "vray_vertical_lighting_analysis", "vray_fade_background_lighting_analysis"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($display != 1));
	}
}

// This procedure is executed when Update button in the Lighting Analysis RE is pressed
// It takes the render element's attributes and pass them to c++ function refreshLightingAnalysis in vraycmd
//attrName is useless in this call
global proc  vrayOnRefreshLightingAnalysisPressed(string $nodeName, string $attrName) {
	string $cmd = "vray refreshLightingAnalysis ";
	string $attrList[] = {
		"enabled",
		"vray_name_lighting_analysis",
		"vray_quantity_lighting_analysis",
		"vray_min_lighting_analysis",
		"vray_max_lighting_analysis",
		"vray_scale_lighting_analysis",
		"vray_display_lighting_analysis",
		"vray_horizontal_lighting_analysis",
		"vray_vertical_lighting_analysis",
		"vray_fade_background_lighting_analysis", 
		"vray_draw_legend_lighting_analysis"
	};

	for($attr in $attrList)
	{
		if (`attributeExists $attr $nodeName`) {
			if ($attr=="vray_name_lighting_analysis" && `getAttr vraySettings.relements_useNodeName`) {
				$cmd = $cmd + " \""+$nodeName+"\"";
			} else {
				$cmd = $cmd + " " + `getAttr ($nodeName + "." + $attr)`;
			}
		} else {
			$cmd = $cmd + " 0"; // Dummy value, it may be missing because it's deprecated
		}
	}
	eval($cmd);
}

global proc vrayOnMotionBlurSamplesEnable(string $nodeName, string $attrName, string $ctrl) {
	if (`objExists $nodeName` && `attributeQuery -exists -node $nodeName "vrayMotionBlurSamplesEnable"`) {
		int $display = `getAttr ($nodeName + ".vrayMotionBlurSamplesEnable")`;
			// dim motion blur samples value when the override is disabled
			string $attrNames[] = {"vrayMotionBlurSamplesValue"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($display != 1));
	}
}

// This procedure is used for disable light path expression text box
// if the light select render element type is not light path expression.
global proc vrayOnLightSelectTypeChanged(string $nodeName, string $attrName, string $ctrl) {
	if (`attributeExists $attrName $nodeName`) {
		string $nodeDotAttr = $nodeName + "." + $attrName;
		int $value = `getAttr $nodeDotAttr`;
		string $attrNames[] = {"vray_lpe_lightselect", "vray_lpe_builder_lightselect"};
		vrayDimControls($nodeName,  $attrNames, $ctrl, ($value != 9 /* light path expression */));
	}
}

// End of procedures for enable/disable of dynamic Vray Attributes
//---------------------------------------------------------


global proc suppressAttributesForVRayObjects() {
	editorTemplate -suppress "resolution";
	editorTemplate -suppress "normalCamera";
	editorTemplate -suppress "objectType";
	editorTemplate -suppress "nodeState";
	editorTemplate -suppress "caching";
	editorTemplate -suppress "frozen";
	editorTemplate -suppress "intermediateObject";
	editorTemplate -suppress "ghosting";
	editorTemplate -suppress "ghostingControl";
	editorTemplate -suppress "ghostPreSteps";
	editorTemplate -suppress "ghostPostSteps";
	editorTemplate -suppress "ghostStepSize";
	editorTemplate -suppress "ghostFrames";
	editorTemplate -suppress "ghostRangeStart";
	editorTemplate -suppress "ghostRangeEnd";
	editorTemplate -suppress "ghostColorPre";
	editorTemplate -suppress "ghostColorPreA";
	editorTemplate -suppress "ghostColorPost";
	editorTemplate -suppress "ghostColorPostA";
	editorTemplate -suppress "ghostDriver";
	editorTemplate -suppress "ghostCustomSteps";
	editorTemplate -suppress "boundingBox";
	editorTemplate -suppress "castsShadows";
	editorTemplate -suppress "receiveShadows";
	editorTemplate -suppress "motionBlur";
	editorTemplate -suppress "visibleInReflections";
	editorTemplate -suppress "visibleInRefractions";
	editorTemplate -suppress "depthJitter";
	editorTemplate -suppress "maxVisibilitySamplesOverride";
	editorTemplate -suppress "maxVisibilitySamples";
	editorTemplate -suppress "geometryAntialiasingOverride";
	editorTemplate -suppress "antialiasingLevel";
	editorTemplate -suppress "shadingSamplesOverride";
	editorTemplate -suppress "shadingSamples";
	editorTemplate -suppress "maxShadingSamples";
	editorTemplate -suppress "volumeSamplesOverride";
	editorTemplate -suppress "volumeSamples";

	editorTemplate -suppress "visibility";
	editorTemplate -suppress "template";
	editorTemplate -suppress "selectionChildHighlighting";
	editorTemplate -suppress "useOutlinerColor";
	editorTemplate -suppress "outlinerColor";
	editorTemplate -suppress "hiddenInOutliner";
	editorTemplate -suppress "hardwareFogMultiplier";
	editorTemplate -suppress "drawOverride";
	editorTemplate -suppress "overrideDisplayType";
	editorTemplate -suppress "overrideLevelOfDetail";
	editorTemplate -suppress "overrideShading";
	editorTemplate -suppress "overrideTexturing";
	editorTemplate -suppress "overridePlayback";
	editorTemplate -suppress "overrideEnabled";
	editorTemplate -suppress "overrideVisibility";
	editorTemplate -suppress "overrideColor";
	editorTemplate -suppress "lodVisibility";
	editorTemplate -suppress "renderInfo";
	editorTemplate -suppress "identification";
	editorTemplate -suppress "layerRenderable";
	editorTemplate -suppress "layerOverrideColor";
	editorTemplate -suppress "renderLayerInfo";
	editorTemplate -suppress "renderType";
	editorTemplate -suppress "renderVolume";
	editorTemplate -suppress "visibleFraction";
	editorTemplate -suppress "motionBlur";
	editorTemplate -suppress "visibleInReflections";
	editorTemplate -suppress "visibleInRefractions";
	editorTemplate -suppress "depthJitter";
	editorTemplate -suppress "ignoreSelfShadowing";
	editorTemplate -suppress "primaryVisibility";
	editorTemplate -suppress "referenceObject";
	editorTemplate -suppress "compInstObjGroups";
	editorTemplate -suppress "underWorldObject";
	editorTemplate -suppress "localPosition";
	editorTemplate -suppress "worldPosition";
	editorTemplate -suppress "localScale";
	editorTemplate -suppress "lightData";
	editorTemplate -suppress "lightDirection";
	editorTemplate -suppress "lightIntensity";
	editorTemplate -suppress "lightAmbient";
	editorTemplate -suppress "lightDiffuse";
	editorTemplate -suppress "lightSpecular";
	editorTemplate -suppress "lightShadowFraction";
	editorTemplate -suppress "preShadowIntensity";
	editorTemplate -suppress "lightBlindData";
}

global proc string vrayFileExtVarName(string $pluginName, string $attribute) {
	string $varName = ($pluginName + "." + $attribute + "FileExt");
	return $varName;
}

global proc string vrayTooltipVarName(string $pluginName, string $attribute) {
	string $varName = ($pluginName + "." + $attribute + "Tooltip");
	return $varName;
}

global proc AEvrayCustomUINew(string $nodeAttr) {
	AEvrayCustomUIReplace($nodeAttr);
}

global proc int vrayIsAttrColorComponent(string $node, string $attr) {
	// Color components in items of multi attributes produce errors
	// in "attributeQuery" and "addAttr" so filter those
	if (!`attributeQuery -exists -node $node $attr`) {
		return false;
	}

	string $parentAttr = `addAttr -q -parent ($node+"."+$attr)`;
	if ($parentAttr == $attr) {
		return false;
	}
	
	if (`addAttr -q -usedAsColor ($node+"."+$parentAttr)`) {
		return true;
	} else {
		return false;
	}
}

proc int vrayCheckIfAttributeHasCategory(string $node, string $attr, string $category) {
	// "attributeQuery" leads to errors when called for textures multi attributes
	// and their color components so skip those (e.g. "textures.texturesR", "textures[0].texturesR")
	if (!`attributeQuery -exists -node $node $attr`)
		return false;
	string $categories[]=`attributeQuery -categories -n $node $attr`;
	int $hasVrayNoValue=false;
	for ($c in $categories) {
		if ($c==$category)
			return true;
	}
	return false;
}

proc string vrayGetLabelFromAttribute(string $node, string $attr) {
	string $label=`attributeQuery -niceName -node $node $attr`;
	if ($label=="") {
		string $nodeDotAttr = ($node + "." + $attr);
		$label=`addAttr -q -longName $nodeDotAttr`;
	}
	return $label;
}

// The function is used to create UI controls for VRay nodes' attributes. For most attributes we create default controls with tooltips.
// For some specific attributes, we however  create custom UI controls. This include file names, which require file browsing dialogs, and
// enums, which require drop-down lists.
// Note that the function is called by Maya when it's required, for example when creating AE for new node, when changing AE selection, etc.
global proc AEvrayCustomUIReplace(string $nodeAttr) {
	// $nodeAttr is the message attribute used for callCustom
	setUITemplate -pst attributeEditorTemplate;
	
	string $controlLayout = `setParent -q`;
	$controlLayout += ("|vrayCustomUILayout");
	if ( `columnLayout -exists $controlLayout`) {
		deleteUI $controlLayout;
	}

	columnLayout -adj 1 vrayCustomUILayout;

	string $tokens[];
	tokenize $nodeAttr "." $tokens;
	string $node = $tokens[0];
	//Note that node attributes are filtered with listAttr command. Attributes that are set with "-hidden true" or "-writable false" are not shown in Attribute editor.
	string $attributes[] = `listAttr -visible -write -userDefined $node`;
	string $pluginName = `getAttr ($node + ".vray_pluginName")`;
	for ($attr in $attributes) {
		// Do not add separate controls for color components. Color controls are added only
		// for the compound color attribute which is parent of color component attributes.
		// Color components in attributes of multi-attributes work fine in commands "listAttr"
		// and "attributeExists" but not in "attributeQuery". Using them with the last one
		// produces errors. That's why check here with "attributeQuery" to skip those.
		if (!`attributeQuery -exists -node $node $attr` || vrayIsAttrColorComponent($node, $attr)==true) {
			continue;
		}
		string $nodeDotAttr = ($node + "." + $attr);

		string $tooltip = "";
		string $tooltipVar = vrayTooltipVarName($pluginName,$attr);
		if ( `displayString -exists $tooltipVar`) {
			$tooltip = uiRes($tooltipVar);
		}	
		string $control = "";

		string $ext = "";
		string $extVar = vrayFileExtVarName($pluginName,$attr);
		if ( `displayString -exists $extVar`) {
			$ext = uiRes($extVar);
		}

		if ($ext != "") {
			string $fileCtrlLayout = ($attr+"fileCtrl");
			columnLayout $fileCtrlLayout;

			string $label=vrayGetLabelFromAttribute($node, $attr);

			AE_VRAY_fileNameNew($label,$ext, 0, $nodeDotAttr);
			$control = $fileCtrlLayout + "|fileNameLayout";

			setParent..;
		} else {
			int $isMultiAttr = `attributeQuery -node $node -multi $attr`;
			if (vrayCheckIfAttributeHasCategory($node, $attr, "vray-no-value") && !$isMultiAttr) {
				string $label=vrayGetLabelFromAttribute($node, $attr);
				$control=`attrNavigationControlGrp -attribute $nodeDotAttr -label $label`;
			} else if ($isMultiAttr) {
				string $label=vrayGetLabelFromAttribute($node, $attr);
				vrayListControlNew($label, $tooltip, "vrayCreateArrayAttrControl", $nodeDotAttr);
			} else {
				$control = `attrControlGrp -attribute $nodeDotAttr`;
			}
		}
		if ($control != "") {
			control -edit -annotation $tooltip $control;
		}

	}

	setUITemplate -ppt;
}

//Code for "global proc vraySuppressExtraNew()" is borrowed from AEcgfxShaderTemplate.

// Find the "Extra Attributes" frameLayout and hide it.
global proc vraySuppressExtraNew()
{
    string $sExtraParent = `setParent ..`;
    string $sa[] = `layout -q -ca $sExtraParent`;
    string $sExtra;
    // Bug 261197: label string may be localized, look up the localized value 
    // Beware, the resource format or id could change some day. 
    string $extraLabel = `uiRes("s_TPStemplateStrings.rExtraAttributes")`;
    for ( $sExtra in $sa )
    {
        if ( `objectTypeUI -isType frameLayout $sExtra` &&
             `frameLayout -q -l $sExtra` == $extraLabel )
        {
            frameLayout -e -manage 0 $sExtra;
            break;
        }
    }
}

global proc vraySuppressExtraReplace()
{
}

global proc suppressAttributesForVRaySurfaceShapes() {
	suppressAttributesForVRayObjects();

	editorTemplate -suppress "doubleSided";
	editorTemplate -suppress "opposite";
	editorTemplate -suppress "smoothShading";
	editorTemplate -suppress "holdOut";

	editorTemplate -suppress "ignoreHwShader";
	editorTemplate -suppress "center";
	editorTemplate -suppress "matrix";
	editorTemplate -suppress "inverseMatrix";
	editorTemplate -suppress "worldMatrix";
	editorTemplate -suppress "worldInverseMatrix";
	editorTemplate -suppress "parentMatrix";
	editorTemplate -suppress "parentInverseMatrix";
	editorTemplate -suppress "instObjGroups";

	editorTemplate -suppress "controlPoints";
	editorTemplate -suppress "weights";
	editorTemplate -suppress "tweak";
	editorTemplate -suppress "relativeTweak";
	editorTemplate -suppress "currentUVSet";
	editorTemplate -suppress "currentColorSet";
	editorTemplate -suppress "uvSet";
	editorTemplate -suppress "displayColors";
	editorTemplate -suppress "displayColorChannel";
	editorTemplate -suppress "displayImmediate";
	editorTemplate -suppress "colorSet";
	
	editorTemplate -suppress "useObjectColor";
	editorTemplate -suppress "objectColor";
	editorTemplate -suppress "objectColorRGB";
	editorTemplate -suppress "wireColorRGB";

	editorTemplate -suppress "featureDisplacement";
	editorTemplate -suppress "initialSampleRate";
	editorTemplate -suppress "extraSampleRate";
	editorTemplate -suppress "textureThreshold";
	editorTemplate -suppress "normalThreshold";
	editorTemplate -suppress "boundingBoxScale";
	
	editorTemplate -suppress "collisionOffsetVelocityIncrement";
	editorTemplate -suppress "collisionDepthVelocityIncrement";
	editorTemplate -suppress "collisionOffsetVelocityMultiplier";
	editorTemplate -suppress "collisionDepthVelocityMultiplier";
}

global proc suppressAttributesForVRayObjectSets() {
	editorTemplate -suppress "memberWireframeColor";
	editorTemplate -suppress "annotation";
	editorTemplate -suppress "partition";
	editorTemplate -suppress "isLayer";
	editorTemplate -suppress "verticesOnlySet";
	editorTemplate -suppress "edgesOnlySet";
	editorTemplate -suppress "facetsOnlySet";
	editorTemplate -suppress "editPointsOnlySet";
	editorTemplate -suppress "renderableOnlySet";
	editorTemplate -suppress "dagSetMembers";
	editorTemplate -suppress "dnSetMembers";
	editorTemplate -suppress "groupNodes";
	editorTemplate -suppress "usedBy";
	editorTemplate -suppress "hiddenInOutliner";
}

global proc vrayToggleLightTargetManipulator() {
	string $whichCtx = `currentCtx`;
	
	if($whichCtx != "ShowManips") {
		setToolTo "ShowManips";
	} else {
		setToolTo "selectSuperContext";
		//setToolTo "moveSuperContext";
	}
}

global proc AEvrayLightTargetManipulatorReplace(string $a, string $b) {}
global proc AEvrayLightTargetManipulatorNew(string $a, string $b) {
	setUITemplate -pst attributeEditorTemplate;
	rowLayout -nc 2 -cw 2 90;
		text -label "";
		button -label "Toggle Target" -height 21 -command "vrayToggleLightTargetManipulator();";
	setParent ..;
	setUITemplate -ppt;
}

global proc vrayObjSetSelect(string $setName) {
	string $relationshipEditorPanels[] = `getPanel -scriptType "relationshipPanel"`;
	string $thisSelection = ($relationshipEditorPanels[0] + "LeftSelection");

	// In order for the selection code to succeed on Linux, both of these command should be execute on idle.
	evalDeferred("selectionConnection -e -clear \""+$thisSelection+"\";");
	evalDeferred("selectionConnection -e -select \""+$setName+"\" \""+$thisSelection+"\";");
}

global proc vrayObjSetShowEditor(string $msgAttr, string $createSetName) {
	setMembershipEditor();
	string $connected[]=`listConnections $msgAttr`;
	string $setName="";
	if (size($connected)!=0)
		$setName=$connected[0];
	else {
		if ($createSetName != "renderMaskSet")
			$setName=`sets -name ($createSetName+"#") -empty`;
		else
			$setName=`sets -name ($createSetName+"#")`;
		connectAttr ($setName+".usedBy") $msgAttr;
	}

	// Try to select the newly created set, but works only if the relationship editor is already shown.
	vrayObjSetSelect($setName);
}

global proc string AEvrayObjectSetNew(string $label, string $createSetName, string $attr) {
	string $controlName = `makeControlName($attr)`;
	string $layoutName = $controlName + "Layout";
	string $btnName = $controlName+"Button";
	
	string $id = `formLayout $layoutName`;
	attrNavigationControlGrp
		-columnWidth 3 0
		-attribute $attr
		-label $label
		-createNew ("vrayObjSetShowEditor(\""+$attr+"\", \""+$createSetName+"\")")
		$controlName;
	button
		-label ">"
		-command ("vrayObjSetShowEditor(\""+$attr+"\", \""+$createSetName+"\")")
		$btnName;
		
	formLayout -e
		-af $controlName left 0
		-af $btnName right 5
		-ac $controlName right 3 $btnName
		$layoutName;
	setParent ..;
	return $id;
}

// Added a new version of AEvrayObjectSetNew which accepts the -annotation flag.
global proc AEvrayObjectSetNewWithAnnotation(string $label, string $createSetName, string $attr, string $tooltip, string $tooltipButton) {
	AEvrayObjectSetNew($label, $createSetName, $attr);
	string $controlName = `makeControlName($attr)`;
	attrNavigationControlGrp -e -ann (uiRes("m_vrayTooltipsRes."+ $tooltip)) $controlName;
	button -e -ann (uiRes("m_vrayTooltipsRes."+$tooltipButton)) ($controlName+"Button");
}

global proc AEvrayObjectSetReplace(string $label, string $createSetName, string $attr) {
	string $controlName = `makeControlName($attr)`;
	attrNavigationControlGrp -e
		-label $label
		-attribute $attr
		-createNew ("vrayObjSetShowEditor(\""+$attr+"\", \""+$createSetName+"\")")
		$controlName;
		
	button -e
		-command ("vrayObjSetShowEditor(\""+$attr+"\", \""+$createSetName+"\")")
		($controlName+"Button");
}

global proc vrayEditorTemplateObjectSet(string $attrName, string $attrLabel, string $createSetName) {
	editorTemplate -callCustom ("AEvrayObjectSetNew \""+$attrLabel+"\" \""+$createSetName+"\" ") ("AEvrayObjectSetReplace \""+$attrLabel+"\" \""+$createSetName+"\" ") $attrName;
	editorTemplate -suppress $attrName;
}

// -----------------------------

//
// Create AE widgets that control given light's color and temperature
// attributes.  The light's color is determined by the following algorithm:
//
// If colorMode is set to COLOR (index 0), then light's color can be
// manually selected.  In this case the temperature control is
// disabled.
//
// If colorMode is set to TEMPERATURE (index 1), then light's color is
// solely derived from the temperature's value.
//
// This function works on light nodes with the following attributes:
// 1. colorMode -- Integer enum, 0=color, 1=temperature
// 2. lightColor -- Color input attribute
// 3. outTemperatureColor -- Color output attribute
// 4. temperature -- Float input attribute
//
// Added controls act as follows:
// When `colorMode` == COLOR (that's index 0):
//    - `lightColor` is visible
//    - `temperature` slider is dimmed
//    - `outTemperatureColor` is invisible
// When `colorMode` == TEMPERATURE (that's 1):
//    - `lightColor` is invisible
//    - `temperature` slider is editable and not dimmed
//    - `outTemperatureColor` visually replaces `lightColor`
//
global proc AEVRayLight_addColorAndTemperature(string $prefix)
{
	// 1. colorMode
	editorTemplate -addControl
		"colorMode"
		// ydm: Strange, but using " \"" + $prefix + "\" "
		// doesn't work as expected.
		("AEVRayLight_colorMode_onChange " + $prefix + " ");

	// 2. lightColor
	string $lightColor = ($prefix + "_lightColor");
	editorTemplate -callCustom
		("AEVRayLight_color_new \"" + $lightColor + "\" ")
		("AEVRayLight_color_replace \"" + $lightColor + "\" ")
		"color";

	// 3. outTemperatureColor
	string $outTemp = ($prefix + "_outTemperatureColor");
	editorTemplate -callCustom
		("AEVRayLight_color_new \"" + $outTemp + "\" ")
		("AEVRayLight_color_replace \"" + $outTemp + "\" ")
		"outTemperatureColor";

	// 4. temperature
	editorTemplateFloatNoMap("temperature", "Temperature");
}

global proc AEVRayLight_colorMode_onChange(string $prefix, string $nodeName)
{
	if (!`objExists $nodeName`)
		return;
	// Get the color mode index.  It's 0 (color) or 1 (temp).
	int $index = `getAttr ($nodeName + ".colorMode")`;

	// Apply visibility depending on mode.
	string $lightColor = ($prefix + "_lightColor");
	string $tempColor  = ($prefix + "_outTemperatureColor");
	vrayToggleControlState($lightColor, "visible", $index == 0);
	vrayToggleControlState($tempColor, "visible", $index == 1);
	editorTemplate -dimControl $nodeName "temperature" ($index == 0);
}

global proc AEVRayLight_color_new(string $groupName, string $attrName)
{
	attrColorSliderGrp -attribute $attrName -label "Light Color" -showButton false $groupName;
}

global proc AEVRayLight_color_replace(string $groupName, string $attrName)
{
	attrColorSliderGrp -e -attribute $attrName $groupName;
}
// Return the next available index of a multi attribute
proc int vrayGetMultiAttrNextAvailable(string $nodeDotAttr) {
	int $nextAvailable = 0;
	string $buffer;
	if(`getAttr -size $nodeDotAttr` > 0)
	{
		//find first free index in the attribute
		string $multi[] = `listAttr -multi $nodeDotAttr`;
		for($m in $multi)
		{
			//	Find index [n]
			$buffer = match("\[[0-9]+\]", $m);
			//	Find n. Use implicate data type conversion. string "15" is converted to int 15
			int $index = match("[0-9]+", $buffer);
			if ( $index >= $nextAvailable )
				$nextAvailable = $index + 1;
		}
	}
	
	return $nextAvailable;
}

//helper function used in vrayAECompoundMultiReplace
//It's used to create new entry in multi compound attribute. Finds first free index in
//the array attribute and place the new entry there.
global proc vrayAENewMultiCompElem(string $nodeDotAttr, int $startId)
{
	int $nextAvailable = vrayGetMultiAttrNextAvailable($nodeDotAttr);
	
	// Create a plug by accessing it
	string $plugName = $nodeDotAttr + "[" + $nextAvailable + "]";
	catchQuiet( `getAttr -type $plugName`);
	string $attrBuffer[];
	$numTokens = `tokenize $nodeDotAttr "." $attrBuffer`;
	catchQuiet(`setAttr ($plugName + "." + $attrBuffer[$numTokens - 1] + "ID") ($nextAvailable+$startId)`); // ID is not mandatory
}

//Creates custom control for multi compound attributes. It's using $createEntryFunction to create
//single entry and wraps all of them in single frameLayout.
//$createEntryFunction - name of procedure that creates controls for every node in the list, it has to add delete control too!
// example for $createEntryFunction in AEvrayMultiSubTexTemplate.mel -> vrayCreateMultiSubTexEntryControl
global proc vrayAECompoundMultiNew(string $nodeDotAttr, string $displayName, string $createEntryFunction, string $startId) {
	vrayAECompoundMultiNewInternal($nodeDotAttr, $displayName, $createEntryFunction, $startId, true, false);
}

// Same as the original, but with no button to add a new entry. Used by VRayProxy.
global proc vrayAECompoundMultiNewNoAddButton(string $nodeDotAttr, string $displayName, string $createEntryFunction, string $startId) {
	vrayAECompoundMultiNewInternal($nodeDotAttr, $displayName, $createEntryFunction, $startId, false, false);
}

// Same as the original, but with collapsed layout. Used by proxy alembic layers.
global proc vrayAECompoundMultiNewCollapse(string $nodeDotAttr, string $displayName, string $createEntryFunction, string $startId) {
	vrayAECompoundMultiNewInternal($nodeDotAttr, $displayName, $createEntryFunction, $startId, true, true);
}

// Since Maya has no default values, if we add an extra parameter to these new/delete functions, we have to add it everywhere.
// So instead, we have multiple versions of the new/replace functions, calling this one with different params.
// This approach saves us from adding the parameter everywhere every time, and also avoids using tokenize() to get the actual value
global proc vrayAECompoundMultiNewInternal(string $nodeDotAttr, string $displayName, string $createEntryFunction, string $startId, int $hasAddButton, int $collapse) {
	string $buffer[];
	tokenize($displayName, ".", $buffer);
	string $niceName = $buffer[1];
	tokenize($startId, ".", $buffer);
	int $niceStartId = $buffer[1];
	
	//create frame for whole multi attr
	frameLayout -l $niceName -collapse $collapse vrayListFrame;
		//maya like -> row layout for "New Item" button
		if ($hasAddButton) {
			rowLayout -nc 2 vrayButtonLayout;
				text -label "";
				button -label "Add New Item"
					-command ("vrayAENewMultiCompElem(\"" + $nodeDotAttr+"\", "+$niceStartId+")") vrayNewItemButton;
			setParent ..;
		}
	setParent ..;

	//we are forcing replace (copy tab, loading new scene that contains this control etc.)
	vrayAECompoundMultiReplaceInternal($nodeDotAttr, $displayName, $createEntryFunction, $startId, $hasAddButton, $collapse);
}

//vrayAECompoundMultiReplace pair with vrayAECompoundMultiNew
global proc vrayAECompoundMultiReplace(string $nodeDotAttr, string $displayName, string $createEntryFunction, string $startId) {
	vrayAECompoundMultiReplaceInternal($nodeDotAttr, $displayName, $createEntryFunction, $startId, true, false);
}

global proc vrayAECompoundMultiReplaceNoAddButton(string $nodeDotAttr, string $displayName, string $createEntryFunction, string $startId) {
	vrayAECompoundMultiReplaceInternal($nodeDotAttr, $displayName, $createEntryFunction, $startId, false, false);
}

global proc vrayAECompoundMultiReplaceCollapse(string $nodeDotAttr, string $displayName, string $createEntryFunction, string $startId) {
	vrayAECompoundMultiReplaceInternal($nodeDotAttr, $displayName, $createEntryFunction, $startId, true, true);
}

global proc vrayAECompoundMultiReplaceInternal(string $nodeDotAttr, string $displayName, string $createEntryFunction, string $startId, int $hasAddButton, int $collapse) {
	//maya puts nodename in string args before the given args
	string $buffer[];
	tokenize($createEntryFunction, ".", $buffer);
	string $nodeName = $buffer[0];
	string $niceCreateEntry = $buffer[1];
	tokenize($startId, ".", $buffer);
	int $niceStartId = $buffer[1];

	if ($hasAddButton) {
		button -e -command ("vrayAENewMultiCompElem(\"" + $nodeDotAttr+"\", "+$niceStartId+")") vrayNewItemButton;
	}
	
	string $controlLayout = `setParent -q`;
	$controlLayout += ("|vrayListFrame");
	if (!`layout -exists $controlLayout`) {
			return;
	}
	
	string $currentChildren[] = `layout -q -childArray $controlLayout`;
	for($ch in $currentChildren) {
		if($ch != "vrayButtonLayout") {
			deleteUI $ch;
		}
	}
	
	setParent $controlLayout;
	int $elementsCnt = `getAttr -size $nodeDotAttr`;
	if($elementsCnt > 0) {
		//	The return value looks like this: {rgb[0], rgb[0].r, rgb[0].g, rgb[0].b, rgb[3], ... }
		// when we use it with -leaf results is something like { rgb[0], r, g b, rgb[6] ...}
		string $multi[] = `listAttr -multi -leaf $nodeDotAttr`;
		for($m in $multi) {
			// and thill there isnt compound attr with multi attr in them we can use only children with []
			// IMPORTANT!!! Wont work for compound attr with child multi attribute
			string $buffer = match("\[[0-9]+\]", $m);
			if(size($buffer) > 0) {
				eval($niceCreateEntry, $nodeName, $m);
			}
		}
	}
	setParent ..;
}

// Add delete and swap buttons for array attributes
// $nodeName The name of the attributes' node
// $attrWithIdx The name of the attribute parent including its index
// $deleteCommand Command for delete button
// $swapUpCommand Command for arrow up button
// $swapDownCommand Command for arrow down button
global proc vrayAECompoundMultiDeleteAndSwapButtons(string $nodeName, string $attrWithIdx, string $deleteCommand, string $swapUpCommand, string $swapDownCommand) {

	// delete button
	columnLayout;
		symbolButton
		-image "smallTrash.png"
		-command ($deleteCommand);
		setParent..;

	// swap buttons
	columnLayout;
		symbolButton
			-image "arrowUp.png"
			-command ($swapUpCommand);

		symbolButton
			-image "arrowDown.png"
			-command ($swapDownCommand);
	setParent..;
}

// Delete and swap buttons with the most commonly used delete/swap functions for compound multi attributes
global proc vrayAECompoundMultiDefaultDeleteAndSwap(string $nodeName, string $attrWithIdx) {
	// Extract the attribute name and index from $attrWithIdx
	string $attrTokenized[];
	tokenize $attrWithIdx "[]" $attrTokenized;
	string $attr = $attrTokenized[0];
	int $idx = $attrTokenized[1];
	string $attrChildren[] = `attributeQuery -node ($nodeName) -listChildren ($attr)`;

	// Construct next and previous attributes. Produce empty strings if this is the first or the last attribute.
	int $attrIndexes[] = eval("getAttr -multiIndices " + $nodeName + "." + $attr);
	int $attrIdxIndex = intArrayFind($idx, 0, $attrIndexes);
	$prevAttrWithIdx = $attrIdxIndex>0 ? $attr + "[" + $attrIndexes[$attrIdxIndex-1] + "]" : "";
	$nextAttrWithIdx = $attrIdxIndex<(size($attrIndexes)-1) ? $attr + "[" + $attrIndexes[$attrIdxIndex+1] + "]" : "";

	vrayAECompoundMultiDeleteAndSwapButtons(
		$nodeName,
		$attrWithIdx,
		"removeMultiInstance -break true " + $nodeName + "." + $attrWithIdx,
		"vrayAECompoundMultiSwap(\"" + $nodeName + "\", \"" + $attr + "\", \"" + $attrWithIdx + "\", \"" + $prevAttrWithIdx + "\");",
		"vrayAECompoundMultiSwap(\"" + $nodeName + "\", \"" + $attr + "\", \"" + $attrWithIdx + "\", \"" + $nextAttrWithIdx + "\");"
	);
}

// Swap a simple attribute element of two compound attributes.
// No check is done if a connected attribute is input or output and only input attributes are supported.
// $nodeName The name of the attributes' node
// $attr The name of the attribute element
// $attrWithIdx1 The name of the first attribute parent including its index
// $attrWithIdx2 The name of the second attribute parent including its index
global proc vrayAECompoundMultiSwapSimple(string $nodeName, string $attr, string $attrWithIdx1, string $attrWithIdx2) {
	string $destination1 = $nodeName + "." + $attrWithIdx1 + "." + $attr;
	string $destination2 = $nodeName + "." + $attrWithIdx2 + "." + $attr;
	string $sources1[] = `listConnections -p true ($destination1)`;
	string $sources2[] = `listConnections -p true ($destination2)`;

	// Disconnect and connect in reverse order or just swap values
	if (size($sources1))
		disconnectAttr $sources1[0] $destination1;

	if (size($sources2))
		disconnectAttr $sources2[0] $destination2;

	string $value1 = `getAttr ($destination1)`;
	string $value2 = `getAttr ($destination2)`;

	if (size($sources2))
		connectAttr $sources2[0] $destination1;
	else {
		if (`getAttr -type $destination1`=="string")
			setAttr -type "string" $destination1 $value2;
		else
			setAttr $destination1 ((float)$value2);
	}
	if (size($sources1))
		connectAttr $sources1[0] $destination2;
	else {
		if (`getAttr -type $destination2`=="string")
			setAttr -type "string" $destination2 $value1;
		else
			setAttr $destination2 ((float)$value1);
	}
}

// Swap a compound attribute element of two compound attributes.
// No check is done if a connected attribute is input or output and only input attributes are supported.
// $nodeName The name of the attributes' node
// $attr The name of the attribute element
// $attrWithIdx1 The name of the first attribute parent including its index
// $attrWithIdx2 The name of the second attribute parent including its index
global proc vrayAECompoundMultiSwapCompound(string $nodeName, string $attr, string $attrWithIdx1, string $attrWithIdx2) {
	string $destination1 = $nodeName + "." + $attrWithIdx1 + "." + $attr;
	string $destination2 = $nodeName + "." + $attrWithIdx2 + "." + $attr;
	string $sources1[] = `listConnections -p true ($destination1)`;
	string $sources2[] = `listConnections -p true ($destination2)`;

	string $attrChildren[] = `attributeQuery -node ($nodeName) -listChildren ($attr)`;

	string $childDestinations1[];
	string $childDestinations2[];
	string $childSources1[];
	string $childSources2[];
	string $childValues1[];
	string $childValues2[];

	// Collect everything necessary from the children
	for ($attrChild in $attrChildren) {
		string $childDestination1 = $nodeName + "." + $attrWithIdx1 + "." + $attrChild;
		string $childDestination2 = $nodeName + "." + $attrWithIdx2 + "." + $attrChild;
		$childDestinations1[size($childDestinations1)] = $childDestination1;
		$childDestinations2[size($childDestinations2)] = $childDestination2;
		string $allChildSources1[] = `listConnections -p true ($childDestination1)`;
		string $allChildSources2[] = `listConnections -p true ($childDestination2)`;

		$childSources1[size($childSources1)] = size($allChildSources1)? $allChildSources1[0] : "";
		$childSources2[size($childSources2)] = size($allChildSources2)? $allChildSources2[0] : "";
		$childValues1[size($childValues1)] = `getAttr ($childDestination1)`;
		$childValues2[size($childValues2)] = `getAttr ($childDestination2)`;
	}

	// Remove all connections including children
	if (size($sources1))
		disconnectAttr $sources1[0] $destination1;

	if (size($sources2))
		disconnectAttr $sources2[0] $destination2;

	for ($i=0; $i<size($attrChildren); $i++) {
		if ($childSources1[$i]!="")
			disconnectAttr $childSources1[$i] $childDestinations1[$i];
		if ($childSources2[$i]!="")
			disconnectAttr $childSources2[$i] $childDestinations2[$i];
	}

	// Swap the connected attributes including the childrens. In case of no connections, swap its children values.
	if (size($sources2)) {
		connectAttr $sources2[0] $destination1;
	} else {
		for ($i=0; $i<size($attrChildren); $i++) {
			if ($childSources2[$i]=="") {
				if (`getAttr -type $childDestinations1[$i]`=="string")
					setAttr -type "string" $childDestinations1[$i] $childValues2[$i];
				else
					setAttr $childDestinations1[$i] ((float)$childValues2[$i]);
			}
		}
	}
	for ($i=0; $i<size($attrChildren); $i++) {
		if ($childSources2[$i]!="")
			connectAttr $childSources2[$i] $childDestinations1[$i];
	}

	if (size($sources1)) {
		connectAttr $sources1[0] $destination2;
	} else {
		for ($i=0; $i<size($attrChildren); $i++) {
			if ($childSources1[$i]=="") {
				if (`getAttr -type $childDestinations2[$i]`=="string")
					setAttr -type "string" $childDestinations2[$i] $childValues1[$i];
				else
					setAttr $childDestinations2[$i] ((float)$childValues1[$i]);
			}
		}
	}
	for ($i=0; $i<size($attrChildren); $i++) {
		if ($childSources1[$i]!="")
			connectAttr $childSources1[$i] $childDestinations2[$i];
	}
}

// Swap two child attributes.
// Supports simple child attributes and compound child attributes, comprised of only simple attributes
// (e.g. R, G, B).
// $nodeName The name of the attribute's node
// $attr The name of the attribute excluding its index
// $attrWithIdx1 The name of the first attribute including its index
// $attrWithIdx2 The name of the second attribute including its index
global proc vrayAECompoundMultiSwap(string $nodeName, string $attr, string $attrWithIdx1, string $attrWithIdx2) {
	if ($attrWithIdx1=="" || $attrWithIdx2=="") {
		return;
	}
	string $attrChildren[] = `attributeQuery -node ($nodeName) -listChildren ($attr)`;
	for ($attrChild in $attrChildren) {
		int $isCompound = size(`attributeQuery -node ($nodeName) -listChildren ($attrChild)`)>0;

		if ($isCompound)
			vrayAECompoundMultiSwapCompound($nodeName, $attrChild, $attrWithIdx1, $attrWithIdx2);
		else
			vrayAECompoundMultiSwapSimple($nodeName, $attrChild, $attrWithIdx1, $attrWithIdx2);
	}
}

// Helper function for getting the name of a ramp control's frame layout name.
// Useful for layout manipulations (e.g. show/hide/resize).
global proc string vrayMakeRampLayoutName(string $attrName) {
	return vrayMakeNodeAttrControlName($attrName) + "diagramLayoutName";
}

//--------------------------------------------------------------------------------------------
// Ask the C++ code to create PhoenixCurveControl
//--------------------------------------------------------------------------------------------
global proc vrayAERampNew(string $attrName, string $label) {
	string $tokenArray[];
	int $numTokens = tokenize($attrName, ".", $tokenArray);
	string $node = $tokenArray[0];
	string $prefix = $tokenArray[1];
	tokenize($label, ".", $tokenArray);
	string $labelStr = $tokenArray[1];

	string $diagramFrameLayoutName = vrayMakeRampLayoutName($attrName);
	// This "fakeUI" path is used to keep track of all allocated PhoenixCurveControls.
	string $fakeDiagramUIPath = `setParent -q`;
	$fakeDiagramUIPath = $fakeDiagramUIPath + ".guiwin_diagram";
	
	// TODO: Pass the height as a function param
	int $diagramContainerHeight = 300;
	if ($prefix != "mixCurve")
		$diagramContainerHeight = 200;

	// [CAUTION] In order to embed the PhoenixCurveControl into the Attribute Editor we:
	// Embedded the PhoenixCurveControl in a frameLayout which is embedded within another frame layout.
	// The 1st frameLayout is used in order to be able to hide the diagram.
	// The 2nd one is used for proper GUI sizing.
	// For some reason Maya ignores the size of our diagram, putting it in another frameLayout fixes this problem.
	// [NOTE] There could be a better way to do this but unfortunately I couldn't figure out how.
	frameLayout -collapse false -label $labelStr $diagramFrameLayoutName;
		frameLayout -labelVisible false -collapsable false -w 400 -h ($diagramContainerHeight);
			string $parentLayout = `setParent -q`;
			vrayUI -a ("initDiagram") -node ($node) -parent ($parentLayout) -ph ($fakeDiagramUIPath) -src $prefix;
		setParent ..;
	setParent ..;
}

global proc vrayAERampReplace(string $attrName, string $label) {
	string $tokenArray[];
	int $numTokens = tokenize($attrName, ".", $tokenArray);
	string $node = $tokenArray[0];

	// Reattach the diagram to the new node.
	string $fakeDiagramUIPath = `setParent -q`;
	$fakeDiagramUIPath = $fakeDiagramUIPath + ".guiwin_diagram";
	vrayUI -a ("reattachDiagram") -node($node) -ph ($fakeDiagramUIPath);
}

//Enumerates all control instances of the given control, instance can be created with copy tab.
//It counts porperty editor in hypershade after 2016 too.
global proc string[] AEVRayEnumNodeCtrls(string $nodeName, string $ctrlName, string $ctrlType)
{
	// Find all nameField controls for attribute editors that are currently open for this node
	string $controls[] = `lsUI -l -type nameField`;
	string $filtered[];
	for ($ctrl in $controls) {
		if (`nameField -q -o $ctrl` == $nodeName)
			$filtered[size($filtered)] = $ctrl;
	}
	clear($controls);
	// Find all instances of the control we're searching for
	$controls = `lsUI -l -type $ctrlType`;
	string $lists[];
	for ($ctrl in $controls) {
		if (endsWith($ctrl, $ctrlName))
			$lists[size($lists)] = $ctrl;
	}
	clear($controls);
	for ($f in $filtered)
	{
		if ( !`endsWith $f "AEnodeNameField"` && !`endsWith $f "tearOffNameField"` && !`endsWith $f "ppTabNameField0"` )
			continue;
		int $i;
		string $common = "";
		string $tokens[];
		tokenize($f, "|", $tokens);
		for ($i = 0; $i < 3; $i = $i + 1) // yes, 3!
			$common = $common + $tokens[$i] + "|";
		for ($list in $lists) {
			if (`startsWith $list $common`)
				$controls[size($controls)] = $list;
		}
	}
	return $controls;
}
// ---------------------------------------------------------------------------------
// 2016-07-18 09.48 AM
// Domemaster3D for Vray Lens Shader Additions
// ---------------------------------------------------------------------------------

global proc vrayOnDomemasterStereoOn(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayDomemasterStereoOn"`) {
		int $dim = (! `getAttr ($node + ".vrayDomemasterStereoOn")`);
		if ($dim == 0) {
			// disable the physical camera
			if (`attributeQuery -exists -node $node "vrayCameraPhysicalOn"` && `getAttr ($node + ".vrayCameraPhysicalOn")`) {
				setAttr ($node + ".vrayCameraPhysicalOn") false;
				string $tmpWidget = tokenizeWidget(tokenizeWidget($widget));
				vrayOnCameraPhysicalOn($node, $attrName, $tmpWidget + "vray_cameraPhysical_camera|dummy");
			}
     	// disable the LatlongStereo camera
			if (`attributeQuery -exists -node $node "vrayLatLongStereoOn"` && `getAttr ($node + ".vrayLatLongStereoOn")`) {
				setAttr ($node + ".vrayLatLongStereoOn") false;
				string $tmpWidget = tokenizeWidget(tokenizeWidget($widget));
				vrayOnLatLongStereoOn($node, $attrName, $tmpWidget + "vray_LatLongStereo_camera|dummy");
			}
			// disable the dome camera
			if (`attributeQuery -exists -node $node "vrayCameraDomeOn"` && `getAttr ($node + ".vrayCameraDomeOn")`) {
				setAttr ($node + ".vrayCameraDomeOn") false;
				string $tmpWidget = tokenizeWidget(tokenizeWidget($widget));
				vrayOnCameraDomeOn($node, $attrName, $tmpWidget + "vray_cameraDome_camera|dummy");
			}
		}
		string $attrNames[] = {
			"vrayDomemasterStereoCamera", "vrayDomemasterStereoFovAngle", "vrayDomemasterStereoParallaxDistance",
			"vrayDomemasterStereoSeparation", "vrayDomemasterStereoForwardTilt", "vrayDomemasterStereoTiltCompensation",
			"vrayDomemasterStereoVerticalMode", "vrayDomemasterStereoSeparationMap", "vrayDomemasterStereoHeadTurnMap",
			"vrayDomemasterStereoHeadTiltMap", "vrayDomemasterStereoFlipX", "vrayDomemasterStereoFlipY",
			"vrayDomemasterStereoNeckOffset", "vrayDomemasterStereoPolesCorrection", "vrayDomemasterStereoPolesCorrectionStart",
			"vrayDomemasterStereoPolesCorrectionEnd"
		};
		vrayDimControls($node, $attrNames, $widget, $dim);
    
		// Add the Domemaster3D shader's Vray Translator Python Script settings 
		domeVrayAddTranslator();
	}
}

global proc vrayOnLatLongStereoOn(string $node, string $attrName, string $widget) {
	if (`attributeQuery -exists -node $node "vrayLatLongStereoOn"`) {
		int $dim = (! `getAttr ($node + ".vrayLatLongStereoOn")`);
		if ($dim == 0) {
			// disable the physical camera
			if (`attributeQuery -exists -node $node "vrayCameraPhysicalOn"` && `getAttr ($node + ".vrayCameraPhysicalOn")`) {
				setAttr ($node + ".vrayCameraPhysicalOn") false;
				string $tmpWidget = tokenizeWidget(tokenizeWidget($widget));
				vrayOnCameraPhysicalOn($node, $attrName, $tmpWidget + "vray_cameraPhysical_camera|dummy");
			}
      // disable the DomemasterStereo camera
			if (`attributeQuery -exists -node $node "vrayDomemasterStereoOn"` && `getAttr ($node + ".vrayDomemasterStereoOn")`) {
				setAttr ($node + ".vrayDomemasterStereoOn") false;
				string $tmpWidget = tokenizeWidget(tokenizeWidget($widget));
				vrayOnLatLongStereoOn($node, $attrName, $tmpWidget + "vray_DomemasterStereo_camera|dummy");
			}
      // disable the dome camera
			if (`attributeQuery -exists -node $node "vrayCameraDomeOn"` && `getAttr ($node + ".vrayCameraDomeOn")`) {
				setAttr ($node + ".vrayCameraDomeOn") false;
				string $tmpWidget = tokenizeWidget(tokenizeWidget($widget));
				vrayOnCameraDomeOn($node, $attrName, $tmpWidget + "vray_cameraDome_camera|dummy");
			}
		}
		string $attrNames[] = {
			"vrayLatLongStereoCamera", "vrayLatLongStereoFovVertAngle", "vrayLatLongStereoFovHorizAngle",
			"vrayLatLongStereoParallaxDistance", "vrayLatLongStereoSeparation", "vrayLatLongStereoZenithMode",
			"vrayLatLongStereoSeparationMap", "vrayLatLongStereoFlipX", "vrayLatLongStereoFlipY", "vrayLatLongStereoNeckOffset",
			"vrayLatLongStereoZenithFov", "vrayLatLongStereoPolesCorrection", "vrayLatLongStereoPolesCorrectionStart",
			"vrayLatLongStereoPolesCorrectionEnd"
		};
		vrayDimControls($node, $attrNames, $widget, $dim);
    
		// Add the Domemaster3D shader's Vray Translator Python Script settings 
		domeVrayAddTranslator();
	}
}

global proc domeVrayAddTranslator(){
  // Use the new domeVrayRender.py python script translator actions
  string $vraySettingsNode = "vraySettings";
  string $vrayTranslator = "import domeVrayRender\nreload(domeVrayRender)\ndomeVrayRender.domeVrayTranslator()";
  setAttr ($vraySettingsNode+".postTranslatePython") -type "string" $vrayTranslator;
}
// Creates the array item control for a multi attribute.
// $hasNoValueCategory - 'true' when the attribute is marked with 'vray-no-value' category
//   and should allow connections but not direct edit.
global proc vrayCreateArrayAttrControl(string $nodeName, string $attrWithIdx, int $hasNoValueCategory) {
	string $nodeDotAttr = ($nodeName+"."+$attrWithIdx);
	string $label = `attributeName -nice $nodeDotAttr`;
	string $attrType = `getAttr -type $nodeDotAttr`;
	
	setUITemplate -pst attributeEditorMultiTemplate;
		rowLayout -nc 2 -adj 1 ;
			if ($hasNoValueCategory)
				attrNavigationControlGrp -attribute $nodeDotAttr -label $label;
			else if (!strcmp($attrType, "float3"))
				attrColorSliderGrp -label $label -attribute $nodeDotAttr;
			else
				attrControlGrp -label $label -attribute $nodeDotAttr;
			
			symbolButton
				-image "smallTrash.png"
				-w 40
				-command ("removeMultiInstance -break true " + $nodeDotAttr);
		setParent..;
	setUITemplate -ppt;
}
// Add a new item to a multi attribute
global proc vrayAddNewListItem(string $nodeDotAttr) {
	int $nextAvailable = vrayGetMultiAttrNextAvailable($nodeDotAttr);
	string $plugName = $nodeDotAttr + "[" + $nextAvailable + "]";
	// Access the plug in order to create it (Maya does create it as well this way).
	getAttr -type $plugName;
}
// Create a list control for a multi attribute which contains homogeneous elements
global proc vrayListControlNew(string $label, string $tooltip, string $createItemFunc, string $nodeDotAttr) {
	string $niceName = (size($label)>0) ? $label : `attributeName -nice $nodeDotAttr`;
	string $longName = `attributeName -long $nodeDotAttr`;
	frameLayout -l $niceName -collapse false -borderVisible 1 -ann $tooltip ($longName+"Frame");
		columnLayout -adj 1 ($longName+"Column");
			rowLayout -nc 2 vrayListAddNewLayout;
				text -label "";
				button -label "Add New Item"
					-command ("vrayAddNewListItem(\"" + $nodeDotAttr+"\")") ($longName+"NewItemBtn");
			setParent ..;
		setParent ..;
	setParent ..;
	
	vrayListControlReplace($createItemFunc, $nodeDotAttr);
}
// This is the update method. It deletes the controls for previously created items.
// Then for each existing item of the multi attribute, creates a new control.
global proc vrayListControlReplace(string $createItemFunc, string $nodeDotAttr) {
	string $oldLayout = `setParent -q`;
	string $mainLayout = $oldLayout;
	string $longName = `attributeName -long $nodeDotAttr`;
	// the layout structure is part of the custom control design created in the "new" method
	// and is not something that Maya has created in prior or expects from us to do.
	string $frame = $longName+"Frame";
	string $column = $longName+"Column";
	$mainLayout += "|"+$frame+"|"+$column;
	if (!`layout -exists $mainLayout`)
		return;
	
	string $currentChildren[] = `layout -q -childArray $mainLayout`;
	for($ch in $currentChildren) {
		if($ch != "vrayListAddNewLayout") {
			deleteUI $ch;
		}
	}
	button -e -command ("vrayAddNewListItem(\"" + $nodeDotAttr+"\")") ($longName+"NewItemBtn");
	
	string $nodeName = `plugNode $nodeDotAttr`;
	// check if the parent multi attribute is marked with no default value category
	// because attributeQuery does not recognize the child attributes.
	int $noDefaultValue = vrayCheckIfAttributeHasCategory($nodeName, $longName, "vray-no-value");
	
	setParent $mainLayout;
	int $elementsCnt = `getAttr -size $nodeDotAttr`;
	if($elementsCnt > 0) {
		string $multi[] = `listAttr -multi -leaf $nodeDotAttr`;
		for($m in $multi) {
			// for each item of the multi attribute, check if it contains "[index]" in its name
			// and if so - create a control for it
			string $buffer = match("\[[0-9]+\]", $m);
			if(size($buffer) > 0)
				eval($createItemFunc, $nodeName, $m, $noDefaultValue);
		}
	}
	setParent $oldLayout;
}
// editorTemplate callCustom New handler for a button that is attached to a non-existing node attribute
global proc vrayAENoAttrButtonNew(string $controlName, string $label, string $command, string $fakeNodeDotAttr) {
	int $btnWidth = 200;
	rowLayout -nc 3 -cat 1 both 5 -columnWidth 2 $btnWidth;
	text -label "";
	string $fullCtrlName = `button -label $label $controlName`;
	vrayAENoAttrButtonReplace($fullCtrlName, $label, $command, $fakeNodeDotAttr);
}
// editorTemplate callCustom Replace handler for a button that is attached to a non-existing node attribute
global proc vrayAENoAttrButtonReplace(string $controlName, string $label, string $command, string $fakeNodeDotAttr) {
	string $nodeName = vrayGetPlugNodeName($fakeNodeDotAttr);
	button -e -c ($command+" "+$nodeName) $controlName;
}
// The button is created as a custom control attached to a non-existing attribute
global proc vrayAENoAttrButton(string $fakeNodeDotAttr, string $controlName, string $label, string $command) {
	editorTemplate -callCustom
		("vrayAENoAttrButtonNew \"" + $controlName + "\" \"" + $label + "\" \"" + $command + "\" ")
		("vrayAENoAttrButtonReplace \"" + $controlName + "\" \"" + $label + "\" \"" + $command + "\" ")
		$fakeNodeDotAttr;
	editorTemplate -suppress $fakeNodeDotAttr;
}